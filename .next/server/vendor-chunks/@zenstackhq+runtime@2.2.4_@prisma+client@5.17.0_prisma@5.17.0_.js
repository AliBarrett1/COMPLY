/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_";
exports.ids = ["vendor-chunks/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/constants.js":
/*!*****************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/constants.js ***!
  \*****************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DELEGATE_AUX_RELATION_PREFIX = exports.PRISMA_MINIMUM_VERSION = exports.PRISMA_PROXY_ENHANCER = exports.PrismaErrorCode = exports.CrudFailureReason = exports.DEFAULT_PASSWORD_SALT_LENGTH = exports.DEFAULT_RUNTIME_LOAD_PATH = void 0;\n/**\n * Default path for loading CLI-generated code\n */\nexports.DEFAULT_RUNTIME_LOAD_PATH = '.zenstack';\n/**\n * Default length of password hash salt (used by bcryptjs to hash password)\n */\nexports.DEFAULT_PASSWORD_SALT_LENGTH = 12;\n/**\n * Reasons for a CRUD operation to fail\n */\nvar CrudFailureReason;\n(function (CrudFailureReason) {\n    /**\n     * CRUD failed because of access policy violation.\n     */\n    CrudFailureReason[\"ACCESS_POLICY_VIOLATION\"] = \"ACCESS_POLICY_VIOLATION\";\n    /**\n     * CRUD succeeded but the result was not readable.\n     */\n    CrudFailureReason[\"RESULT_NOT_READABLE\"] = \"RESULT_NOT_READABLE\";\n    /**\n     * CRUD failed because of a data validation rule violation.\n     */\n    CrudFailureReason[\"DATA_VALIDATION_VIOLATION\"] = \"DATA_VALIDATION_VIOLATION\";\n})(CrudFailureReason || (exports.CrudFailureReason = CrudFailureReason = {}));\n/**\n * Prisma error codes used\n */\nvar PrismaErrorCode;\n(function (PrismaErrorCode) {\n    /**\n     * Unique constraint failed\n     */\n    PrismaErrorCode[\"UNIQUE_CONSTRAINT_FAILED\"] = \"P2002\";\n    /**\n     * A constraint failed on the database\n     */\n    PrismaErrorCode[\"CONSTRAINED_FAILED\"] = \"P2004\";\n    /**\n     * The required connected records were not found\n     */\n    PrismaErrorCode[\"REQUIRED_CONNECTED_RECORD_NOT_FOUND\"] = \"P2018\";\n    /**\n     * An operation failed because it depends on one or more records that were required but not found\n     */\n    PrismaErrorCode[\"DEPEND_ON_RECORD_NOT_FOUND\"] = \"P2025\";\n})(PrismaErrorCode || (exports.PrismaErrorCode = PrismaErrorCode = {}));\n/**\n * Field name for getting current enhancer\n */\nexports.PRISMA_PROXY_ENHANCER = '$__zenstack_enhancer';\n/**\n * Minimum Prisma version supported\n */\nexports.PRISMA_MINIMUM_VERSION = '5.0.0';\n/**\n * Prefix for auxiliary relation field generated for delegated models\n */\nexports.DELEGATE_AUX_RELATION_PREFIX = 'delegate_aux';\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHplbnN0YWNraHErcnVudGltZUAyLjIuNF9AcHJpc21hK2NsaWVudEA1LjE3LjBfcHJpc21hQDUuMTcuMF8vbm9kZV9tb2R1bGVzL0B6ZW5zdGFja2hxL3J1bnRpbWUvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9DQUFvQyxHQUFHLDhCQUE4QixHQUFHLDZCQUE2QixHQUFHLHVCQUF1QixHQUFHLHlCQUF5QixHQUFHLG9DQUFvQyxHQUFHLGlDQUFpQztBQUN0TztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3Qix5QkFBeUIseUJBQXlCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0JBQXNCLHVCQUF1Qix1QkFBdUI7QUFDckU7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFyYmxpc20vbmV4dC1qcy8uL25vZGVfbW9kdWxlcy8ucG5wbS9AemVuc3RhY2tocStydW50aW1lQDIuMi40X0BwcmlzbWErY2xpZW50QDUuMTcuMF9wcmlzbWFANS4xNy4wXy9ub2RlX21vZHVsZXMvQHplbnN0YWNraHEvcnVudGltZS9jb25zdGFudHMuanM/M2UzYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuREVMRUdBVEVfQVVYX1JFTEFUSU9OX1BSRUZJWCA9IGV4cG9ydHMuUFJJU01BX01JTklNVU1fVkVSU0lPTiA9IGV4cG9ydHMuUFJJU01BX1BST1hZX0VOSEFOQ0VSID0gZXhwb3J0cy5QcmlzbWFFcnJvckNvZGUgPSBleHBvcnRzLkNydWRGYWlsdXJlUmVhc29uID0gZXhwb3J0cy5ERUZBVUxUX1BBU1NXT1JEX1NBTFRfTEVOR1RIID0gZXhwb3J0cy5ERUZBVUxUX1JVTlRJTUVfTE9BRF9QQVRIID0gdm9pZCAwO1xuLyoqXG4gKiBEZWZhdWx0IHBhdGggZm9yIGxvYWRpbmcgQ0xJLWdlbmVyYXRlZCBjb2RlXG4gKi9cbmV4cG9ydHMuREVGQVVMVF9SVU5USU1FX0xPQURfUEFUSCA9ICcuemVuc3RhY2snO1xuLyoqXG4gKiBEZWZhdWx0IGxlbmd0aCBvZiBwYXNzd29yZCBoYXNoIHNhbHQgKHVzZWQgYnkgYmNyeXB0anMgdG8gaGFzaCBwYXNzd29yZClcbiAqL1xuZXhwb3J0cy5ERUZBVUxUX1BBU1NXT1JEX1NBTFRfTEVOR1RIID0gMTI7XG4vKipcbiAqIFJlYXNvbnMgZm9yIGEgQ1JVRCBvcGVyYXRpb24gdG8gZmFpbFxuICovXG52YXIgQ3J1ZEZhaWx1cmVSZWFzb247XG4oZnVuY3Rpb24gKENydWRGYWlsdXJlUmVhc29uKSB7XG4gICAgLyoqXG4gICAgICogQ1JVRCBmYWlsZWQgYmVjYXVzZSBvZiBhY2Nlc3MgcG9saWN5IHZpb2xhdGlvbi5cbiAgICAgKi9cbiAgICBDcnVkRmFpbHVyZVJlYXNvbltcIkFDQ0VTU19QT0xJQ1lfVklPTEFUSU9OXCJdID0gXCJBQ0NFU1NfUE9MSUNZX1ZJT0xBVElPTlwiO1xuICAgIC8qKlxuICAgICAqIENSVUQgc3VjY2VlZGVkIGJ1dCB0aGUgcmVzdWx0IHdhcyBub3QgcmVhZGFibGUuXG4gICAgICovXG4gICAgQ3J1ZEZhaWx1cmVSZWFzb25bXCJSRVNVTFRfTk9UX1JFQURBQkxFXCJdID0gXCJSRVNVTFRfTk9UX1JFQURBQkxFXCI7XG4gICAgLyoqXG4gICAgICogQ1JVRCBmYWlsZWQgYmVjYXVzZSBvZiBhIGRhdGEgdmFsaWRhdGlvbiBydWxlIHZpb2xhdGlvbi5cbiAgICAgKi9cbiAgICBDcnVkRmFpbHVyZVJlYXNvbltcIkRBVEFfVkFMSURBVElPTl9WSU9MQVRJT05cIl0gPSBcIkRBVEFfVkFMSURBVElPTl9WSU9MQVRJT05cIjtcbn0pKENydWRGYWlsdXJlUmVhc29uIHx8IChleHBvcnRzLkNydWRGYWlsdXJlUmVhc29uID0gQ3J1ZEZhaWx1cmVSZWFzb24gPSB7fSkpO1xuLyoqXG4gKiBQcmlzbWEgZXJyb3IgY29kZXMgdXNlZFxuICovXG52YXIgUHJpc21hRXJyb3JDb2RlO1xuKGZ1bmN0aW9uIChQcmlzbWFFcnJvckNvZGUpIHtcbiAgICAvKipcbiAgICAgKiBVbmlxdWUgY29uc3RyYWludCBmYWlsZWRcbiAgICAgKi9cbiAgICBQcmlzbWFFcnJvckNvZGVbXCJVTklRVUVfQ09OU1RSQUlOVF9GQUlMRURcIl0gPSBcIlAyMDAyXCI7XG4gICAgLyoqXG4gICAgICogQSBjb25zdHJhaW50IGZhaWxlZCBvbiB0aGUgZGF0YWJhc2VcbiAgICAgKi9cbiAgICBQcmlzbWFFcnJvckNvZGVbXCJDT05TVFJBSU5FRF9GQUlMRURcIl0gPSBcIlAyMDA0XCI7XG4gICAgLyoqXG4gICAgICogVGhlIHJlcXVpcmVkIGNvbm5lY3RlZCByZWNvcmRzIHdlcmUgbm90IGZvdW5kXG4gICAgICovXG4gICAgUHJpc21hRXJyb3JDb2RlW1wiUkVRVUlSRURfQ09OTkVDVEVEX1JFQ09SRF9OT1RfRk9VTkRcIl0gPSBcIlAyMDE4XCI7XG4gICAgLyoqXG4gICAgICogQW4gb3BlcmF0aW9uIGZhaWxlZCBiZWNhdXNlIGl0IGRlcGVuZHMgb24gb25lIG9yIG1vcmUgcmVjb3JkcyB0aGF0IHdlcmUgcmVxdWlyZWQgYnV0IG5vdCBmb3VuZFxuICAgICAqL1xuICAgIFByaXNtYUVycm9yQ29kZVtcIkRFUEVORF9PTl9SRUNPUkRfTk9UX0ZPVU5EXCJdID0gXCJQMjAyNVwiO1xufSkoUHJpc21hRXJyb3JDb2RlIHx8IChleHBvcnRzLlByaXNtYUVycm9yQ29kZSA9IFByaXNtYUVycm9yQ29kZSA9IHt9KSk7XG4vKipcbiAqIEZpZWxkIG5hbWUgZm9yIGdldHRpbmcgY3VycmVudCBlbmhhbmNlclxuICovXG5leHBvcnRzLlBSSVNNQV9QUk9YWV9FTkhBTkNFUiA9ICckX196ZW5zdGFja19lbmhhbmNlcic7XG4vKipcbiAqIE1pbmltdW0gUHJpc21hIHZlcnNpb24gc3VwcG9ydGVkXG4gKi9cbmV4cG9ydHMuUFJJU01BX01JTklNVU1fVkVSU0lPTiA9ICc1LjAuMCc7XG4vKipcbiAqIFByZWZpeCBmb3IgYXV4aWxpYXJ5IHJlbGF0aW9uIGZpZWxkIGdlbmVyYXRlZCBmb3IgZGVsZWdhdGVkIG1vZGVsc1xuICovXG5leHBvcnRzLkRFTEVHQVRFX0FVWF9SRUxBVElPTl9QUkVGSVggPSAnZGVsZWdhdGVfYXV4Jztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/cross/index.js":
/*!*******************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/cross/index.js ***!
  \*******************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/cross/index.ts\nvar cross_exports = {};\n__export(cross_exports, {\n  ModelDataVisitor: () => ModelDataVisitor,\n  NestedReadVisitor: () => NestedReadVisitor,\n  NestedWriteVisitor: () => NestedWriteVisitor,\n  PrismaWriteActions: () => PrismaWriteActions,\n  applyMutation: () => applyMutation,\n  enumerate: () => enumerate,\n  getFields: () => getFields,\n  getIdFields: () => getIdFields,\n  getModelFields: () => getModelFields,\n  getModelInfo: () => getModelInfo,\n  getMutatedModels: () => getMutatedModels,\n  getReadModels: () => getReadModels,\n  getUniqueConstraints: () => getUniqueConstraints,\n  isDelegateModel: () => isDelegateModel,\n  requireField: () => requireField,\n  resolveField: () => resolveField,\n  zip: () => zip\n});\nmodule.exports = __toCommonJS(cross_exports);\n\n// src/cross/model-data-visitor.ts\nvar ModelDataVisitor = class {\n  constructor(modelMeta) {\n    this.modelMeta = modelMeta;\n  }\n  /**\n   * Visits the given model data.\n   */\n  visit(model, data, callback) {\n    if (!data || typeof data !== \"object\") {\n      return;\n    }\n    const scalarData = {};\n    const subTasks = [];\n    for (const [k, v] of Object.entries(data)) {\n      const field = resolveField(this.modelMeta, model, k);\n      if (field && field.isDataModel) {\n        if (field.isArray && Array.isArray(v)) {\n          subTasks.push(...v.map((item) => ({ model: field.type, data: item })));\n        } else {\n          subTasks.push({ model: field.type, data: v });\n        }\n      } else {\n        scalarData[k] = v;\n      }\n    }\n    callback(model, data, scalarData);\n    subTasks.forEach(({ model: model2, data: data2 }) => this.visit(model2, data2, callback));\n  }\n};\n\n// src/cross/model-meta.ts\nvar import_lower_case_first = __webpack_require__(/*! lower-case-first */ \"(rsc)/./node_modules/.pnpm/lower-case-first@2.0.2/node_modules/lower-case-first/dist.es2015/index.js\");\nfunction resolveField(modelMeta, model, field) {\n  var _a, _b;\n  return (_b = (_a = modelMeta.models[(0, import_lower_case_first.lowerCaseFirst)(model)]) == null ? void 0 : _a.fields) == null ? void 0 : _b[field];\n}\nfunction requireField(modelMeta, model, field) {\n  const f = resolveField(modelMeta, model, field);\n  if (!f) {\n    throw new Error(`Field ${model}.${field} cannot be resolved`);\n  }\n  return f;\n}\nfunction getFields(modelMeta, model) {\n  var _a;\n  return (_a = modelMeta.models[(0, import_lower_case_first.lowerCaseFirst)(model)]) == null ? void 0 : _a.fields;\n}\nfunction getUniqueConstraints(modelMeta, model) {\n  var _a;\n  return (_a = modelMeta.models[(0, import_lower_case_first.lowerCaseFirst)(model)]) == null ? void 0 : _a.uniqueConstraints;\n}\n\n// src/cross/mutator.ts\nvar import_uuid = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-node/index.js\");\nvar import_deepcopy = __toESM(__webpack_require__(/*! deepcopy */ \"(rsc)/./node_modules/.pnpm/deepcopy@2.1.0/node_modules/deepcopy/index.mjs\"));\nfunction applyMutation(queryModel, queryOp, queryData, mutationModel, mutationOp, mutationArgs, modelMeta, logging) {\n  return __async(this, null, function* () {\n    if ([\"count\", \"aggregate\", \"groupBy\"].includes(queryOp)) {\n      return void 0;\n    }\n    let resultData = queryData;\n    let updated = false;\n    const visitor = new NestedWriteVisitor(modelMeta, {\n      create: (model, args) => {\n        if (model === queryModel) {\n          const r = createMutate(queryModel, queryOp, resultData, args, modelMeta, logging);\n          if (r) {\n            resultData = r;\n            updated = true;\n          }\n        }\n      },\n      createMany: (model, args) => {\n        if (model === queryModel && (args == null ? void 0 : args.data)) {\n          for (const oneArg of enumerate(args.data)) {\n            const r = createMutate(queryModel, queryOp, resultData, oneArg, modelMeta, logging);\n            if (r) {\n              resultData = r;\n              updated = true;\n            }\n          }\n        }\n      },\n      update: (model, args) => {\n        if (model === queryModel) {\n          const r = updateMutate(queryModel, resultData, model, args, modelMeta, logging);\n          if (r) {\n            resultData = r;\n            updated = true;\n          }\n        }\n      },\n      delete: (model, args) => {\n        if (model === queryModel) {\n          const r = deleteMutate(queryModel, resultData, model, args, modelMeta, logging);\n          if (r) {\n            resultData = r;\n            updated = true;\n          }\n        }\n      }\n    });\n    yield visitor.visit(mutationModel, mutationOp, mutationArgs);\n    return updated ? resultData : void 0;\n  });\n}\nfunction createMutate(queryModel, queryOp, currentData, newData, modelMeta, logging) {\n  if (!newData) {\n    return void 0;\n  }\n  if (queryOp !== \"findMany\") {\n    return void 0;\n  }\n  const modelFields = getFields(modelMeta, queryModel);\n  if (!modelFields) {\n    return void 0;\n  }\n  const insert = {};\n  const newDataFields = Object.keys(newData);\n  Object.entries(modelFields).forEach(([name, field]) => {\n    var _a, _b, _c, _d;\n    if (field.isDataModel) {\n      return;\n    }\n    if (newDataFields.includes(name)) {\n      insert[name] = newData[name];\n    } else {\n      const defaultAttr = (_a = field.attributes) == null ? void 0 : _a.find((attr) => attr.name === \"@default\");\n      if (field.type === \"DateTime\") {\n        if (defaultAttr || ((_b = field.attributes) == null ? void 0 : _b.some((attr) => attr.name === \"@updatedAt\"))) {\n          insert[name] = /* @__PURE__ */ new Date();\n        }\n      } else if (((_d = (_c = defaultAttr == null ? void 0 : defaultAttr.args) == null ? void 0 : _c[0]) == null ? void 0 : _d.value) !== void 0) {\n        insert[name] = defaultAttr.args[0].value;\n      }\n    }\n  });\n  const idFields = getIdFields(modelMeta, queryModel, false);\n  idFields.forEach((f) => {\n    if (insert[f.name] === void 0) {\n      if (f.type === \"Int\" || f.type === \"BigInt\") {\n        const currMax = Array.isArray(currentData) ? Math.max(\n          ...[...currentData].map((item) => {\n            const idv = parseInt(item[f.name]);\n            return isNaN(idv) ? 0 : idv;\n          })\n        ) : 0;\n        insert[f.name] = currMax + 1;\n      } else {\n        insert[f.name] = (0, import_uuid.v4)();\n      }\n    }\n  });\n  insert.$optimistic = true;\n  if (logging) {\n    console.log(`Optimistic create for ${queryModel}:`, insert);\n  }\n  return [insert, ...Array.isArray(currentData) ? currentData : []];\n}\nfunction updateMutate(queryModel, currentData, mutateModel, mutateArgs, modelMeta, logging) {\n  if (!currentData) {\n    return void 0;\n  }\n  if (!(mutateArgs == null ? void 0 : mutateArgs.where) || !(mutateArgs == null ? void 0 : mutateArgs.data)) {\n    return void 0;\n  }\n  let updated = false;\n  for (const item of enumerate(currentData)) {\n    const visitor = new ModelDataVisitor(modelMeta);\n    visitor.visit(queryModel, item, (model, _data, scalarData) => {\n      if (model === mutateModel && idFieldsMatch(model, scalarData, mutateArgs.where, modelMeta)) {\n        Object.keys(item).forEach((k) => {\n          if (mutateArgs.data[k] !== void 0) {\n            item[k] = mutateArgs.data[k];\n          }\n        });\n        item.$optimistic = true;\n        updated = true;\n        if (logging) {\n          console.log(`Optimistic update for ${queryModel}:`, item);\n        }\n      }\n    });\n  }\n  return updated ? (0, import_deepcopy.default)(currentData) : void 0;\n}\nfunction deleteMutate(queryModel, currentData, mutateModel, mutateArgs, modelMeta, logging) {\n  if (!currentData || !mutateArgs) {\n    return void 0;\n  }\n  if (queryModel !== mutateModel) {\n    return void 0;\n  }\n  let updated = false;\n  let result = currentData;\n  if (Array.isArray(currentData)) {\n    for (const item of currentData) {\n      if (idFieldsMatch(mutateModel, item, mutateArgs, modelMeta)) {\n        result = result.filter((x) => x !== item);\n        updated = true;\n        if (logging) {\n          console.log(`Optimistic delete for ${queryModel}:`, item);\n        }\n      }\n    }\n  } else {\n    if (idFieldsMatch(mutateModel, currentData, mutateArgs, modelMeta)) {\n      result = null;\n      updated = true;\n      if (logging) {\n        console.log(`Optimistic delete for ${queryModel}:`, currentData);\n      }\n    }\n  }\n  return updated ? result : void 0;\n}\nfunction idFieldsMatch(model, x, y, modelMeta) {\n  if (!x || !y || typeof x !== \"object\" || typeof y !== \"object\") {\n    return false;\n  }\n  const idFields = getIdFields(modelMeta, model, false);\n  if (idFields.length === 0) {\n    return false;\n  }\n  return idFields.every((f) => x[f.name] === y[f.name]);\n}\n\n// src/cross/nested-read-visitor.ts\nvar NestedReadVisitor = class {\n  constructor(modelMeta, callback) {\n    this.modelMeta = modelMeta;\n    this.callback = callback;\n  }\n  doVisit(model, field, kind, args) {\n    if (this.callback.field) {\n      const r = this.callback.field(model, field, kind, args);\n      if (r === false) {\n        return;\n      }\n    }\n    if (!args || typeof args !== \"object\") {\n      return;\n    }\n    let selectInclude;\n    let nextKind;\n    if (args.select) {\n      selectInclude = args.select;\n      nextKind = \"select\";\n    } else if (args.include) {\n      selectInclude = args.include;\n      nextKind = \"include\";\n    }\n    if (selectInclude && typeof selectInclude === \"object\") {\n      for (const [k, v] of Object.entries(selectInclude)) {\n        if (k === \"_count\" && typeof v === \"object\" && v) {\n          this.doVisit(model, field, kind, v);\n        } else {\n          const field2 = resolveField(this.modelMeta, model, k);\n          if (field2) {\n            this.doVisit(field2.type, field2, nextKind, v);\n          }\n        }\n      }\n    }\n  }\n  visit(model, args) {\n    this.doVisit(model, void 0, void 0, args);\n  }\n};\n\n// src/cross/types.ts\nvar PrismaWriteActions = [\n  \"create\",\n  \"createMany\",\n  \"connectOrCreate\",\n  \"update\",\n  \"updateMany\",\n  \"upsert\",\n  \"connect\",\n  \"disconnect\",\n  \"set\",\n  \"delete\",\n  \"deleteMany\"\n];\n\n// src/cross/utils.ts\nvar import_lower_case_first2 = __webpack_require__(/*! lower-case-first */ \"(rsc)/./node_modules/.pnpm/lower-case-first@2.0.2/node_modules/lower-case-first/dist.es2015/index.js\");\nfunction getModelFields(data) {\n  return data ? Object.keys(data) : [];\n}\nfunction enumerate(x) {\n  if (x === null || x === void 0) {\n    return [];\n  } else if (Array.isArray(x)) {\n    return x;\n  } else {\n    return [x];\n  }\n}\nfunction zip(x, y) {\n  if (Array.isArray(x)) {\n    if (!Array.isArray(y)) {\n      throw new Error(\"x and y should be both array or both scalar\");\n    }\n    if (x.length !== y.length) {\n      throw new Error(\"x and y should have the same length\");\n    }\n    return x.map((_, i) => [x[i], y[i]]);\n  } else {\n    if (Array.isArray(y)) {\n      throw new Error(\"x and y should be both array or both scalar\");\n    }\n    return [[x, y]];\n  }\n}\nfunction getIdFields(modelMeta, model, throwIfNotFound = false) {\n  var _a, _b;\n  const uniqueConstraints = (_b = (_a = modelMeta.models[(0, import_lower_case_first2.lowerCaseFirst)(model)]) == null ? void 0 : _a.uniqueConstraints) != null ? _b : {};\n  const entries = Object.values(uniqueConstraints);\n  if (entries.length === 0) {\n    if (throwIfNotFound) {\n      throw new Error(`Model ${model} does not have any id field`);\n    }\n    return [];\n  }\n  return entries[0].fields.map((f) => requireField(modelMeta, model, f));\n}\nfunction getModelInfo(modelMeta, model, throwIfNotFound = false) {\n  const info = modelMeta.models[(0, import_lower_case_first2.lowerCaseFirst)(model)];\n  if (!info && throwIfNotFound) {\n    throw new Error(`Unable to load info for ${model}`);\n  }\n  return info;\n}\nfunction isDelegateModel(modelMeta, model) {\n  var _a, _b;\n  return !!((_b = (_a = getModelInfo(modelMeta, model)) == null ? void 0 : _a.attributes) == null ? void 0 : _b.some((attr) => attr.name === \"@@delegate\"));\n}\n\n// src/cross/nested-write-visitor.ts\nvar NestedWriteVisitor = class {\n  constructor(modelMeta, callback) {\n    this.modelMeta = modelMeta;\n    this.callback = callback;\n  }\n  isPrismaWriteAction(value) {\n    return PrismaWriteActions.includes(value);\n  }\n  /**\n   * Start visiting\n   *\n   * @see NestedWriterVisitorCallback\n   */\n  visit(model, action, args) {\n    return __async(this, null, function* () {\n      if (!args) {\n        return;\n      }\n      let topData = args;\n      switch (action) {\n        case \"create\":\n          topData = topData.data;\n          break;\n        case \"delete\":\n        case \"deleteMany\":\n          topData = topData.where;\n          break;\n      }\n      yield this.doVisit(model, action, topData, void 0, void 0, []);\n    });\n  }\n  doVisit(model, action, data, parent, field, nestingPath) {\n    return __async(this, null, function* () {\n      if (!data) {\n        return;\n      }\n      const toplevel = field == void 0;\n      const context = { parent, field, nestingPath: [...nestingPath] };\n      const pushNewContext = (field2, model2, where, unique = false) => {\n        return __spreadProps(__spreadValues({}, context), { nestingPath: [...context.nestingPath, { field: field2, model: model2, where, unique }] });\n      };\n      switch (action) {\n        case \"create\":\n          for (const item of this.enumerateReverse(data)) {\n            const newContext = pushNewContext(field, model, {});\n            let callbackResult;\n            if (this.callback.create) {\n              callbackResult = yield this.callback.create(model, item, newContext);\n            }\n            if (callbackResult !== false) {\n              const subPayload = typeof callbackResult === \"object\" ? callbackResult : item;\n              yield this.visitSubPayload(model, action, subPayload, newContext.nestingPath);\n            }\n          }\n          break;\n        case \"createMany\":\n          if (data) {\n            const newContext = pushNewContext(field, model, {});\n            let callbackResult;\n            if (this.callback.createMany) {\n              callbackResult = yield this.callback.createMany(model, data, newContext);\n            }\n            if (callbackResult !== false) {\n              const subPayload = typeof callbackResult === \"object\" ? callbackResult : data.data;\n              yield this.visitSubPayload(model, action, subPayload, newContext.nestingPath);\n            }\n          }\n          break;\n        case \"connectOrCreate\":\n          for (const item of this.enumerateReverse(data)) {\n            const newContext = pushNewContext(field, model, item.where);\n            let callbackResult;\n            if (this.callback.connectOrCreate) {\n              callbackResult = yield this.callback.connectOrCreate(model, item, newContext);\n            }\n            if (callbackResult !== false) {\n              const subPayload = typeof callbackResult === \"object\" ? callbackResult : item.create;\n              yield this.visitSubPayload(model, action, subPayload, newContext.nestingPath);\n            }\n          }\n          break;\n        case \"connect\":\n          if (this.callback.connect) {\n            for (const item of this.enumerateReverse(data)) {\n              const newContext = pushNewContext(field, model, item, true);\n              yield this.callback.connect(model, item, newContext);\n            }\n          }\n          break;\n        case \"disconnect\":\n          if (this.callback.disconnect) {\n            for (const item of this.enumerateReverse(data)) {\n              const newContext = pushNewContext(field, model, item, typeof item === \"object\");\n              yield this.callback.disconnect(model, item, newContext);\n            }\n          }\n          break;\n        case \"set\":\n          if (this.callback.set) {\n            for (const item of this.enumerateReverse(data)) {\n              const newContext = pushNewContext(field, model, item, true);\n              yield this.callback.set(model, item, newContext);\n            }\n          }\n          break;\n        case \"update\":\n          for (const item of this.enumerateReverse(data)) {\n            const newContext = pushNewContext(field, model, item.where);\n            let callbackResult;\n            if (this.callback.update) {\n              callbackResult = yield this.callback.update(model, item, newContext);\n            }\n            if (callbackResult !== false) {\n              const subPayload = typeof callbackResult === \"object\" ? callbackResult : typeof item.data === \"object\" ? item.data : item;\n              yield this.visitSubPayload(model, action, subPayload, newContext.nestingPath);\n            }\n          }\n          break;\n        case \"updateMany\":\n          for (const item of this.enumerateReverse(data)) {\n            const newContext = pushNewContext(field, model, item.where);\n            let callbackResult;\n            if (this.callback.updateMany) {\n              callbackResult = yield this.callback.updateMany(model, item, newContext);\n            }\n            if (callbackResult !== false) {\n              const subPayload = typeof callbackResult === \"object\" ? callbackResult : item;\n              yield this.visitSubPayload(model, action, subPayload, newContext.nestingPath);\n            }\n          }\n          break;\n        case \"upsert\": {\n          for (const item of this.enumerateReverse(data)) {\n            const newContext = pushNewContext(field, model, item.where);\n            let callbackResult;\n            if (this.callback.upsert) {\n              callbackResult = yield this.callback.upsert(model, item, newContext);\n            }\n            if (callbackResult !== false) {\n              if (typeof callbackResult === \"object\") {\n                yield this.visitSubPayload(model, action, callbackResult, newContext.nestingPath);\n              } else {\n                yield this.visitSubPayload(model, action, item.create, newContext.nestingPath);\n                yield this.visitSubPayload(model, action, item.update, newContext.nestingPath);\n              }\n            }\n          }\n          break;\n        }\n        case \"delete\": {\n          if (this.callback.delete) {\n            for (const item of this.enumerateReverse(data)) {\n              const newContext = pushNewContext(field, model, toplevel ? item.where : item);\n              yield this.callback.delete(model, item, newContext);\n            }\n          }\n          break;\n        }\n        case \"deleteMany\":\n          if (this.callback.deleteMany) {\n            for (const item of this.enumerateReverse(data)) {\n              const newContext = pushNewContext(field, model, toplevel ? item.where : item);\n              yield this.callback.deleteMany(model, item, newContext);\n            }\n          }\n          break;\n        default: {\n          throw new Error(`unhandled action type ${action}`);\n        }\n      }\n    });\n  }\n  visitSubPayload(model, action, payload, nestingPath) {\n    return __async(this, null, function* () {\n      for (const field of getModelFields(payload)) {\n        const fieldInfo = resolveField(this.modelMeta, model, field);\n        if (!fieldInfo) {\n          continue;\n        }\n        if (fieldInfo.isDataModel) {\n          if (payload[field]) {\n            for (const [subAction, subData] of Object.entries(payload[field])) {\n              if (this.isPrismaWriteAction(subAction) && subData) {\n                yield this.doVisit(fieldInfo.type, subAction, subData, payload[field], fieldInfo, [\n                  ...nestingPath\n                ]);\n              }\n            }\n          }\n        } else {\n          if (this.callback.field) {\n            yield this.callback.field(fieldInfo, action, payload[field], {\n              parent: payload,\n              nestingPath,\n              field: fieldInfo\n            });\n          }\n        }\n      }\n    });\n  }\n  // enumerate a (possible) array in reverse order, so that the enumeration\n  // callback can safely delete the current item\n  *enumerateReverse(data) {\n    if (Array.isArray(data)) {\n      for (let i = data.length - 1; i >= 0; i--) {\n        yield data[i];\n      }\n    } else {\n      yield data;\n    }\n  }\n};\n\n// src/cross/query-analyzer.ts\nvar import_lower_case_first3 = __webpack_require__(/*! lower-case-first */ \"(rsc)/./node_modules/.pnpm/lower-case-first@2.0.2/node_modules/lower-case-first/dist.es2015/index.js\");\nfunction getReadModels(model, modelMeta, args) {\n  const result = /* @__PURE__ */ new Set();\n  result.add(model);\n  const visitor = new NestedReadVisitor(modelMeta, {\n    field: (model2) => {\n      result.add(model2);\n      return true;\n    }\n  });\n  visitor.visit(model, args);\n  return [...result];\n}\nfunction getMutatedModels(model, operation, mutationArgs, modelMeta) {\n  return __async(this, null, function* () {\n    const result = /* @__PURE__ */ new Set();\n    result.add(model);\n    if (mutationArgs) {\n      const addModel = (model2) => void result.add(model2);\n      const addCascades = (model2) => {\n        const cascades = /* @__PURE__ */ new Set();\n        const visited = /* @__PURE__ */ new Set();\n        collectDeleteCascades(model2, modelMeta, cascades, visited);\n        cascades.forEach((m) => addModel(m));\n      };\n      const visitor = new NestedWriteVisitor(modelMeta, {\n        create: addModel,\n        createMany: addModel,\n        connectOrCreate: addModel,\n        connect: addModel,\n        disconnect: addModel,\n        set: addModel,\n        update: addModel,\n        updateMany: addModel,\n        upsert: addModel,\n        delete: (model2) => {\n          addModel(model2);\n          addCascades(model2);\n        },\n        deleteMany: (model2) => {\n          addModel(model2);\n          addCascades(model2);\n        }\n      });\n      yield visitor.visit(model, operation, mutationArgs);\n    }\n    result.forEach((m) => {\n      getBaseRecursively(m, modelMeta, result);\n    });\n    return [...result];\n  });\n}\nfunction collectDeleteCascades(model, modelMeta, result, visited) {\n  var _a;\n  if (visited.has(model)) {\n    return;\n  }\n  visited.add(model);\n  const cascades = (_a = modelMeta.deleteCascade) == null ? void 0 : _a[(0, import_lower_case_first3.lowerCaseFirst)(model)];\n  if (!cascades) {\n    return;\n  }\n  cascades.forEach((m) => {\n    result.add(m);\n    collectDeleteCascades(m, modelMeta, result, visited);\n  });\n}\nfunction getBaseRecursively(model, modelMeta, result) {\n  var _a;\n  const bases = (_a = getModelInfo(modelMeta, model)) == null ? void 0 : _a.baseTypes;\n  if (bases) {\n    bases.forEach((base) => {\n      result.add(base);\n      getBaseRecursively(base, modelMeta, result);\n    });\n  }\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHplbnN0YWNraHErcnVudGltZUAyLjIuNF9AcHJpc21hK2NsaWVudEA1LjE3LjBfcHJpc21hQDUuMTcuMF8vbm9kZV9tb2R1bGVzL0B6ZW5zdGFja2hxL3J1bnRpbWUvY3Jvc3MvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsOEJBQThCO0FBQ3ZHO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywrQkFBK0I7QUFDN0UsVUFBVTtBQUNWLDBCQUEwQiw0QkFBNEI7QUFDdEQ7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNEJBQTRCO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsbUJBQU8sQ0FBQyw4SEFBa0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsTUFBTSxHQUFHLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLDRGQUFNO0FBQ2hDLDhCQUE4QixtQkFBTyxDQUFDLDJGQUFVO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHlDQUF5QyxXQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxXQUFXO0FBQzFEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFdBQVc7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFdBQVc7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixtQkFBTyxDQUFDLDhIQUFrQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsTUFBTTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSw4Q0FBOEMsY0FBYyx3Q0FBd0MsNkNBQTZDLEdBQUc7QUFDcEo7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixtQkFBTyxDQUFDLDhIQUFrQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBa0JMO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFyYmxpc20vbmV4dC1qcy8uL25vZGVfbW9kdWxlcy8ucG5wbS9AemVuc3RhY2tocStydW50aW1lQDIuMi40X0BwcmlzbWErY2xpZW50QDUuMTcuMF9wcmlzbWFANS4xNy4wXy9ub2RlX21vZHVsZXMvQHplbnN0YWNraHEvcnVudGltZS9jcm9zcy9pbmRleC5qcz80ODAyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9FU00gPSAobW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+ICh0YXJnZXQgPSBtb2QgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2QpKSA6IHt9LCBfX2NvcHlQcm9wcyhcbiAgLy8gSWYgdGhlIGltcG9ydGVyIGlzIGluIG5vZGUgY29tcGF0aWJpbGl0eSBtb2RlIG9yIHRoaXMgaXMgbm90IGFuIEVTTVxuICAvLyBmaWxlIHRoYXQgaGFzIGJlZW4gY29udmVydGVkIHRvIGEgQ29tbW9uSlMgZmlsZSB1c2luZyBhIEJhYmVsLVxuICAvLyBjb21wYXRpYmxlIHRyYW5zZm9ybSAoaS5lLiBcIl9fZXNNb2R1bGVcIiBoYXMgbm90IGJlZW4gc2V0KSwgdGhlbiBzZXRcbiAgLy8gXCJkZWZhdWx0XCIgdG8gdGhlIENvbW1vbkpTIFwibW9kdWxlLmV4cG9ydHNcIiBmb3Igbm9kZSBjb21wYXRpYmlsaXR5LlxuICBpc05vZGVNb2RlIHx8ICFtb2QgfHwgIW1vZC5fX2VzTW9kdWxlID8gX19kZWZQcm9wKHRhcmdldCwgXCJkZWZhdWx0XCIsIHsgdmFsdWU6IG1vZCwgZW51bWVyYWJsZTogdHJ1ZSB9KSA6IHRhcmdldCxcbiAgbW9kXG4pKTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIF9fYXN5bmMgPSAoX190aGlzLCBfX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdmFyIGZ1bGZpbGxlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcmVqZWN0ZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLnRocm93KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzdGVwID0gKHgpID0+IHguZG9uZSA/IHJlc29sdmUoeC52YWx1ZSkgOiBQcm9taXNlLnJlc29sdmUoeC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkoX190aGlzLCBfX2FyZ3VtZW50cykpLm5leHQoKSk7XG4gIH0pO1xufTtcblxuLy8gc3JjL2Nyb3NzL2luZGV4LnRzXG52YXIgY3Jvc3NfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoY3Jvc3NfZXhwb3J0cywge1xuICBNb2RlbERhdGFWaXNpdG9yOiAoKSA9PiBNb2RlbERhdGFWaXNpdG9yLFxuICBOZXN0ZWRSZWFkVmlzaXRvcjogKCkgPT4gTmVzdGVkUmVhZFZpc2l0b3IsXG4gIE5lc3RlZFdyaXRlVmlzaXRvcjogKCkgPT4gTmVzdGVkV3JpdGVWaXNpdG9yLFxuICBQcmlzbWFXcml0ZUFjdGlvbnM6ICgpID0+IFByaXNtYVdyaXRlQWN0aW9ucyxcbiAgYXBwbHlNdXRhdGlvbjogKCkgPT4gYXBwbHlNdXRhdGlvbixcbiAgZW51bWVyYXRlOiAoKSA9PiBlbnVtZXJhdGUsXG4gIGdldEZpZWxkczogKCkgPT4gZ2V0RmllbGRzLFxuICBnZXRJZEZpZWxkczogKCkgPT4gZ2V0SWRGaWVsZHMsXG4gIGdldE1vZGVsRmllbGRzOiAoKSA9PiBnZXRNb2RlbEZpZWxkcyxcbiAgZ2V0TW9kZWxJbmZvOiAoKSA9PiBnZXRNb2RlbEluZm8sXG4gIGdldE11dGF0ZWRNb2RlbHM6ICgpID0+IGdldE11dGF0ZWRNb2RlbHMsXG4gIGdldFJlYWRNb2RlbHM6ICgpID0+IGdldFJlYWRNb2RlbHMsXG4gIGdldFVuaXF1ZUNvbnN0cmFpbnRzOiAoKSA9PiBnZXRVbmlxdWVDb25zdHJhaW50cyxcbiAgaXNEZWxlZ2F0ZU1vZGVsOiAoKSA9PiBpc0RlbGVnYXRlTW9kZWwsXG4gIHJlcXVpcmVGaWVsZDogKCkgPT4gcmVxdWlyZUZpZWxkLFxuICByZXNvbHZlRmllbGQ6ICgpID0+IHJlc29sdmVGaWVsZCxcbiAgemlwOiAoKSA9PiB6aXBcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoY3Jvc3NfZXhwb3J0cyk7XG5cbi8vIHNyYy9jcm9zcy9tb2RlbC1kYXRhLXZpc2l0b3IudHNcbnZhciBNb2RlbERhdGFWaXNpdG9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihtb2RlbE1ldGEpIHtcbiAgICB0aGlzLm1vZGVsTWV0YSA9IG1vZGVsTWV0YTtcbiAgfVxuICAvKipcbiAgICogVmlzaXRzIHRoZSBnaXZlbiBtb2RlbCBkYXRhLlxuICAgKi9cbiAgdmlzaXQobW9kZWwsIGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNjYWxhckRhdGEgPSB7fTtcbiAgICBjb25zdCBzdWJUYXNrcyA9IFtdO1xuICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKGRhdGEpKSB7XG4gICAgICBjb25zdCBmaWVsZCA9IHJlc29sdmVGaWVsZCh0aGlzLm1vZGVsTWV0YSwgbW9kZWwsIGspO1xuICAgICAgaWYgKGZpZWxkICYmIGZpZWxkLmlzRGF0YU1vZGVsKSB7XG4gICAgICAgIGlmIChmaWVsZC5pc0FycmF5ICYmIEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgICBzdWJUYXNrcy5wdXNoKC4uLnYubWFwKChpdGVtKSA9PiAoeyBtb2RlbDogZmllbGQudHlwZSwgZGF0YTogaXRlbSB9KSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1YlRhc2tzLnB1c2goeyBtb2RlbDogZmllbGQudHlwZSwgZGF0YTogdiB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NhbGFyRGF0YVtrXSA9IHY7XG4gICAgICB9XG4gICAgfVxuICAgIGNhbGxiYWNrKG1vZGVsLCBkYXRhLCBzY2FsYXJEYXRhKTtcbiAgICBzdWJUYXNrcy5mb3JFYWNoKCh7IG1vZGVsOiBtb2RlbDIsIGRhdGE6IGRhdGEyIH0pID0+IHRoaXMudmlzaXQobW9kZWwyLCBkYXRhMiwgY2FsbGJhY2spKTtcbiAgfVxufTtcblxuLy8gc3JjL2Nyb3NzL21vZGVsLW1ldGEudHNcbnZhciBpbXBvcnRfbG93ZXJfY2FzZV9maXJzdCA9IHJlcXVpcmUoXCJsb3dlci1jYXNlLWZpcnN0XCIpO1xuZnVuY3Rpb24gcmVzb2x2ZUZpZWxkKG1vZGVsTWV0YSwgbW9kZWwsIGZpZWxkKSB7XG4gIHZhciBfYSwgX2I7XG4gIHJldHVybiAoX2IgPSAoX2EgPSBtb2RlbE1ldGEubW9kZWxzWygwLCBpbXBvcnRfbG93ZXJfY2FzZV9maXJzdC5sb3dlckNhc2VGaXJzdCkobW9kZWwpXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmZpZWxkcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iW2ZpZWxkXTtcbn1cbmZ1bmN0aW9uIHJlcXVpcmVGaWVsZChtb2RlbE1ldGEsIG1vZGVsLCBmaWVsZCkge1xuICBjb25zdCBmID0gcmVzb2x2ZUZpZWxkKG1vZGVsTWV0YSwgbW9kZWwsIGZpZWxkKTtcbiAgaWYgKCFmKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGaWVsZCAke21vZGVsfS4ke2ZpZWxkfSBjYW5ub3QgYmUgcmVzb2x2ZWRgKTtcbiAgfVxuICByZXR1cm4gZjtcbn1cbmZ1bmN0aW9uIGdldEZpZWxkcyhtb2RlbE1ldGEsIG1vZGVsKSB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIChfYSA9IG1vZGVsTWV0YS5tb2RlbHNbKDAsIGltcG9ydF9sb3dlcl9jYXNlX2ZpcnN0Lmxvd2VyQ2FzZUZpcnN0KShtb2RlbCldKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZmllbGRzO1xufVxuZnVuY3Rpb24gZ2V0VW5pcXVlQ29uc3RyYWludHMobW9kZWxNZXRhLCBtb2RlbCkge1xuICB2YXIgX2E7XG4gIHJldHVybiAoX2EgPSBtb2RlbE1ldGEubW9kZWxzWygwLCBpbXBvcnRfbG93ZXJfY2FzZV9maXJzdC5sb3dlckNhc2VGaXJzdCkobW9kZWwpXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnVuaXF1ZUNvbnN0cmFpbnRzO1xufVxuXG4vLyBzcmMvY3Jvc3MvbXV0YXRvci50c1xudmFyIGltcG9ydF91dWlkID0gcmVxdWlyZShcInV1aWRcIik7XG52YXIgaW1wb3J0X2RlZXBjb3B5ID0gX190b0VTTShyZXF1aXJlKFwiZGVlcGNvcHlcIikpO1xuZnVuY3Rpb24gYXBwbHlNdXRhdGlvbihxdWVyeU1vZGVsLCBxdWVyeU9wLCBxdWVyeURhdGEsIG11dGF0aW9uTW9kZWwsIG11dGF0aW9uT3AsIG11dGF0aW9uQXJncywgbW9kZWxNZXRhLCBsb2dnaW5nKSB7XG4gIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgaWYgKFtcImNvdW50XCIsIFwiYWdncmVnYXRlXCIsIFwiZ3JvdXBCeVwiXS5pbmNsdWRlcyhxdWVyeU9wKSkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgbGV0IHJlc3VsdERhdGEgPSBxdWVyeURhdGE7XG4gICAgbGV0IHVwZGF0ZWQgPSBmYWxzZTtcbiAgICBjb25zdCB2aXNpdG9yID0gbmV3IE5lc3RlZFdyaXRlVmlzaXRvcihtb2RlbE1ldGEsIHtcbiAgICAgIGNyZWF0ZTogKG1vZGVsLCBhcmdzKSA9PiB7XG4gICAgICAgIGlmIChtb2RlbCA9PT0gcXVlcnlNb2RlbCkge1xuICAgICAgICAgIGNvbnN0IHIgPSBjcmVhdGVNdXRhdGUocXVlcnlNb2RlbCwgcXVlcnlPcCwgcmVzdWx0RGF0YSwgYXJncywgbW9kZWxNZXRhLCBsb2dnaW5nKTtcbiAgICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgcmVzdWx0RGF0YSA9IHI7XG4gICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjcmVhdGVNYW55OiAobW9kZWwsIGFyZ3MpID0+IHtcbiAgICAgICAgaWYgKG1vZGVsID09PSBxdWVyeU1vZGVsICYmIChhcmdzID09IG51bGwgPyB2b2lkIDAgOiBhcmdzLmRhdGEpKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBvbmVBcmcgb2YgZW51bWVyYXRlKGFyZ3MuZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHIgPSBjcmVhdGVNdXRhdGUocXVlcnlNb2RlbCwgcXVlcnlPcCwgcmVzdWx0RGF0YSwgb25lQXJnLCBtb2RlbE1ldGEsIGxvZ2dpbmcpO1xuICAgICAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgICAgcmVzdWx0RGF0YSA9IHI7XG4gICAgICAgICAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVwZGF0ZTogKG1vZGVsLCBhcmdzKSA9PiB7XG4gICAgICAgIGlmIChtb2RlbCA9PT0gcXVlcnlNb2RlbCkge1xuICAgICAgICAgIGNvbnN0IHIgPSB1cGRhdGVNdXRhdGUocXVlcnlNb2RlbCwgcmVzdWx0RGF0YSwgbW9kZWwsIGFyZ3MsIG1vZGVsTWV0YSwgbG9nZ2luZyk7XG4gICAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgIHJlc3VsdERhdGEgPSByO1xuICAgICAgICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVsZXRlOiAobW9kZWwsIGFyZ3MpID0+IHtcbiAgICAgICAgaWYgKG1vZGVsID09PSBxdWVyeU1vZGVsKSB7XG4gICAgICAgICAgY29uc3QgciA9IGRlbGV0ZU11dGF0ZShxdWVyeU1vZGVsLCByZXN1bHREYXRhLCBtb2RlbCwgYXJncywgbW9kZWxNZXRhLCBsb2dnaW5nKTtcbiAgICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgcmVzdWx0RGF0YSA9IHI7XG4gICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB5aWVsZCB2aXNpdG9yLnZpc2l0KG11dGF0aW9uTW9kZWwsIG11dGF0aW9uT3AsIG11dGF0aW9uQXJncyk7XG4gICAgcmV0dXJuIHVwZGF0ZWQgPyByZXN1bHREYXRhIDogdm9pZCAwO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU11dGF0ZShxdWVyeU1vZGVsLCBxdWVyeU9wLCBjdXJyZW50RGF0YSwgbmV3RGF0YSwgbW9kZWxNZXRhLCBsb2dnaW5nKSB7XG4gIGlmICghbmV3RGF0YSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgaWYgKHF1ZXJ5T3AgIT09IFwiZmluZE1hbnlcIikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgY29uc3QgbW9kZWxGaWVsZHMgPSBnZXRGaWVsZHMobW9kZWxNZXRhLCBxdWVyeU1vZGVsKTtcbiAgaWYgKCFtb2RlbEZpZWxkcykge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgY29uc3QgaW5zZXJ0ID0ge307XG4gIGNvbnN0IG5ld0RhdGFGaWVsZHMgPSBPYmplY3Qua2V5cyhuZXdEYXRhKTtcbiAgT2JqZWN0LmVudHJpZXMobW9kZWxGaWVsZHMpLmZvckVhY2goKFtuYW1lLCBmaWVsZF0pID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgaWYgKGZpZWxkLmlzRGF0YU1vZGVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuZXdEYXRhRmllbGRzLmluY2x1ZGVzKG5hbWUpKSB7XG4gICAgICBpbnNlcnRbbmFtZV0gPSBuZXdEYXRhW25hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkZWZhdWx0QXR0ciA9IChfYSA9IGZpZWxkLmF0dHJpYnV0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5maW5kKChhdHRyKSA9PiBhdHRyLm5hbWUgPT09IFwiQGRlZmF1bHRcIik7XG4gICAgICBpZiAoZmllbGQudHlwZSA9PT0gXCJEYXRlVGltZVwiKSB7XG4gICAgICAgIGlmIChkZWZhdWx0QXR0ciB8fCAoKF9iID0gZmllbGQuYXR0cmlidXRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnNvbWUoKGF0dHIpID0+IGF0dHIubmFtZSA9PT0gXCJAdXBkYXRlZEF0XCIpKSkge1xuICAgICAgICAgIGluc2VydFtuYW1lXSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCgoX2QgPSAoX2MgPSBkZWZhdWx0QXR0ciA9PSBudWxsID8gdm9pZCAwIDogZGVmYXVsdEF0dHIuYXJncykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2QudmFsdWUpICE9PSB2b2lkIDApIHtcbiAgICAgICAgaW5zZXJ0W25hbWVdID0gZGVmYXVsdEF0dHIuYXJnc1swXS52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBjb25zdCBpZEZpZWxkcyA9IGdldElkRmllbGRzKG1vZGVsTWV0YSwgcXVlcnlNb2RlbCwgZmFsc2UpO1xuICBpZEZpZWxkcy5mb3JFYWNoKChmKSA9PiB7XG4gICAgaWYgKGluc2VydFtmLm5hbWVdID09PSB2b2lkIDApIHtcbiAgICAgIGlmIChmLnR5cGUgPT09IFwiSW50XCIgfHwgZi50eXBlID09PSBcIkJpZ0ludFwiKSB7XG4gICAgICAgIGNvbnN0IGN1cnJNYXggPSBBcnJheS5pc0FycmF5KGN1cnJlbnREYXRhKSA/IE1hdGgubWF4KFxuICAgICAgICAgIC4uLlsuLi5jdXJyZW50RGF0YV0ubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpZHYgPSBwYXJzZUludChpdGVtW2YubmFtZV0pO1xuICAgICAgICAgICAgcmV0dXJuIGlzTmFOKGlkdikgPyAwIDogaWR2O1xuICAgICAgICAgIH0pXG4gICAgICAgICkgOiAwO1xuICAgICAgICBpbnNlcnRbZi5uYW1lXSA9IGN1cnJNYXggKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zZXJ0W2YubmFtZV0gPSAoMCwgaW1wb3J0X3V1aWQudjQpKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgaW5zZXJ0LiRvcHRpbWlzdGljID0gdHJ1ZTtcbiAgaWYgKGxvZ2dpbmcpIHtcbiAgICBjb25zb2xlLmxvZyhgT3B0aW1pc3RpYyBjcmVhdGUgZm9yICR7cXVlcnlNb2RlbH06YCwgaW5zZXJ0KTtcbiAgfVxuICByZXR1cm4gW2luc2VydCwgLi4uQXJyYXkuaXNBcnJheShjdXJyZW50RGF0YSkgPyBjdXJyZW50RGF0YSA6IFtdXTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU11dGF0ZShxdWVyeU1vZGVsLCBjdXJyZW50RGF0YSwgbXV0YXRlTW9kZWwsIG11dGF0ZUFyZ3MsIG1vZGVsTWV0YSwgbG9nZ2luZykge1xuICBpZiAoIWN1cnJlbnREYXRhKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBpZiAoIShtdXRhdGVBcmdzID09IG51bGwgPyB2b2lkIDAgOiBtdXRhdGVBcmdzLndoZXJlKSB8fCAhKG11dGF0ZUFyZ3MgPT0gbnVsbCA/IHZvaWQgMCA6IG11dGF0ZUFyZ3MuZGF0YSkpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGxldCB1cGRhdGVkID0gZmFsc2U7XG4gIGZvciAoY29uc3QgaXRlbSBvZiBlbnVtZXJhdGUoY3VycmVudERhdGEpKSB7XG4gICAgY29uc3QgdmlzaXRvciA9IG5ldyBNb2RlbERhdGFWaXNpdG9yKG1vZGVsTWV0YSk7XG4gICAgdmlzaXRvci52aXNpdChxdWVyeU1vZGVsLCBpdGVtLCAobW9kZWwsIF9kYXRhLCBzY2FsYXJEYXRhKSA9PiB7XG4gICAgICBpZiAobW9kZWwgPT09IG11dGF0ZU1vZGVsICYmIGlkRmllbGRzTWF0Y2gobW9kZWwsIHNjYWxhckRhdGEsIG11dGF0ZUFyZ3Mud2hlcmUsIG1vZGVsTWV0YSkpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoaXRlbSkuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgICAgIGlmIChtdXRhdGVBcmdzLmRhdGFba10gIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaXRlbVtrXSA9IG11dGF0ZUFyZ3MuZGF0YVtrXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpdGVtLiRvcHRpbWlzdGljID0gdHJ1ZTtcbiAgICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgIGlmIChsb2dnaW5nKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYE9wdGltaXN0aWMgdXBkYXRlIGZvciAke3F1ZXJ5TW9kZWx9OmAsIGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZWQgPyAoMCwgaW1wb3J0X2RlZXBjb3B5LmRlZmF1bHQpKGN1cnJlbnREYXRhKSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZU11dGF0ZShxdWVyeU1vZGVsLCBjdXJyZW50RGF0YSwgbXV0YXRlTW9kZWwsIG11dGF0ZUFyZ3MsIG1vZGVsTWV0YSwgbG9nZ2luZykge1xuICBpZiAoIWN1cnJlbnREYXRhIHx8ICFtdXRhdGVBcmdzKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBpZiAocXVlcnlNb2RlbCAhPT0gbXV0YXRlTW9kZWwpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGxldCB1cGRhdGVkID0gZmFsc2U7XG4gIGxldCByZXN1bHQgPSBjdXJyZW50RGF0YTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudERhdGEpKSB7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGN1cnJlbnREYXRhKSB7XG4gICAgICBpZiAoaWRGaWVsZHNNYXRjaChtdXRhdGVNb2RlbCwgaXRlbSwgbXV0YXRlQXJncywgbW9kZWxNZXRhKSkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuZmlsdGVyKCh4KSA9PiB4ICE9PSBpdGVtKTtcbiAgICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgIGlmIChsb2dnaW5nKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYE9wdGltaXN0aWMgZGVsZXRlIGZvciAke3F1ZXJ5TW9kZWx9OmAsIGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpZEZpZWxkc01hdGNoKG11dGF0ZU1vZGVsLCBjdXJyZW50RGF0YSwgbXV0YXRlQXJncywgbW9kZWxNZXRhKSkge1xuICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgaWYgKGxvZ2dpbmcpIHtcbiAgICAgICAgY29uc29sZS5sb2coYE9wdGltaXN0aWMgZGVsZXRlIGZvciAke3F1ZXJ5TW9kZWx9OmAsIGN1cnJlbnREYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZWQgPyByZXN1bHQgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBpZEZpZWxkc01hdGNoKG1vZGVsLCB4LCB5LCBtb2RlbE1ldGEpIHtcbiAgaWYgKCF4IHx8ICF5IHx8IHR5cGVvZiB4ICE9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiB5ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGlkRmllbGRzID0gZ2V0SWRGaWVsZHMobW9kZWxNZXRhLCBtb2RlbCwgZmFsc2UpO1xuICBpZiAoaWRGaWVsZHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpZEZpZWxkcy5ldmVyeSgoZikgPT4geFtmLm5hbWVdID09PSB5W2YubmFtZV0pO1xufVxuXG4vLyBzcmMvY3Jvc3MvbmVzdGVkLXJlYWQtdmlzaXRvci50c1xudmFyIE5lc3RlZFJlYWRWaXNpdG9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihtb2RlbE1ldGEsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5tb2RlbE1ldGEgPSBtb2RlbE1ldGE7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG4gIGRvVmlzaXQobW9kZWwsIGZpZWxkLCBraW5kLCBhcmdzKSB7XG4gICAgaWYgKHRoaXMuY2FsbGJhY2suZmllbGQpIHtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLmNhbGxiYWNrLmZpZWxkKG1vZGVsLCBmaWVsZCwga2luZCwgYXJncyk7XG4gICAgICBpZiAociA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWFyZ3MgfHwgdHlwZW9mIGFyZ3MgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHNlbGVjdEluY2x1ZGU7XG4gICAgbGV0IG5leHRLaW5kO1xuICAgIGlmIChhcmdzLnNlbGVjdCkge1xuICAgICAgc2VsZWN0SW5jbHVkZSA9IGFyZ3Muc2VsZWN0O1xuICAgICAgbmV4dEtpbmQgPSBcInNlbGVjdFwiO1xuICAgIH0gZWxzZSBpZiAoYXJncy5pbmNsdWRlKSB7XG4gICAgICBzZWxlY3RJbmNsdWRlID0gYXJncy5pbmNsdWRlO1xuICAgICAgbmV4dEtpbmQgPSBcImluY2x1ZGVcIjtcbiAgICB9XG4gICAgaWYgKHNlbGVjdEluY2x1ZGUgJiYgdHlwZW9mIHNlbGVjdEluY2x1ZGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKHNlbGVjdEluY2x1ZGUpKSB7XG4gICAgICAgIGlmIChrID09PSBcIl9jb3VudFwiICYmIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYpIHtcbiAgICAgICAgICB0aGlzLmRvVmlzaXQobW9kZWwsIGZpZWxkLCBraW5kLCB2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBmaWVsZDIgPSByZXNvbHZlRmllbGQodGhpcy5tb2RlbE1ldGEsIG1vZGVsLCBrKTtcbiAgICAgICAgICBpZiAoZmllbGQyKSB7XG4gICAgICAgICAgICB0aGlzLmRvVmlzaXQoZmllbGQyLnR5cGUsIGZpZWxkMiwgbmV4dEtpbmQsIHYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2aXNpdChtb2RlbCwgYXJncykge1xuICAgIHRoaXMuZG9WaXNpdChtb2RlbCwgdm9pZCAwLCB2b2lkIDAsIGFyZ3MpO1xuICB9XG59O1xuXG4vLyBzcmMvY3Jvc3MvdHlwZXMudHNcbnZhciBQcmlzbWFXcml0ZUFjdGlvbnMgPSBbXG4gIFwiY3JlYXRlXCIsXG4gIFwiY3JlYXRlTWFueVwiLFxuICBcImNvbm5lY3RPckNyZWF0ZVwiLFxuICBcInVwZGF0ZVwiLFxuICBcInVwZGF0ZU1hbnlcIixcbiAgXCJ1cHNlcnRcIixcbiAgXCJjb25uZWN0XCIsXG4gIFwiZGlzY29ubmVjdFwiLFxuICBcInNldFwiLFxuICBcImRlbGV0ZVwiLFxuICBcImRlbGV0ZU1hbnlcIlxuXTtcblxuLy8gc3JjL2Nyb3NzL3V0aWxzLnRzXG52YXIgaW1wb3J0X2xvd2VyX2Nhc2VfZmlyc3QyID0gcmVxdWlyZShcImxvd2VyLWNhc2UtZmlyc3RcIik7XG5mdW5jdGlvbiBnZXRNb2RlbEZpZWxkcyhkYXRhKSB7XG4gIHJldHVybiBkYXRhID8gT2JqZWN0LmtleXMoZGF0YSkgOiBbXTtcbn1cbmZ1bmN0aW9uIGVudW1lcmF0ZSh4KSB7XG4gIGlmICh4ID09PSBudWxsIHx8IHggPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBbXTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgcmV0dXJuIHg7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFt4XTtcbiAgfVxufVxuZnVuY3Rpb24gemlwKHgsIHkpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoeCkpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoeSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInggYW5kIHkgc2hvdWxkIGJlIGJvdGggYXJyYXkgb3IgYm90aCBzY2FsYXJcIik7XG4gICAgfVxuICAgIGlmICh4Lmxlbmd0aCAhPT0geS5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInggYW5kIHkgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCIpO1xuICAgIH1cbiAgICByZXR1cm4geC5tYXAoKF8sIGkpID0+IFt4W2ldLCB5W2ldXSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoeSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInggYW5kIHkgc2hvdWxkIGJlIGJvdGggYXJyYXkgb3IgYm90aCBzY2FsYXJcIik7XG4gICAgfVxuICAgIHJldHVybiBbW3gsIHldXTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0SWRGaWVsZHMobW9kZWxNZXRhLCBtb2RlbCwgdGhyb3dJZk5vdEZvdW5kID0gZmFsc2UpIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgdW5pcXVlQ29uc3RyYWludHMgPSAoX2IgPSAoX2EgPSBtb2RlbE1ldGEubW9kZWxzWygwLCBpbXBvcnRfbG93ZXJfY2FzZV9maXJzdDIubG93ZXJDYXNlRmlyc3QpKG1vZGVsKV0pID09IG51bGwgPyB2b2lkIDAgOiBfYS51bmlxdWVDb25zdHJhaW50cykgIT0gbnVsbCA/IF9iIDoge307XG4gIGNvbnN0IGVudHJpZXMgPSBPYmplY3QudmFsdWVzKHVuaXF1ZUNvbnN0cmFpbnRzKTtcbiAgaWYgKGVudHJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNb2RlbCAke21vZGVsfSBkb2VzIG5vdCBoYXZlIGFueSBpZCBmaWVsZGApO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIGVudHJpZXNbMF0uZmllbGRzLm1hcCgoZikgPT4gcmVxdWlyZUZpZWxkKG1vZGVsTWV0YSwgbW9kZWwsIGYpKTtcbn1cbmZ1bmN0aW9uIGdldE1vZGVsSW5mbyhtb2RlbE1ldGEsIG1vZGVsLCB0aHJvd0lmTm90Rm91bmQgPSBmYWxzZSkge1xuICBjb25zdCBpbmZvID0gbW9kZWxNZXRhLm1vZGVsc1soMCwgaW1wb3J0X2xvd2VyX2Nhc2VfZmlyc3QyLmxvd2VyQ2FzZUZpcnN0KShtb2RlbCldO1xuICBpZiAoIWluZm8gJiYgdGhyb3dJZk5vdEZvdW5kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gbG9hZCBpbmZvIGZvciAke21vZGVsfWApO1xuICB9XG4gIHJldHVybiBpbmZvO1xufVxuZnVuY3Rpb24gaXNEZWxlZ2F0ZU1vZGVsKG1vZGVsTWV0YSwgbW9kZWwpIHtcbiAgdmFyIF9hLCBfYjtcbiAgcmV0dXJuICEhKChfYiA9IChfYSA9IGdldE1vZGVsSW5mbyhtb2RlbE1ldGEsIG1vZGVsKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmF0dHJpYnV0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5zb21lKChhdHRyKSA9PiBhdHRyLm5hbWUgPT09IFwiQEBkZWxlZ2F0ZVwiKSk7XG59XG5cbi8vIHNyYy9jcm9zcy9uZXN0ZWQtd3JpdGUtdmlzaXRvci50c1xudmFyIE5lc3RlZFdyaXRlVmlzaXRvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobW9kZWxNZXRhLCBjYWxsYmFjaykge1xuICAgIHRoaXMubW9kZWxNZXRhID0gbW9kZWxNZXRhO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuICBpc1ByaXNtYVdyaXRlQWN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIFByaXNtYVdyaXRlQWN0aW9ucy5pbmNsdWRlcyh2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0IHZpc2l0aW5nXG4gICAqXG4gICAqIEBzZWUgTmVzdGVkV3JpdGVyVmlzaXRvckNhbGxiYWNrXG4gICAqL1xuICB2aXNpdChtb2RlbCwgYWN0aW9uLCBhcmdzKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghYXJncykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgdG9wRGF0YSA9IGFyZ3M7XG4gICAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgICBjYXNlIFwiY3JlYXRlXCI6XG4gICAgICAgICAgdG9wRGF0YSA9IHRvcERhdGEuZGF0YTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRlbGV0ZVwiOlxuICAgICAgICBjYXNlIFwiZGVsZXRlTWFueVwiOlxuICAgICAgICAgIHRvcERhdGEgPSB0b3BEYXRhLndoZXJlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgeWllbGQgdGhpcy5kb1Zpc2l0KG1vZGVsLCBhY3Rpb24sIHRvcERhdGEsIHZvaWQgMCwgdm9pZCAwLCBbXSk7XG4gICAgfSk7XG4gIH1cbiAgZG9WaXNpdChtb2RlbCwgYWN0aW9uLCBkYXRhLCBwYXJlbnQsIGZpZWxkLCBuZXN0aW5nUGF0aCkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdG9wbGV2ZWwgPSBmaWVsZCA9PSB2b2lkIDA7XG4gICAgICBjb25zdCBjb250ZXh0ID0geyBwYXJlbnQsIGZpZWxkLCBuZXN0aW5nUGF0aDogWy4uLm5lc3RpbmdQYXRoXSB9O1xuICAgICAgY29uc3QgcHVzaE5ld0NvbnRleHQgPSAoZmllbGQyLCBtb2RlbDIsIHdoZXJlLCB1bmlxdWUgPSBmYWxzZSkgPT4ge1xuICAgICAgICByZXR1cm4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgY29udGV4dCksIHsgbmVzdGluZ1BhdGg6IFsuLi5jb250ZXh0Lm5lc3RpbmdQYXRoLCB7IGZpZWxkOiBmaWVsZDIsIG1vZGVsOiBtb2RlbDIsIHdoZXJlLCB1bmlxdWUgfV0gfSk7XG4gICAgICB9O1xuICAgICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgICAgY2FzZSBcImNyZWF0ZVwiOlxuICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLmVudW1lcmF0ZVJldmVyc2UoZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbnRleHQgPSBwdXNoTmV3Q29udGV4dChmaWVsZCwgbW9kZWwsIHt9KTtcbiAgICAgICAgICAgIGxldCBjYWxsYmFja1Jlc3VsdDtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbGxiYWNrLmNyZWF0ZSkge1xuICAgICAgICAgICAgICBjYWxsYmFja1Jlc3VsdCA9IHlpZWxkIHRoaXMuY2FsbGJhY2suY3JlYXRlKG1vZGVsLCBpdGVtLCBuZXdDb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFja1Jlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc3ViUGF5bG9hZCA9IHR5cGVvZiBjYWxsYmFja1Jlc3VsdCA9PT0gXCJvYmplY3RcIiA/IGNhbGxiYWNrUmVzdWx0IDogaXRlbTtcbiAgICAgICAgICAgICAgeWllbGQgdGhpcy52aXNpdFN1YlBheWxvYWQobW9kZWwsIGFjdGlvbiwgc3ViUGF5bG9hZCwgbmV3Q29udGV4dC5uZXN0aW5nUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY3JlYXRlTWFueVwiOlxuICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdDb250ZXh0ID0gcHVzaE5ld0NvbnRleHQoZmllbGQsIG1vZGVsLCB7fSk7XG4gICAgICAgICAgICBsZXQgY2FsbGJhY2tSZXN1bHQ7XG4gICAgICAgICAgICBpZiAodGhpcy5jYWxsYmFjay5jcmVhdGVNYW55KSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrUmVzdWx0ID0geWllbGQgdGhpcy5jYWxsYmFjay5jcmVhdGVNYW55KG1vZGVsLCBkYXRhLCBuZXdDb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFja1Jlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc3ViUGF5bG9hZCA9IHR5cGVvZiBjYWxsYmFja1Jlc3VsdCA9PT0gXCJvYmplY3RcIiA/IGNhbGxiYWNrUmVzdWx0IDogZGF0YS5kYXRhO1xuICAgICAgICAgICAgICB5aWVsZCB0aGlzLnZpc2l0U3ViUGF5bG9hZChtb2RlbCwgYWN0aW9uLCBzdWJQYXlsb2FkLCBuZXdDb250ZXh0Lm5lc3RpbmdQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjb25uZWN0T3JDcmVhdGVcIjpcbiAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5lbnVtZXJhdGVSZXZlcnNlKGRhdGEpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdDb250ZXh0ID0gcHVzaE5ld0NvbnRleHQoZmllbGQsIG1vZGVsLCBpdGVtLndoZXJlKTtcbiAgICAgICAgICAgIGxldCBjYWxsYmFja1Jlc3VsdDtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbGxiYWNrLmNvbm5lY3RPckNyZWF0ZSkge1xuICAgICAgICAgICAgICBjYWxsYmFja1Jlc3VsdCA9IHlpZWxkIHRoaXMuY2FsbGJhY2suY29ubmVjdE9yQ3JlYXRlKG1vZGVsLCBpdGVtLCBuZXdDb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFja1Jlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc3ViUGF5bG9hZCA9IHR5cGVvZiBjYWxsYmFja1Jlc3VsdCA9PT0gXCJvYmplY3RcIiA/IGNhbGxiYWNrUmVzdWx0IDogaXRlbS5jcmVhdGU7XG4gICAgICAgICAgICAgIHlpZWxkIHRoaXMudmlzaXRTdWJQYXlsb2FkKG1vZGVsLCBhY3Rpb24sIHN1YlBheWxvYWQsIG5ld0NvbnRleHQubmVzdGluZ1BhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNvbm5lY3RcIjpcbiAgICAgICAgICBpZiAodGhpcy5jYWxsYmFjay5jb25uZWN0KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5lbnVtZXJhdGVSZXZlcnNlKGRhdGEpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5ld0NvbnRleHQgPSBwdXNoTmV3Q29udGV4dChmaWVsZCwgbW9kZWwsIGl0ZW0sIHRydWUpO1xuICAgICAgICAgICAgICB5aWVsZCB0aGlzLmNhbGxiYWNrLmNvbm5lY3QobW9kZWwsIGl0ZW0sIG5ld0NvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRpc2Nvbm5lY3RcIjpcbiAgICAgICAgICBpZiAodGhpcy5jYWxsYmFjay5kaXNjb25uZWN0KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5lbnVtZXJhdGVSZXZlcnNlKGRhdGEpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5ld0NvbnRleHQgPSBwdXNoTmV3Q29udGV4dChmaWVsZCwgbW9kZWwsIGl0ZW0sIHR5cGVvZiBpdGVtID09PSBcIm9iamVjdFwiKTtcbiAgICAgICAgICAgICAgeWllbGQgdGhpcy5jYWxsYmFjay5kaXNjb25uZWN0KG1vZGVsLCBpdGVtLCBuZXdDb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzZXRcIjpcbiAgICAgICAgICBpZiAodGhpcy5jYWxsYmFjay5zZXQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLmVudW1lcmF0ZVJldmVyc2UoZGF0YSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgbmV3Q29udGV4dCA9IHB1c2hOZXdDb250ZXh0KGZpZWxkLCBtb2RlbCwgaXRlbSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHlpZWxkIHRoaXMuY2FsbGJhY2suc2V0KG1vZGVsLCBpdGVtLCBuZXdDb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ1cGRhdGVcIjpcbiAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5lbnVtZXJhdGVSZXZlcnNlKGRhdGEpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdDb250ZXh0ID0gcHVzaE5ld0NvbnRleHQoZmllbGQsIG1vZGVsLCBpdGVtLndoZXJlKTtcbiAgICAgICAgICAgIGxldCBjYWxsYmFja1Jlc3VsdDtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbGxiYWNrLnVwZGF0ZSkge1xuICAgICAgICAgICAgICBjYWxsYmFja1Jlc3VsdCA9IHlpZWxkIHRoaXMuY2FsbGJhY2sudXBkYXRlKG1vZGVsLCBpdGVtLCBuZXdDb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFja1Jlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc3ViUGF5bG9hZCA9IHR5cGVvZiBjYWxsYmFja1Jlc3VsdCA9PT0gXCJvYmplY3RcIiA/IGNhbGxiYWNrUmVzdWx0IDogdHlwZW9mIGl0ZW0uZGF0YSA9PT0gXCJvYmplY3RcIiA/IGl0ZW0uZGF0YSA6IGl0ZW07XG4gICAgICAgICAgICAgIHlpZWxkIHRoaXMudmlzaXRTdWJQYXlsb2FkKG1vZGVsLCBhY3Rpb24sIHN1YlBheWxvYWQsIG5ld0NvbnRleHQubmVzdGluZ1BhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInVwZGF0ZU1hbnlcIjpcbiAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5lbnVtZXJhdGVSZXZlcnNlKGRhdGEpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdDb250ZXh0ID0gcHVzaE5ld0NvbnRleHQoZmllbGQsIG1vZGVsLCBpdGVtLndoZXJlKTtcbiAgICAgICAgICAgIGxldCBjYWxsYmFja1Jlc3VsdDtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbGxiYWNrLnVwZGF0ZU1hbnkpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2tSZXN1bHQgPSB5aWVsZCB0aGlzLmNhbGxiYWNrLnVwZGF0ZU1hbnkobW9kZWwsIGl0ZW0sIG5ld0NvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrUmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICBjb25zdCBzdWJQYXlsb2FkID0gdHlwZW9mIGNhbGxiYWNrUmVzdWx0ID09PSBcIm9iamVjdFwiID8gY2FsbGJhY2tSZXN1bHQgOiBpdGVtO1xuICAgICAgICAgICAgICB5aWVsZCB0aGlzLnZpc2l0U3ViUGF5bG9hZChtb2RlbCwgYWN0aW9uLCBzdWJQYXlsb2FkLCBuZXdDb250ZXh0Lm5lc3RpbmdQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ1cHNlcnRcIjoge1xuICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLmVudW1lcmF0ZVJldmVyc2UoZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbnRleHQgPSBwdXNoTmV3Q29udGV4dChmaWVsZCwgbW9kZWwsIGl0ZW0ud2hlcmUpO1xuICAgICAgICAgICAgbGV0IGNhbGxiYWNrUmVzdWx0O1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2sudXBzZXJ0KSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrUmVzdWx0ID0geWllbGQgdGhpcy5jYWxsYmFjay51cHNlcnQobW9kZWwsIGl0ZW0sIG5ld0NvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrUmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrUmVzdWx0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy52aXNpdFN1YlBheWxvYWQobW9kZWwsIGFjdGlvbiwgY2FsbGJhY2tSZXN1bHQsIG5ld0NvbnRleHQubmVzdGluZ1BhdGgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMudmlzaXRTdWJQYXlsb2FkKG1vZGVsLCBhY3Rpb24sIGl0ZW0uY3JlYXRlLCBuZXdDb250ZXh0Lm5lc3RpbmdQYXRoKTtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnZpc2l0U3ViUGF5bG9hZChtb2RlbCwgYWN0aW9uLCBpdGVtLnVwZGF0ZSwgbmV3Q29udGV4dC5uZXN0aW5nUGF0aCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImRlbGV0ZVwiOiB7XG4gICAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2suZGVsZXRlKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5lbnVtZXJhdGVSZXZlcnNlKGRhdGEpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5ld0NvbnRleHQgPSBwdXNoTmV3Q29udGV4dChmaWVsZCwgbW9kZWwsIHRvcGxldmVsID8gaXRlbS53aGVyZSA6IGl0ZW0pO1xuICAgICAgICAgICAgICB5aWVsZCB0aGlzLmNhbGxiYWNrLmRlbGV0ZShtb2RlbCwgaXRlbSwgbmV3Q29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJkZWxldGVNYW55XCI6XG4gICAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2suZGVsZXRlTWFueSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuZW51bWVyYXRlUmV2ZXJzZShkYXRhKSkge1xuICAgICAgICAgICAgICBjb25zdCBuZXdDb250ZXh0ID0gcHVzaE5ld0NvbnRleHQoZmllbGQsIG1vZGVsLCB0b3BsZXZlbCA/IGl0ZW0ud2hlcmUgOiBpdGVtKTtcbiAgICAgICAgICAgICAgeWllbGQgdGhpcy5jYWxsYmFjay5kZWxldGVNYW55KG1vZGVsLCBpdGVtLCBuZXdDb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuaGFuZGxlZCBhY3Rpb24gdHlwZSAke2FjdGlvbn1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHZpc2l0U3ViUGF5bG9hZChtb2RlbCwgYWN0aW9uLCBwYXlsb2FkLCBuZXN0aW5nUGF0aCkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGdldE1vZGVsRmllbGRzKHBheWxvYWQpKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkSW5mbyA9IHJlc29sdmVGaWVsZCh0aGlzLm1vZGVsTWV0YSwgbW9kZWwsIGZpZWxkKTtcbiAgICAgICAgaWYgKCFmaWVsZEluZm8pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGRJbmZvLmlzRGF0YU1vZGVsKSB7XG4gICAgICAgICAgaWYgKHBheWxvYWRbZmllbGRdKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtzdWJBY3Rpb24sIHN1YkRhdGFdIG9mIE9iamVjdC5lbnRyaWVzKHBheWxvYWRbZmllbGRdKSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5pc1ByaXNtYVdyaXRlQWN0aW9uKHN1YkFjdGlvbikgJiYgc3ViRGF0YSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZG9WaXNpdChmaWVsZEluZm8udHlwZSwgc3ViQWN0aW9uLCBzdWJEYXRhLCBwYXlsb2FkW2ZpZWxkXSwgZmllbGRJbmZvLCBbXG4gICAgICAgICAgICAgICAgICAuLi5uZXN0aW5nUGF0aFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLmNhbGxiYWNrLmZpZWxkKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmNhbGxiYWNrLmZpZWxkKGZpZWxkSW5mbywgYWN0aW9uLCBwYXlsb2FkW2ZpZWxkXSwge1xuICAgICAgICAgICAgICBwYXJlbnQ6IHBheWxvYWQsXG4gICAgICAgICAgICAgIG5lc3RpbmdQYXRoLFxuICAgICAgICAgICAgICBmaWVsZDogZmllbGRJbmZvXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvLyBlbnVtZXJhdGUgYSAocG9zc2libGUpIGFycmF5IGluIHJldmVyc2Ugb3JkZXIsIHNvIHRoYXQgdGhlIGVudW1lcmF0aW9uXG4gIC8vIGNhbGxiYWNrIGNhbiBzYWZlbHkgZGVsZXRlIHRoZSBjdXJyZW50IGl0ZW1cbiAgKmVudW1lcmF0ZVJldmVyc2UoZGF0YSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB5aWVsZCBkYXRhW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB5aWVsZCBkYXRhO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2Nyb3NzL3F1ZXJ5LWFuYWx5emVyLnRzXG52YXIgaW1wb3J0X2xvd2VyX2Nhc2VfZmlyc3QzID0gcmVxdWlyZShcImxvd2VyLWNhc2UtZmlyc3RcIik7XG5mdW5jdGlvbiBnZXRSZWFkTW9kZWxzKG1vZGVsLCBtb2RlbE1ldGEsIGFyZ3MpIHtcbiAgY29uc3QgcmVzdWx0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgcmVzdWx0LmFkZChtb2RlbCk7XG4gIGNvbnN0IHZpc2l0b3IgPSBuZXcgTmVzdGVkUmVhZFZpc2l0b3IobW9kZWxNZXRhLCB7XG4gICAgZmllbGQ6IChtb2RlbDIpID0+IHtcbiAgICAgIHJlc3VsdC5hZGQobW9kZWwyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIHZpc2l0b3IudmlzaXQobW9kZWwsIGFyZ3MpO1xuICByZXR1cm4gWy4uLnJlc3VsdF07XG59XG5mdW5jdGlvbiBnZXRNdXRhdGVkTW9kZWxzKG1vZGVsLCBvcGVyYXRpb24sIG11dGF0aW9uQXJncywgbW9kZWxNZXRhKSB7XG4gIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICByZXN1bHQuYWRkKG1vZGVsKTtcbiAgICBpZiAobXV0YXRpb25BcmdzKSB7XG4gICAgICBjb25zdCBhZGRNb2RlbCA9IChtb2RlbDIpID0+IHZvaWQgcmVzdWx0LmFkZChtb2RlbDIpO1xuICAgICAgY29uc3QgYWRkQ2FzY2FkZXMgPSAobW9kZWwyKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhc2NhZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3QgdmlzaXRlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICAgIGNvbGxlY3REZWxldGVDYXNjYWRlcyhtb2RlbDIsIG1vZGVsTWV0YSwgY2FzY2FkZXMsIHZpc2l0ZWQpO1xuICAgICAgICBjYXNjYWRlcy5mb3JFYWNoKChtKSA9PiBhZGRNb2RlbChtKSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgdmlzaXRvciA9IG5ldyBOZXN0ZWRXcml0ZVZpc2l0b3IobW9kZWxNZXRhLCB7XG4gICAgICAgIGNyZWF0ZTogYWRkTW9kZWwsXG4gICAgICAgIGNyZWF0ZU1hbnk6IGFkZE1vZGVsLFxuICAgICAgICBjb25uZWN0T3JDcmVhdGU6IGFkZE1vZGVsLFxuICAgICAgICBjb25uZWN0OiBhZGRNb2RlbCxcbiAgICAgICAgZGlzY29ubmVjdDogYWRkTW9kZWwsXG4gICAgICAgIHNldDogYWRkTW9kZWwsXG4gICAgICAgIHVwZGF0ZTogYWRkTW9kZWwsXG4gICAgICAgIHVwZGF0ZU1hbnk6IGFkZE1vZGVsLFxuICAgICAgICB1cHNlcnQ6IGFkZE1vZGVsLFxuICAgICAgICBkZWxldGU6IChtb2RlbDIpID0+IHtcbiAgICAgICAgICBhZGRNb2RlbChtb2RlbDIpO1xuICAgICAgICAgIGFkZENhc2NhZGVzKG1vZGVsMik7XG4gICAgICAgIH0sXG4gICAgICAgIGRlbGV0ZU1hbnk6IChtb2RlbDIpID0+IHtcbiAgICAgICAgICBhZGRNb2RlbChtb2RlbDIpO1xuICAgICAgICAgIGFkZENhc2NhZGVzKG1vZGVsMik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgeWllbGQgdmlzaXRvci52aXNpdChtb2RlbCwgb3BlcmF0aW9uLCBtdXRhdGlvbkFyZ3MpO1xuICAgIH1cbiAgICByZXN1bHQuZm9yRWFjaCgobSkgPT4ge1xuICAgICAgZ2V0QmFzZVJlY3Vyc2l2ZWx5KG0sIG1vZGVsTWV0YSwgcmVzdWx0KTtcbiAgICB9KTtcbiAgICByZXR1cm4gWy4uLnJlc3VsdF07XG4gIH0pO1xufVxuZnVuY3Rpb24gY29sbGVjdERlbGV0ZUNhc2NhZGVzKG1vZGVsLCBtb2RlbE1ldGEsIHJlc3VsdCwgdmlzaXRlZCkge1xuICB2YXIgX2E7XG4gIGlmICh2aXNpdGVkLmhhcyhtb2RlbCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmlzaXRlZC5hZGQobW9kZWwpO1xuICBjb25zdCBjYXNjYWRlcyA9IChfYSA9IG1vZGVsTWV0YS5kZWxldGVDYXNjYWRlKSA9PSBudWxsID8gdm9pZCAwIDogX2FbKDAsIGltcG9ydF9sb3dlcl9jYXNlX2ZpcnN0My5sb3dlckNhc2VGaXJzdCkobW9kZWwpXTtcbiAgaWYgKCFjYXNjYWRlcykge1xuICAgIHJldHVybjtcbiAgfVxuICBjYXNjYWRlcy5mb3JFYWNoKChtKSA9PiB7XG4gICAgcmVzdWx0LmFkZChtKTtcbiAgICBjb2xsZWN0RGVsZXRlQ2FzY2FkZXMobSwgbW9kZWxNZXRhLCByZXN1bHQsIHZpc2l0ZWQpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEJhc2VSZWN1cnNpdmVseShtb2RlbCwgbW9kZWxNZXRhLCByZXN1bHQpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBiYXNlcyA9IChfYSA9IGdldE1vZGVsSW5mbyhtb2RlbE1ldGEsIG1vZGVsKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmJhc2VUeXBlcztcbiAgaWYgKGJhc2VzKSB7XG4gICAgYmFzZXMuZm9yRWFjaCgoYmFzZSkgPT4ge1xuICAgICAgcmVzdWx0LmFkZChiYXNlKTtcbiAgICAgIGdldEJhc2VSZWN1cnNpdmVseShiYXNlLCBtb2RlbE1ldGEsIHJlc3VsdCk7XG4gICAgfSk7XG4gIH1cbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBNb2RlbERhdGFWaXNpdG9yLFxuICBOZXN0ZWRSZWFkVmlzaXRvcixcbiAgTmVzdGVkV3JpdGVWaXNpdG9yLFxuICBQcmlzbWFXcml0ZUFjdGlvbnMsXG4gIGFwcGx5TXV0YXRpb24sXG4gIGVudW1lcmF0ZSxcbiAgZ2V0RmllbGRzLFxuICBnZXRJZEZpZWxkcyxcbiAgZ2V0TW9kZWxGaWVsZHMsXG4gIGdldE1vZGVsSW5mbyxcbiAgZ2V0TXV0YXRlZE1vZGVscyxcbiAgZ2V0UmVhZE1vZGVscyxcbiAgZ2V0VW5pcXVlQ29uc3RyYWludHMsXG4gIGlzRGVsZWdhdGVNb2RlbCxcbiAgcmVxdWlyZUZpZWxkLFxuICByZXNvbHZlRmllbGQsXG4gIHppcFxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/cross/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhance.js":
/*!***************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhance.js ***!
  \***************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\ntry {\n    exports.enhance = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '.zenstack/enhance'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n} catch {\n    exports.enhance = function () {\n        throw new Error('Generated \"enhance\" function not found. Please run `zenstack generate` first.');\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHplbnN0YWNraHErcnVudGltZUAyLjIuNF9AcHJpc21hK2NsaWVudEA1LjE3LjBfcHJpc21hQDUuMTcuMF8vbm9kZV9tb2R1bGVzL0B6ZW5zdGFja2hxL3J1bnRpbWUvZW5oYW5jZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0Q7QUFDQSxJQUFJLGtLQUFzRDtBQUMxRCxFQUFFO0FBQ0YsSUFBSSxlQUFlO0FBQ25CO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXJibGlzbS9uZXh0LWpzLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B6ZW5zdGFja2hxK3J1bnRpbWVAMi4yLjRfQHByaXNtYStjbGllbnRANS4xNy4wX3ByaXNtYUA1LjE3LjBfL25vZGVfbW9kdWxlcy9AemVuc3RhY2tocS9ydW50aW1lL2VuaGFuY2UuanM/OGRlZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG50cnkge1xuICAgIGV4cG9ydHMuZW5oYW5jZSA9IHJlcXVpcmUoJy56ZW5zdGFjay9lbmhhbmNlJykuZW5oYW5jZTtcbn0gY2F0Y2gge1xuICAgIGV4cG9ydHMuZW5oYW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHZW5lcmF0ZWQgXCJlbmhhbmNlXCIgZnVuY3Rpb24gbm90IGZvdW5kLiBQbGVhc2UgcnVuIGB6ZW5zdGFjayBnZW5lcmF0ZWAgZmlyc3QuJyk7XG4gICAgfTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhance.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/create-enhancement.js":
/*!***************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/create-enhancement.js ***!
  \***************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createEnhancement = void 0;\nconst semver_1 = __importDefault(__webpack_require__(/*! semver */ \"(rsc)/./node_modules/.pnpm/semver@7.6.2/node_modules/semver/index.js\"));\nconst constants_1 = __webpack_require__(/*! ../constants */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/constants.js\");\nconst cross_1 = __webpack_require__(/*! ../cross */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/cross/index.js\");\nconst default_auth_1 = __webpack_require__(/*! ./default-auth */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/default-auth.js\");\nconst delegate_1 = __webpack_require__(/*! ./delegate */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/delegate.js\");\nconst logger_1 = __webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/logger.js\");\nconst omit_1 = __webpack_require__(/*! ./omit */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/omit.js\");\nconst password_1 = __webpack_require__(/*! ./password */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/password.js\");\nconst policy_1 = __webpack_require__(/*! ./policy */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/policy/index.js\");\n/**\n * All enhancement kinds\n */\nconst ALL_ENHANCEMENTS = ['password', 'omit', 'policy', 'validation', 'delegate'];\n/**\n * Gets a Prisma client enhanced with all enhancement behaviors, including access\n * policy, field validation, field omission and password hashing.\n *\n * @private\n *\n * @param prisma The Prisma client to enhance.\n * @param context Context.\n * @param options Options.\n */\nfunction createEnhancement(prisma, options, context) {\n    var _a;\n    if (!prisma) {\n        throw new Error('Invalid prisma instance');\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const prismaVer = prisma._clientVersion;\n    if (prismaVer && semver_1.default.lt(prismaVer, constants_1.PRISMA_MINIMUM_VERSION)) {\n        console.warn(`ZenStack requires Prisma version \"${constants_1.PRISMA_MINIMUM_VERSION}\" or higher. Detected version is \"${prismaVer}\".`);\n    }\n    // TODO: move the detection logic into each enhancement\n    // TODO: how to properly cache the detection result?\n    const allFields = Object.values(options.modelMeta.models).flatMap((modelInfo) => Object.values(modelInfo.fields));\n    const hasPassword = allFields.some((field) => { var _a; return (_a = field.attributes) === null || _a === void 0 ? void 0 : _a.some((attr) => attr.name === '@password'); });\n    const hasOmit = allFields.some((field) => { var _a; return (_a = field.attributes) === null || _a === void 0 ? void 0 : _a.some((attr) => attr.name === '@omit'); });\n    const hasDefaultAuth = allFields.some((field) => field.defaultValueProvider);\n    const kinds = (_a = options.kinds) !== null && _a !== void 0 ? _a : ALL_ENHANCEMENTS;\n    let result = prisma;\n    // delegate proxy needs to be wrapped inside policy proxy, since it may translate `deleteMany`\n    // and `updateMany` to plain `delete` and `update`\n    if (Object.values(options.modelMeta.models).some((model) => (0, cross_1.isDelegateModel)(options.modelMeta, model.name))) {\n        if (!kinds.includes('delegate')) {\n            const logger = new logger_1.Logger(prisma);\n            logger.warn('Your ZModel contains delegate models but \"delegate\" enhancement kind is not enabled. This may result in unexpected behavior.');\n        }\n        else {\n            result = (0, delegate_1.withDelegate)(result, options);\n        }\n    }\n    // 'policy' and 'validation' enhancements are both enabled by `withPolicy`\n    if (kinds.includes('policy') || kinds.includes('validation')) {\n        result = (0, policy_1.withPolicy)(result, options, context);\n        if (kinds.includes('policy') && hasDefaultAuth) {\n            // @default(auth()) proxy\n            result = (0, default_auth_1.withDefaultAuth)(result, options, context);\n        }\n    }\n    if (hasPassword && kinds.includes('password')) {\n        // @password proxy\n        result = (0, password_1.withPassword)(result, options);\n    }\n    if (hasOmit && kinds.includes('omit')) {\n        // @omit proxy\n        result = (0, omit_1.withOmit)(result, options);\n    }\n    return result;\n}\nexports.createEnhancement = createEnhancement;\n//# sourceMappingURL=create-enhancement.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHplbnN0YWNraHErcnVudGltZUAyLjIuNF9AcHJpc21hK2NsaWVudEA1LjE3LjBfcHJpc21hQDUuMTcuMF8vbm9kZV9tb2R1bGVzL0B6ZW5zdGFja2hxL3J1bnRpbWUvZW5oYW5jZW1lbnRzL2NyZWF0ZS1lbmhhbmNlbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QjtBQUN6QixpQ0FBaUMsbUJBQU8sQ0FBQyxvRkFBUTtBQUNqRCxvQkFBb0IsbUJBQU8sQ0FBQyw2SkFBYztBQUMxQyxnQkFBZ0IsbUJBQU8sQ0FBQywySkFBVTtBQUNsQyx1QkFBdUIsbUJBQU8sQ0FBQywrS0FBZ0I7QUFDL0MsbUJBQW1CLG1CQUFPLENBQUMsdUtBQVk7QUFDdkMsaUJBQWlCLG1CQUFPLENBQUMsbUtBQVU7QUFDbkMsZUFBZSxtQkFBTyxDQUFDLCtKQUFRO0FBQy9CLG1CQUFtQixtQkFBTyxDQUFDLHVLQUFZO0FBQ3ZDLGlCQUFpQixtQkFBTyxDQUFDLHlLQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELG1DQUFtQyxvQ0FBb0MsVUFBVTtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxRQUFRLG1IQUFtSDtBQUMvSyxnREFBZ0QsUUFBUSwrR0FBK0c7QUFDdks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXJibGlzbS9uZXh0LWpzLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B6ZW5zdGFja2hxK3J1bnRpbWVAMi4yLjRfQHByaXNtYStjbGllbnRANS4xNy4wX3ByaXNtYUA1LjE3LjBfL25vZGVfbW9kdWxlcy9AemVuc3RhY2tocS9ydW50aW1lL2VuaGFuY2VtZW50cy9jcmVhdGUtZW5oYW5jZW1lbnQuanM/N2JmNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlRW5oYW5jZW1lbnQgPSB2b2lkIDA7XG5jb25zdCBzZW12ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwic2VtdmVyXCIpKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbmNvbnN0IGNyb3NzXzEgPSByZXF1aXJlKFwiLi4vY3Jvc3NcIik7XG5jb25zdCBkZWZhdWx0X2F1dGhfMSA9IHJlcXVpcmUoXCIuL2RlZmF1bHQtYXV0aFwiKTtcbmNvbnN0IGRlbGVnYXRlXzEgPSByZXF1aXJlKFwiLi9kZWxlZ2F0ZVwiKTtcbmNvbnN0IGxvZ2dlcl8xID0gcmVxdWlyZShcIi4vbG9nZ2VyXCIpO1xuY29uc3Qgb21pdF8xID0gcmVxdWlyZShcIi4vb21pdFwiKTtcbmNvbnN0IHBhc3N3b3JkXzEgPSByZXF1aXJlKFwiLi9wYXNzd29yZFwiKTtcbmNvbnN0IHBvbGljeV8xID0gcmVxdWlyZShcIi4vcG9saWN5XCIpO1xuLyoqXG4gKiBBbGwgZW5oYW5jZW1lbnQga2luZHNcbiAqL1xuY29uc3QgQUxMX0VOSEFOQ0VNRU5UUyA9IFsncGFzc3dvcmQnLCAnb21pdCcsICdwb2xpY3knLCAndmFsaWRhdGlvbicsICdkZWxlZ2F0ZSddO1xuLyoqXG4gKiBHZXRzIGEgUHJpc21hIGNsaWVudCBlbmhhbmNlZCB3aXRoIGFsbCBlbmhhbmNlbWVudCBiZWhhdmlvcnMsIGluY2x1ZGluZyBhY2Nlc3NcbiAqIHBvbGljeSwgZmllbGQgdmFsaWRhdGlvbiwgZmllbGQgb21pc3Npb24gYW5kIHBhc3N3b3JkIGhhc2hpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0gcHJpc21hIFRoZSBQcmlzbWEgY2xpZW50IHRvIGVuaGFuY2UuXG4gKiBAcGFyYW0gY29udGV4dCBDb250ZXh0LlxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRW5oYW5jZW1lbnQocHJpc21hLCBvcHRpb25zLCBjb250ZXh0KSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghcHJpc21hKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcmlzbWEgaW5zdGFuY2UnKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjb25zdCBwcmlzbWFWZXIgPSBwcmlzbWEuX2NsaWVudFZlcnNpb247XG4gICAgaWYgKHByaXNtYVZlciAmJiBzZW12ZXJfMS5kZWZhdWx0Lmx0KHByaXNtYVZlciwgY29uc3RhbnRzXzEuUFJJU01BX01JTklNVU1fVkVSU0lPTikpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBaZW5TdGFjayByZXF1aXJlcyBQcmlzbWEgdmVyc2lvbiBcIiR7Y29uc3RhbnRzXzEuUFJJU01BX01JTklNVU1fVkVSU0lPTn1cIiBvciBoaWdoZXIuIERldGVjdGVkIHZlcnNpb24gaXMgXCIke3ByaXNtYVZlcn1cIi5gKTtcbiAgICB9XG4gICAgLy8gVE9ETzogbW92ZSB0aGUgZGV0ZWN0aW9uIGxvZ2ljIGludG8gZWFjaCBlbmhhbmNlbWVudFxuICAgIC8vIFRPRE86IGhvdyB0byBwcm9wZXJseSBjYWNoZSB0aGUgZGV0ZWN0aW9uIHJlc3VsdD9cbiAgICBjb25zdCBhbGxGaWVsZHMgPSBPYmplY3QudmFsdWVzKG9wdGlvbnMubW9kZWxNZXRhLm1vZGVscykuZmxhdE1hcCgobW9kZWxJbmZvKSA9PiBPYmplY3QudmFsdWVzKG1vZGVsSW5mby5maWVsZHMpKTtcbiAgICBjb25zdCBoYXNQYXNzd29yZCA9IGFsbEZpZWxkcy5zb21lKChmaWVsZCkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBmaWVsZC5hdHRyaWJ1dGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc29tZSgoYXR0cikgPT4gYXR0ci5uYW1lID09PSAnQHBhc3N3b3JkJyk7IH0pO1xuICAgIGNvbnN0IGhhc09taXQgPSBhbGxGaWVsZHMuc29tZSgoZmllbGQpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gZmllbGQuYXR0cmlidXRlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNvbWUoKGF0dHIpID0+IGF0dHIubmFtZSA9PT0gJ0BvbWl0Jyk7IH0pO1xuICAgIGNvbnN0IGhhc0RlZmF1bHRBdXRoID0gYWxsRmllbGRzLnNvbWUoKGZpZWxkKSA9PiBmaWVsZC5kZWZhdWx0VmFsdWVQcm92aWRlcik7XG4gICAgY29uc3Qga2luZHMgPSAoX2EgPSBvcHRpb25zLmtpbmRzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBBTExfRU5IQU5DRU1FTlRTO1xuICAgIGxldCByZXN1bHQgPSBwcmlzbWE7XG4gICAgLy8gZGVsZWdhdGUgcHJveHkgbmVlZHMgdG8gYmUgd3JhcHBlZCBpbnNpZGUgcG9saWN5IHByb3h5LCBzaW5jZSBpdCBtYXkgdHJhbnNsYXRlIGBkZWxldGVNYW55YFxuICAgIC8vIGFuZCBgdXBkYXRlTWFueWAgdG8gcGxhaW4gYGRlbGV0ZWAgYW5kIGB1cGRhdGVgXG4gICAgaWYgKE9iamVjdC52YWx1ZXMob3B0aW9ucy5tb2RlbE1ldGEubW9kZWxzKS5zb21lKChtb2RlbCkgPT4gKDAsIGNyb3NzXzEuaXNEZWxlZ2F0ZU1vZGVsKShvcHRpb25zLm1vZGVsTWV0YSwgbW9kZWwubmFtZSkpKSB7XG4gICAgICAgIGlmICgha2luZHMuaW5jbHVkZXMoJ2RlbGVnYXRlJykpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvZ2dlciA9IG5ldyBsb2dnZXJfMS5Mb2dnZXIocHJpc21hKTtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdZb3VyIFpNb2RlbCBjb250YWlucyBkZWxlZ2F0ZSBtb2RlbHMgYnV0IFwiZGVsZWdhdGVcIiBlbmhhbmNlbWVudCBraW5kIGlzIG5vdCBlbmFibGVkLiBUaGlzIG1heSByZXN1bHQgaW4gdW5leHBlY3RlZCBiZWhhdmlvci4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9ICgwLCBkZWxlZ2F0ZV8xLndpdGhEZWxlZ2F0ZSkocmVzdWx0LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyAncG9saWN5JyBhbmQgJ3ZhbGlkYXRpb24nIGVuaGFuY2VtZW50cyBhcmUgYm90aCBlbmFibGVkIGJ5IGB3aXRoUG9saWN5YFxuICAgIGlmIChraW5kcy5pbmNsdWRlcygncG9saWN5JykgfHwga2luZHMuaW5jbHVkZXMoJ3ZhbGlkYXRpb24nKSkge1xuICAgICAgICByZXN1bHQgPSAoMCwgcG9saWN5XzEud2l0aFBvbGljeSkocmVzdWx0LCBvcHRpb25zLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGtpbmRzLmluY2x1ZGVzKCdwb2xpY3knKSAmJiBoYXNEZWZhdWx0QXV0aCkge1xuICAgICAgICAgICAgLy8gQGRlZmF1bHQoYXV0aCgpKSBwcm94eVxuICAgICAgICAgICAgcmVzdWx0ID0gKDAsIGRlZmF1bHRfYXV0aF8xLndpdGhEZWZhdWx0QXV0aCkocmVzdWx0LCBvcHRpb25zLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaGFzUGFzc3dvcmQgJiYga2luZHMuaW5jbHVkZXMoJ3Bhc3N3b3JkJykpIHtcbiAgICAgICAgLy8gQHBhc3N3b3JkIHByb3h5XG4gICAgICAgIHJlc3VsdCA9ICgwLCBwYXNzd29yZF8xLndpdGhQYXNzd29yZCkocmVzdWx0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKGhhc09taXQgJiYga2luZHMuaW5jbHVkZXMoJ29taXQnKSkge1xuICAgICAgICAvLyBAb21pdCBwcm94eVxuICAgICAgICByZXN1bHQgPSAoMCwgb21pdF8xLndpdGhPbWl0KShyZXN1bHQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5jcmVhdGVFbmhhbmNlbWVudCA9IGNyZWF0ZUVuaGFuY2VtZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlLWVuaGFuY2VtZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/create-enhancement.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/default-auth.js":
/*!*********************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/default-auth.js ***!
  \*********************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.withDefaultAuth = void 0;\nconst deepcopy_1 = __importDefault(__webpack_require__(/*! deepcopy */ \"(rsc)/./node_modules/.pnpm/deepcopy@2.1.0/node_modules/deepcopy/index.mjs\"));\nconst cross_1 = __webpack_require__(/*! ../cross */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/cross/index.js\");\nconst proxy_1 = __webpack_require__(/*! ./proxy */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/proxy.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/utils.js\");\n/**\n * Gets an enhanced Prisma client that supports `@default(auth())` attribute.\n *\n * @private\n */\nfunction withDefaultAuth(prisma, options, context = {}) {\n    return (0, proxy_1.makeProxy)(prisma, options.modelMeta, (_prisma, model) => new DefaultAuthHandler(_prisma, model, options, context), 'defaultAuth');\n}\nexports.withDefaultAuth = withDefaultAuth;\nclass DefaultAuthHandler extends proxy_1.DefaultPrismaProxyHandler {\n    constructor(prisma, model, options, context) {\n        super(prisma, model, options);\n        this.context = context;\n        this.userContext = this.context.user;\n    }\n    // base override\n    preprocessArgs(action, args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const actionsOfInterest = ['create', 'createMany', 'update', 'updateMany', 'upsert'];\n            if (actionsOfInterest.includes(action)) {\n                const newArgs = yield this.preprocessWritePayload(this.model, action, args);\n                return newArgs;\n            }\n            return args;\n        });\n    }\n    preprocessWritePayload(model, action, args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const newArgs = (0, deepcopy_1.default)(args);\n            const processCreatePayload = (model, data) => {\n                const fields = (0, cross_1.getFields)(this.options.modelMeta, model);\n                for (const fieldInfo of Object.values(fields)) {\n                    if (fieldInfo.name in data) {\n                        // create payload already sets field value\n                        continue;\n                    }\n                    if (!fieldInfo.defaultValueProvider) {\n                        // field doesn't have a runtime default value provider\n                        continue;\n                    }\n                    const authDefaultValue = this.getDefaultValueFromAuth(fieldInfo);\n                    if (authDefaultValue !== undefined) {\n                        // set field value extracted from `auth()`\n                        this.setAuthDefaultValue(fieldInfo, model, data, authDefaultValue);\n                    }\n                }\n            };\n            // visit create payload and set default value to fields using `auth()` in `@default()`\n            const visitor = new cross_1.NestedWriteVisitor(this.options.modelMeta, {\n                create: (model, data) => {\n                    processCreatePayload(model, data);\n                },\n                upsert: (model, data) => {\n                    processCreatePayload(model, data.create);\n                },\n                createMany: (model, args) => {\n                    for (const item of (0, cross_1.enumerate)(args.data)) {\n                        processCreatePayload(model, item);\n                    }\n                },\n            });\n            yield visitor.visit(model, action, newArgs);\n            return newArgs;\n        });\n    }\n    setAuthDefaultValue(fieldInfo, model, data, authDefaultValue) {\n        var _a;\n        if (fieldInfo.isForeignKey && fieldInfo.relationField && fieldInfo.relationField in data) {\n            // if the field is a fk, and the relation field is already set, we should not override it\n            return;\n        }\n        if (fieldInfo.isForeignKey && !(0, utils_1.isUnsafeMutate)(model, data, this.options.modelMeta)) {\n            // if the field is a fk, and the create payload is not unsafe, we need to translate\n            // the fk field setting to a `connect` of the corresponding relation field\n            const relFieldName = fieldInfo.relationField;\n            if (!relFieldName) {\n                throw new Error(`Field \\`${fieldInfo.name}\\` is a foreign key field but no corresponding relation field is found`);\n            }\n            const relationField = (0, cross_1.requireField)(this.options.modelMeta, model, relFieldName);\n            // construct a `{ connect: { ... } }` payload\n            let connect = (_a = data[relationField.name]) === null || _a === void 0 ? void 0 : _a.connect;\n            if (!connect) {\n                connect = {};\n                data[relationField.name] = { connect };\n            }\n            // sets the opposite fk field to value `authDefaultValue`\n            const oppositeFkFieldName = this.getOppositeFkFieldName(relationField, fieldInfo);\n            if (!oppositeFkFieldName) {\n                throw new Error(`Cannot find opposite foreign key field for \\`${fieldInfo.name}\\` in relation field \\`${relFieldName}\\``);\n            }\n            connect[oppositeFkFieldName] = authDefaultValue;\n        }\n        else {\n            // set default value directly\n            data[fieldInfo.name] = authDefaultValue;\n        }\n    }\n    getOppositeFkFieldName(relationField, fieldInfo) {\n        if (!relationField.foreignKeyMapping) {\n            return undefined;\n        }\n        const entry = Object.entries(relationField.foreignKeyMapping).find(([, v]) => v === fieldInfo.name);\n        return entry === null || entry === void 0 ? void 0 : entry[0];\n    }\n    getDefaultValueFromAuth(fieldInfo) {\n        var _a;\n        if (!this.userContext) {\n            throw new Error(`Evaluating default value of field \\`${fieldInfo.name}\\` requires a user context`);\n        }\n        return (_a = fieldInfo.defaultValueProvider) === null || _a === void 0 ? void 0 : _a.call(fieldInfo, this.userContext);\n    }\n}\n//# sourceMappingURL=default-auth.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHplbnN0YWNraHErcnVudGltZUAyLjIuNF9AcHJpc21hK2NsaWVudEA1LjE3LjBfcHJpc21hQDUuMTcuMF8vbm9kZV9tb2R1bGVzL0B6ZW5zdGFja2hxL3J1bnRpbWUvZW5oYW5jZW1lbnRzL2RlZmF1bHQtYXV0aC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCLG1DQUFtQyxtQkFBTyxDQUFDLDJGQUFVO0FBQ3JELGdCQUFnQixtQkFBTyxDQUFDLDJKQUFVO0FBQ2xDLGdCQUFnQixtQkFBTyxDQUFDLGlLQUFTO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLGlLQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxlQUFlO0FBQzFEO0FBQ0E7QUFDQSw4QkFBOEIsV0FBVyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixlQUFlLHlCQUF5QixhQUFhO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxlQUFlO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFyYmxpc20vbmV4dC1qcy8uL25vZGVfbW9kdWxlcy8ucG5wbS9AemVuc3RhY2tocStydW50aW1lQDIuMi40X0BwcmlzbWErY2xpZW50QDUuMTcuMF9wcmlzbWFANS4xNy4wXy9ub2RlX21vZHVsZXMvQHplbnN0YWNraHEvcnVudGltZS9lbmhhbmNlbWVudHMvZGVmYXVsdC1hdXRoLmpzPzNlZWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy53aXRoRGVmYXVsdEF1dGggPSB2b2lkIDA7XG5jb25zdCBkZWVwY29weV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWVwY29weVwiKSk7XG5jb25zdCBjcm9zc18xID0gcmVxdWlyZShcIi4uL2Nyb3NzXCIpO1xuY29uc3QgcHJveHlfMSA9IHJlcXVpcmUoXCIuL3Byb3h5XCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBHZXRzIGFuIGVuaGFuY2VkIFByaXNtYSBjbGllbnQgdGhhdCBzdXBwb3J0cyBgQGRlZmF1bHQoYXV0aCgpKWAgYXR0cmlidXRlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHdpdGhEZWZhdWx0QXV0aChwcmlzbWEsIG9wdGlvbnMsIGNvbnRleHQgPSB7fSkge1xuICAgIHJldHVybiAoMCwgcHJveHlfMS5tYWtlUHJveHkpKHByaXNtYSwgb3B0aW9ucy5tb2RlbE1ldGEsIChfcHJpc21hLCBtb2RlbCkgPT4gbmV3IERlZmF1bHRBdXRoSGFuZGxlcihfcHJpc21hLCBtb2RlbCwgb3B0aW9ucywgY29udGV4dCksICdkZWZhdWx0QXV0aCcpO1xufVxuZXhwb3J0cy53aXRoRGVmYXVsdEF1dGggPSB3aXRoRGVmYXVsdEF1dGg7XG5jbGFzcyBEZWZhdWx0QXV0aEhhbmRsZXIgZXh0ZW5kcyBwcm94eV8xLkRlZmF1bHRQcmlzbWFQcm94eUhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKHByaXNtYSwgbW9kZWwsIG9wdGlvbnMsIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIocHJpc21hLCBtb2RlbCwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMudXNlckNvbnRleHQgPSB0aGlzLmNvbnRleHQudXNlcjtcbiAgICB9XG4gICAgLy8gYmFzZSBvdmVycmlkZVxuICAgIHByZXByb2Nlc3NBcmdzKGFjdGlvbiwgYXJncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgYWN0aW9uc09mSW50ZXJlc3QgPSBbJ2NyZWF0ZScsICdjcmVhdGVNYW55JywgJ3VwZGF0ZScsICd1cGRhdGVNYW55JywgJ3Vwc2VydCddO1xuICAgICAgICAgICAgaWYgKGFjdGlvbnNPZkludGVyZXN0LmluY2x1ZGVzKGFjdGlvbikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdBcmdzID0geWllbGQgdGhpcy5wcmVwcm9jZXNzV3JpdGVQYXlsb2FkKHRoaXMubW9kZWwsIGFjdGlvbiwgYXJncyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0FyZ3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHByZXByb2Nlc3NXcml0ZVBheWxvYWQobW9kZWwsIGFjdGlvbiwgYXJncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgbmV3QXJncyA9ICgwLCBkZWVwY29weV8xLmRlZmF1bHQpKGFyZ3MpO1xuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc0NyZWF0ZVBheWxvYWQgPSAobW9kZWwsIGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZHMgPSAoMCwgY3Jvc3NfMS5nZXRGaWVsZHMpKHRoaXMub3B0aW9ucy5tb2RlbE1ldGEsIG1vZGVsKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkSW5mbyBvZiBPYmplY3QudmFsdWVzKGZpZWxkcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkSW5mby5uYW1lIGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBwYXlsb2FkIGFscmVhZHkgc2V0cyBmaWVsZCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZEluZm8uZGVmYXVsdFZhbHVlUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpZWxkIGRvZXNuJ3QgaGF2ZSBhIHJ1bnRpbWUgZGVmYXVsdCB2YWx1ZSBwcm92aWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXV0aERlZmF1bHRWYWx1ZSA9IHRoaXMuZ2V0RGVmYXVsdFZhbHVlRnJvbUF1dGgoZmllbGRJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF1dGhEZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IGZpZWxkIHZhbHVlIGV4dHJhY3RlZCBmcm9tIGBhdXRoKClgXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF1dGhEZWZhdWx0VmFsdWUoZmllbGRJbmZvLCBtb2RlbCwgZGF0YSwgYXV0aERlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gdmlzaXQgY3JlYXRlIHBheWxvYWQgYW5kIHNldCBkZWZhdWx0IHZhbHVlIHRvIGZpZWxkcyB1c2luZyBgYXV0aCgpYCBpbiBgQGRlZmF1bHQoKWBcbiAgICAgICAgICAgIGNvbnN0IHZpc2l0b3IgPSBuZXcgY3Jvc3NfMS5OZXN0ZWRXcml0ZVZpc2l0b3IodGhpcy5vcHRpb25zLm1vZGVsTWV0YSwge1xuICAgICAgICAgICAgICAgIGNyZWF0ZTogKG1vZGVsLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NDcmVhdGVQYXlsb2FkKG1vZGVsLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHVwc2VydDogKG1vZGVsLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NDcmVhdGVQYXlsb2FkKG1vZGVsLCBkYXRhLmNyZWF0ZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjcmVhdGVNYW55OiAobW9kZWwsIGFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mICgwLCBjcm9zc18xLmVudW1lcmF0ZSkoYXJncy5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0NyZWF0ZVBheWxvYWQobW9kZWwsIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgeWllbGQgdmlzaXRvci52aXNpdChtb2RlbCwgYWN0aW9uLCBuZXdBcmdzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXdBcmdzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0QXV0aERlZmF1bHRWYWx1ZShmaWVsZEluZm8sIG1vZGVsLCBkYXRhLCBhdXRoRGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKGZpZWxkSW5mby5pc0ZvcmVpZ25LZXkgJiYgZmllbGRJbmZvLnJlbGF0aW9uRmllbGQgJiYgZmllbGRJbmZvLnJlbGF0aW9uRmllbGQgaW4gZGF0YSkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGZpZWxkIGlzIGEgZmssIGFuZCB0aGUgcmVsYXRpb24gZmllbGQgaXMgYWxyZWFkeSBzZXQsIHdlIHNob3VsZCBub3Qgb3ZlcnJpZGUgaXRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGRJbmZvLmlzRm9yZWlnbktleSAmJiAhKDAsIHV0aWxzXzEuaXNVbnNhZmVNdXRhdGUpKG1vZGVsLCBkYXRhLCB0aGlzLm9wdGlvbnMubW9kZWxNZXRhKSkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGZpZWxkIGlzIGEgZmssIGFuZCB0aGUgY3JlYXRlIHBheWxvYWQgaXMgbm90IHVuc2FmZSwgd2UgbmVlZCB0byB0cmFuc2xhdGVcbiAgICAgICAgICAgIC8vIHRoZSBmayBmaWVsZCBzZXR0aW5nIHRvIGEgYGNvbm5lY3RgIG9mIHRoZSBjb3JyZXNwb25kaW5nIHJlbGF0aW9uIGZpZWxkXG4gICAgICAgICAgICBjb25zdCByZWxGaWVsZE5hbWUgPSBmaWVsZEluZm8ucmVsYXRpb25GaWVsZDtcbiAgICAgICAgICAgIGlmICghcmVsRmllbGROYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaWVsZCBcXGAke2ZpZWxkSW5mby5uYW1lfVxcYCBpcyBhIGZvcmVpZ24ga2V5IGZpZWxkIGJ1dCBubyBjb3JyZXNwb25kaW5nIHJlbGF0aW9uIGZpZWxkIGlzIGZvdW5kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZWxhdGlvbkZpZWxkID0gKDAsIGNyb3NzXzEucmVxdWlyZUZpZWxkKSh0aGlzLm9wdGlvbnMubW9kZWxNZXRhLCBtb2RlbCwgcmVsRmllbGROYW1lKTtcbiAgICAgICAgICAgIC8vIGNvbnN0cnVjdCBhIGB7IGNvbm5lY3Q6IHsgLi4uIH0gfWAgcGF5bG9hZFxuICAgICAgICAgICAgbGV0IGNvbm5lY3QgPSAoX2EgPSBkYXRhW3JlbGF0aW9uRmllbGQubmFtZV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25uZWN0O1xuICAgICAgICAgICAgaWYgKCFjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdCA9IHt9O1xuICAgICAgICAgICAgICAgIGRhdGFbcmVsYXRpb25GaWVsZC5uYW1lXSA9IHsgY29ubmVjdCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0cyB0aGUgb3Bwb3NpdGUgZmsgZmllbGQgdG8gdmFsdWUgYGF1dGhEZWZhdWx0VmFsdWVgXG4gICAgICAgICAgICBjb25zdCBvcHBvc2l0ZUZrRmllbGROYW1lID0gdGhpcy5nZXRPcHBvc2l0ZUZrRmllbGROYW1lKHJlbGF0aW9uRmllbGQsIGZpZWxkSW5mbyk7XG4gICAgICAgICAgICBpZiAoIW9wcG9zaXRlRmtGaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBmaW5kIG9wcG9zaXRlIGZvcmVpZ24ga2V5IGZpZWxkIGZvciBcXGAke2ZpZWxkSW5mby5uYW1lfVxcYCBpbiByZWxhdGlvbiBmaWVsZCBcXGAke3JlbEZpZWxkTmFtZX1cXGBgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbm5lY3Rbb3Bwb3NpdGVGa0ZpZWxkTmFtZV0gPSBhdXRoRGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gc2V0IGRlZmF1bHQgdmFsdWUgZGlyZWN0bHlcbiAgICAgICAgICAgIGRhdGFbZmllbGRJbmZvLm5hbWVdID0gYXV0aERlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRPcHBvc2l0ZUZrRmllbGROYW1lKHJlbGF0aW9uRmllbGQsIGZpZWxkSW5mbykge1xuICAgICAgICBpZiAoIXJlbGF0aW9uRmllbGQuZm9yZWlnbktleU1hcHBpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW50cnkgPSBPYmplY3QuZW50cmllcyhyZWxhdGlvbkZpZWxkLmZvcmVpZ25LZXlNYXBwaW5nKS5maW5kKChbLCB2XSkgPT4gdiA9PT0gZmllbGRJbmZvLm5hbWUpO1xuICAgICAgICByZXR1cm4gZW50cnkgPT09IG51bGwgfHwgZW50cnkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVudHJ5WzBdO1xuICAgIH1cbiAgICBnZXREZWZhdWx0VmFsdWVGcm9tQXV0aChmaWVsZEluZm8pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMudXNlckNvbnRleHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXZhbHVhdGluZyBkZWZhdWx0IHZhbHVlIG9mIGZpZWxkIFxcYCR7ZmllbGRJbmZvLm5hbWV9XFxgIHJlcXVpcmVzIGEgdXNlciBjb250ZXh0YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChfYSA9IGZpZWxkSW5mby5kZWZhdWx0VmFsdWVQcm92aWRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoZmllbGRJbmZvLCB0aGlzLnVzZXJDb250ZXh0KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0LWF1dGguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/default-auth.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/delegate.js":
/*!*****************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/delegate.js ***!
  \*****************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DelegateProxyHandler = exports.withDelegate = void 0;\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst deepcopy_1 = __importDefault(__webpack_require__(/*! deepcopy */ \"(rsc)/./node_modules/.pnpm/deepcopy@2.1.0/node_modules/deepcopy/index.mjs\"));\nconst deepmerge_1 = __importDefault(__webpack_require__(/*! deepmerge */ \"(rsc)/./node_modules/.pnpm/deepmerge@4.3.1/node_modules/deepmerge/dist/cjs.js\"));\nconst is_plain_object_1 = __webpack_require__(/*! is-plain-object */ \"(rsc)/./node_modules/.pnpm/is-plain-object@5.0.0/node_modules/is-plain-object/dist/is-plain-object.js\");\nconst lower_case_first_1 = __webpack_require__(/*! lower-case-first */ \"(rsc)/./node_modules/.pnpm/lower-case-first@2.0.2/node_modules/lower-case-first/dist.es2015/index.js\");\nconst constants_1 = __webpack_require__(/*! ../constants */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/constants.js\");\nconst cross_1 = __webpack_require__(/*! ../cross */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/cross/index.js\");\nconst logger_1 = __webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/logger.js\");\nconst proxy_1 = __webpack_require__(/*! ./proxy */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/proxy.js\");\nconst query_utils_1 = __webpack_require__(/*! ./query-utils */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/query-utils.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/utils.js\");\nfunction withDelegate(prisma, options) {\n    return (0, proxy_1.makeProxy)(prisma, options.modelMeta, (_prisma, model) => new DelegateProxyHandler(_prisma, model, options), 'delegate');\n}\nexports.withDelegate = withDelegate;\nclass DelegateProxyHandler extends proxy_1.DefaultPrismaProxyHandler {\n    constructor(prisma, model, options) {\n        super(prisma, model, options);\n        this.logger = new logger_1.Logger(prisma);\n        this.queryUtils = new query_utils_1.QueryUtils(prisma, this.options);\n    }\n    // #region find\n    findFirst(args) {\n        return this.doFind(this.prisma, this.model, 'findFirst', args);\n    }\n    findFirstOrThrow(args) {\n        return this.doFind(this.prisma, this.model, 'findFirstOrThrow', args);\n    }\n    findUnique(args) {\n        return this.doFind(this.prisma, this.model, 'findUnique', args);\n    }\n    findUniqueOrThrow(args) {\n        return this.doFind(this.prisma, this.model, 'findUniqueOrThrow', args);\n    }\n    findMany(args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.doFind(this.prisma, this.model, 'findMany', args);\n        });\n    }\n    doFind(db, model, method, args) {\n        const _superIndex = name => super[name];\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.involvesDelegateModel(model)) {\n                return _superIndex(method).call(this, args);\n            }\n            args = args ? (0, deepcopy_1.default)(args) : {};\n            this.injectWhereHierarchy(model, args === null || args === void 0 ? void 0 : args.where);\n            this.injectSelectIncludeHierarchy(model, args);\n            if (args.orderBy) {\n                // `orderBy` may contain fields from base types\n                args.orderBy = this.buildWhereHierarchy(this.model, args.orderBy);\n            }\n            if (this.options.logPrismaQuery) {\n                this.logger.info(`[delegate] \\`${method}\\` ${this.getModelName(model)}: ${(0, utils_1.formatObject)(args)}`);\n            }\n            const entity = yield db[model][method](args);\n            if (Array.isArray(entity)) {\n                return entity.map((item) => this.assembleHierarchy(model, item));\n            }\n            else {\n                return this.assembleHierarchy(model, entity);\n            }\n        });\n    }\n    injectWhereHierarchy(model, where) {\n        if (!where || typeof where !== 'object') {\n            return;\n        }\n        Object.entries(where).forEach(([field, value]) => {\n            if (['AND', 'OR', 'NOT'].includes(field)) {\n                // recurse into logical group\n                (0, cross_1.enumerate)(value).forEach((item) => this.injectWhereHierarchy(model, item));\n                return;\n            }\n            const fieldInfo = (0, cross_1.resolveField)(this.options.modelMeta, model, field);\n            if (!(fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.inheritedFrom)) {\n                return;\n            }\n            let base = this.getBaseModel(model);\n            let target = where;\n            while (base) {\n                const baseRelationName = this.makeAuxRelationName(base);\n                // prepare base layer where\n                let thisLayer;\n                if (target[baseRelationName]) {\n                    thisLayer = target[baseRelationName];\n                }\n                else {\n                    thisLayer = target[baseRelationName] = {};\n                }\n                if (base.name === fieldInfo.inheritedFrom) {\n                    thisLayer[field] = value;\n                    delete where[field];\n                    break;\n                }\n                else {\n                    target = thisLayer;\n                    base = this.getBaseModel(base.name);\n                }\n            }\n        });\n    }\n    buildWhereHierarchy(model, where) {\n        if (!where) {\n            return undefined;\n        }\n        where = (0, deepcopy_1.default)(where);\n        Object.entries(where).forEach(([field, value]) => {\n            const fieldInfo = (0, cross_1.resolveField)(this.options.modelMeta, model, field);\n            if (!(fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.inheritedFrom)) {\n                return;\n            }\n            let base = this.getBaseModel(model);\n            let target = where;\n            while (base) {\n                const baseRelationName = this.makeAuxRelationName(base);\n                // prepare base layer where\n                let thisLayer;\n                if (target[baseRelationName]) {\n                    thisLayer = target[baseRelationName];\n                }\n                else {\n                    thisLayer = target[baseRelationName] = {};\n                }\n                if (base.name === fieldInfo.inheritedFrom) {\n                    thisLayer[field] = value;\n                    delete where[field];\n                    break;\n                }\n                else {\n                    target = thisLayer;\n                    base = this.getBaseModel(base.name);\n                }\n            }\n        });\n        return where;\n    }\n    injectSelectIncludeHierarchy(model, args) {\n        if (!args || typeof args !== 'object') {\n            return;\n        }\n        for (const kind of ['select', 'include']) {\n            if (args[kind] && typeof args[kind] === 'object') {\n                for (const [field, value] of Object.entries(args[kind])) {\n                    const fieldInfo = (0, cross_1.resolveField)(this.options.modelMeta, model, field);\n                    if (fieldInfo && value !== undefined) {\n                        if (value === null || value === void 0 ? void 0 : value.orderBy) {\n                            // `orderBy` may contain fields from base types\n                            value.orderBy = this.buildWhereHierarchy(fieldInfo.type, value.orderBy);\n                        }\n                        if (this.injectBaseFieldSelect(model, field, value, args, kind)) {\n                            delete args[kind][field];\n                        }\n                        else if (fieldInfo.isDataModel) {\n                            let nextValue = value;\n                            if (nextValue === true) {\n                                // make sure the payload is an object\n                                args[kind][field] = nextValue = {};\n                            }\n                            this.injectSelectIncludeHierarchy(fieldInfo.type, nextValue);\n                        }\n                    }\n                }\n            }\n        }\n        if (!args.select) {\n            // include base models upwards\n            this.injectBaseIncludeRecursively(model, args);\n            // include sub models downwards\n            this.injectConcreteIncludeRecursively(model, args);\n        }\n    }\n    buildSelectIncludeHierarchy(model, args) {\n        args = (0, deepcopy_1.default)(args);\n        const selectInclude = this.extractSelectInclude(args) || {};\n        if (selectInclude.select && typeof selectInclude.select === 'object') {\n            Object.entries(selectInclude.select).forEach(([field, value]) => {\n                if (value) {\n                    if (this.injectBaseFieldSelect(model, field, value, selectInclude, 'select')) {\n                        delete selectInclude.select[field];\n                    }\n                }\n            });\n        }\n        else if (selectInclude.include && typeof selectInclude.include === 'object') {\n            Object.entries(selectInclude.include).forEach(([field, value]) => {\n                if (value) {\n                    if (this.injectBaseFieldSelect(model, field, value, selectInclude, 'include')) {\n                        delete selectInclude.include[field];\n                    }\n                }\n            });\n        }\n        if (!selectInclude.select) {\n            this.injectBaseIncludeRecursively(model, selectInclude);\n            this.injectConcreteIncludeRecursively(model, selectInclude);\n        }\n        return selectInclude;\n    }\n    injectBaseFieldSelect(model, field, value, selectInclude, context) {\n        const fieldInfo = (0, cross_1.resolveField)(this.options.modelMeta, model, field);\n        if (!(fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.inheritedFrom)) {\n            return false;\n        }\n        let base = this.getBaseModel(model);\n        let target = selectInclude;\n        while (base) {\n            const baseRelationName = this.makeAuxRelationName(base);\n            // prepare base layer select/include\n            // let selectOrInclude = 'select';\n            let thisLayer;\n            if (target.include) {\n                // selectOrInclude = 'include';\n                thisLayer = target.include;\n            }\n            else if (target.select) {\n                // selectOrInclude = 'select';\n                thisLayer = target.select;\n            }\n            else {\n                // selectInclude = 'include';\n                thisLayer = target.select = {};\n            }\n            if (base.name === fieldInfo.inheritedFrom) {\n                if (!thisLayer[baseRelationName]) {\n                    thisLayer[baseRelationName] = { [context]: {} };\n                }\n                thisLayer[baseRelationName][context][field] = value;\n                break;\n            }\n            else {\n                if (!thisLayer[baseRelationName]) {\n                    thisLayer[baseRelationName] = { select: {} };\n                }\n                target = thisLayer[baseRelationName];\n                base = this.getBaseModel(base.name);\n            }\n        }\n        return true;\n    }\n    injectBaseIncludeRecursively(model, selectInclude) {\n        const base = this.getBaseModel(model);\n        if (!base) {\n            return;\n        }\n        const baseRelationName = this.makeAuxRelationName(base);\n        if (selectInclude.select) {\n            selectInclude.include = Object.assign({ [baseRelationName]: {} }, selectInclude.select);\n            delete selectInclude.select;\n        }\n        else {\n            selectInclude.include = Object.assign({ [baseRelationName]: {} }, selectInclude.include);\n        }\n        this.injectBaseIncludeRecursively(base.name, selectInclude.include[baseRelationName]);\n    }\n    injectConcreteIncludeRecursively(model, selectInclude) {\n        const modelInfo = (0, cross_1.getModelInfo)(this.options.modelMeta, model);\n        if (!modelInfo) {\n            return;\n        }\n        // get sub models of this model\n        const subModels = Object.values(this.options.modelMeta.models).filter((m) => { var _a; return (_a = m.baseTypes) === null || _a === void 0 ? void 0 : _a.includes(modelInfo.name); });\n        for (const subModel of subModels) {\n            // include sub model relation field\n            const subRelationName = this.makeAuxRelationName(subModel);\n            if (selectInclude.select) {\n                selectInclude.include = Object.assign({ [subRelationName]: {} }, selectInclude.select);\n                delete selectInclude.select;\n            }\n            else {\n                selectInclude.include = Object.assign({ [subRelationName]: {} }, selectInclude.include);\n            }\n            this.injectConcreteIncludeRecursively(subModel.name, selectInclude.include[subRelationName]);\n        }\n    }\n    // #endregion\n    // #region create\n    create(args) {\n        const _super = Object.create(null, {\n            create: { get: () => super.create }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!args) {\n                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'query argument is required');\n            }\n            if (!args.data) {\n                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'data field is required in query argument');\n            }\n            if ((0, cross_1.isDelegateModel)(this.options.modelMeta, this.model)) {\n                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, `Model \"${this.model}\" is a delegate and cannot be created directly`);\n            }\n            if (!this.involvesDelegateModel(this.model)) {\n                return _super.create.call(this, args);\n            }\n            return this.doCreate(this.prisma, this.model, args);\n        });\n    }\n    createMany(args) {\n        if (!args) {\n            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'query argument is required');\n        }\n        if (!args.data) {\n            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'data field is required in query argument');\n        }\n        if (!this.involvesDelegateModel(this.model)) {\n            return super.createMany(args);\n        }\n        if (this.isDelegateOrDescendantOfDelegate(this.model) && args.skipDuplicates) {\n            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, '`createMany` with `skipDuplicates` set to true is not supported for delegated models');\n        }\n        // `createMany` doesn't support nested create, which is needed for creating entities\n        // inheriting a delegate base, so we need to convert it to a regular `create` here.\n        // Note that the main difference is `create` doesn't support `skipDuplicates` as\n        // `createMany` does.\n        return this.queryUtils.transaction(this.prisma, (tx) => __awaiter(this, void 0, void 0, function* () {\n            const r = yield Promise.all((0, cross_1.enumerate)(args.data).map((item) => __awaiter(this, void 0, void 0, function* () {\n                return this.doCreate(tx, this.model, { data: item });\n            })));\n            // filter out undefined value (due to skipping duplicates)\n            return { count: r.filter((item) => !!item).length };\n        }));\n    }\n    doCreate(db, model, args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            args = (0, deepcopy_1.default)(args);\n            yield this.injectCreateHierarchy(model, args);\n            this.injectSelectIncludeHierarchy(model, args);\n            if (this.options.logPrismaQuery) {\n                this.logger.info(`[delegate] \\`create\\` ${this.getModelName(model)}: ${(0, utils_1.formatObject)(args)}`);\n            }\n            const result = yield db[model].create(args);\n            return this.assembleHierarchy(model, result);\n        });\n    }\n    injectCreateHierarchy(model, args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const visitor = new cross_1.NestedWriteVisitor(this.options.modelMeta, {\n                create: (model, args, _context) => {\n                    this.doProcessCreatePayload(model, args);\n                },\n                createMany: (model, args, context) => {\n                    // `createMany` doesn't support nested create, which is needed for creating entities\n                    // inheriting a delegate base, so we need to convert it to a regular `create` here.\n                    // Note that the main difference is `create` doesn't support `skipDuplicates` as\n                    // `createMany` does.\n                    var _a;\n                    if (this.isDelegateOrDescendantOfDelegate(model)) {\n                        if (args.skipDuplicates) {\n                            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, '`createMany` with `skipDuplicates` set to true is not supported for delegated models');\n                        }\n                        // convert to regular `create`\n                        let createPayload = (_a = context.parent.create) !== null && _a !== void 0 ? _a : [];\n                        if (!Array.isArray(createPayload)) {\n                            createPayload = [createPayload];\n                        }\n                        for (const item of (0, cross_1.enumerate)(args.data)) {\n                            this.doProcessCreatePayload(model, item);\n                            createPayload.push(item);\n                        }\n                        context.parent.create = createPayload;\n                        delete context.parent['createMany'];\n                    }\n                },\n            });\n            yield visitor.visit(model, 'create', args);\n        });\n    }\n    doProcessCreatePayload(model, args) {\n        if (!args) {\n            return;\n        }\n        this.ensureBaseCreateHierarchy(model, args);\n        for (const [field, value] of Object.entries(args)) {\n            const fieldInfo = (0, cross_1.resolveField)(this.options.modelMeta, model, field);\n            if (fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.inheritedFrom) {\n                this.injectBaseFieldData(model, fieldInfo, value, args, 'create');\n                delete args[field];\n            }\n        }\n    }\n    // ensure the full nested \"create\" structure is created for base types\n    ensureBaseCreateHierarchy(model, args) {\n        let curr = args;\n        let base = this.getBaseModel(model);\n        let sub = this.getModelInfo(model);\n        while (base) {\n            const baseRelationName = this.makeAuxRelationName(base);\n            if (!curr[baseRelationName]) {\n                curr[baseRelationName] = {};\n            }\n            if (!curr[baseRelationName].create) {\n                curr[baseRelationName].create = {};\n                if (base.discriminator) {\n                    // set discriminator field\n                    curr[baseRelationName].create[base.discriminator] = sub.name;\n                }\n            }\n            // Look for base id field assignments in the current level, and push\n            // them down to the base level\n            for (const idField of (0, cross_1.getIdFields)(this.options.modelMeta, base.name)) {\n                if (curr[idField.name] !== undefined) {\n                    curr[baseRelationName].create[idField.name] = curr[idField.name];\n                    delete curr[idField.name];\n                }\n            }\n            curr = curr[baseRelationName].create;\n            sub = base;\n            base = this.getBaseModel(base.name);\n        }\n    }\n    // inject field data that belongs to base type into proper nesting structure\n    injectBaseFieldData(model, fieldInfo, value, args, mode) {\n        let base = this.getBaseModel(model);\n        let curr = args;\n        while (base) {\n            if (base.discriminator === fieldInfo.name) {\n                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, `fields \"${fieldInfo.name}\" is a discriminator and cannot be set directly`);\n            }\n            const baseRelationName = this.makeAuxRelationName(base);\n            if (!curr[baseRelationName]) {\n                curr[baseRelationName] = {};\n            }\n            if (!curr[baseRelationName][mode]) {\n                curr[baseRelationName][mode] = {};\n            }\n            curr = curr[baseRelationName][mode];\n            if (fieldInfo.inheritedFrom === base.name) {\n                curr[fieldInfo.name] = value;\n                break;\n            }\n            base = this.getBaseModel(base.name);\n        }\n    }\n    // #endregion\n    // #region update\n    update(args) {\n        if (!args) {\n            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'query argument is required');\n        }\n        if (!args.data) {\n            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'data field is required in query argument');\n        }\n        if (!this.involvesDelegateModel(this.model)) {\n            return super.update(args);\n        }\n        return this.queryUtils.transaction(this.prisma, (tx) => this.doUpdate(tx, this.model, args));\n    }\n    updateMany(args) {\n        const _super = Object.create(null, {\n            updateMany: { get: () => super.updateMany }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!args) {\n                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'query argument is required');\n            }\n            if (!args.data) {\n                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'data field is required in query argument');\n            }\n            if (!this.involvesDelegateModel(this.model)) {\n                return _super.updateMany.call(this, args);\n            }\n            const simpleUpdateMany = Object.keys(args.data).every((key) => {\n                // check if the `data` clause involves base fields\n                const fieldInfo = (0, cross_1.resolveField)(this.options.modelMeta, this.model, key);\n                return !(fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.inheritedFrom);\n            });\n            return this.queryUtils.transaction(this.prisma, (tx) => this.doUpdateMany(tx, this.model, args, simpleUpdateMany));\n        });\n    }\n    upsert(args) {\n        const _super = Object.create(null, {\n            upsert: { get: () => super.upsert }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!args) {\n                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'query argument is required');\n            }\n            if (!args.where) {\n                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'where field is required in query argument');\n            }\n            if ((0, cross_1.isDelegateModel)(this.options.modelMeta, this.model)) {\n                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, `Model \"${this.model}\" is a delegate and doesn't support upsert`);\n            }\n            if (!this.involvesDelegateModel(this.model)) {\n                return _super.upsert.call(this, args);\n            }\n            args = (0, deepcopy_1.default)(args);\n            this.injectWhereHierarchy(this.model, args === null || args === void 0 ? void 0 : args.where);\n            this.injectSelectIncludeHierarchy(this.model, args);\n            if (args.create) {\n                this.doProcessCreatePayload(this.model, args.create);\n            }\n            if (args.update) {\n                this.doProcessUpdatePayload(this.model, args.update);\n            }\n            if (this.options.logPrismaQuery) {\n                this.logger.info(`[delegate] \\`upsert\\` ${this.getModelName(this.model)}: ${(0, utils_1.formatObject)(args)}`);\n            }\n            const result = yield this.prisma[this.model].upsert(args);\n            return this.assembleHierarchy(this.model, result);\n        });\n    }\n    doUpdate(db, model, args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            args = (0, deepcopy_1.default)(args);\n            yield this.injectUpdateHierarchy(db, model, args);\n            this.injectSelectIncludeHierarchy(model, args);\n            if (this.options.logPrismaQuery) {\n                this.logger.info(`[delegate] \\`update\\` ${this.getModelName(model)}: ${(0, utils_1.formatObject)(args)}`);\n            }\n            const result = yield db[model].update(args);\n            return this.assembleHierarchy(model, result);\n        });\n    }\n    doUpdateMany(db, model, args, simpleUpdateMany) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (simpleUpdateMany) {\n                // do a direct `updateMany`\n                args = (0, deepcopy_1.default)(args);\n                yield this.injectUpdateHierarchy(db, model, args);\n                if (this.options.logPrismaQuery) {\n                    this.logger.info(`[delegate] \\`updateMany\\` ${this.getModelName(model)}: ${(0, utils_1.formatObject)(args)}`);\n                }\n                return db[model].updateMany(args);\n            }\n            else {\n                // translate to plain `update` for nested write into base fields\n                const findArgs = {\n                    where: (0, deepcopy_1.default)(args.where),\n                    select: this.queryUtils.makeIdSelection(model),\n                };\n                yield this.injectUpdateHierarchy(db, model, findArgs);\n                if (this.options.logPrismaQuery) {\n                    this.logger.info(`[delegate] \\`updateMany\\` find candidates: ${this.getModelName(model)}: ${(0, utils_1.formatObject)(findArgs)}`);\n                }\n                const entities = yield db[model].findMany(findArgs);\n                const updatePayload = { data: (0, deepcopy_1.default)(args.data), select: this.queryUtils.makeIdSelection(model) };\n                yield this.injectUpdateHierarchy(db, model, updatePayload);\n                const result = yield Promise.all(entities.map((entity) => {\n                    const updateArgs = Object.assign({ where: entity }, updatePayload);\n                    if (this.options.logPrismaQuery) {\n                        this.logger.info(`[delegate] \\`updateMany\\` update: ${this.getModelName(model)}: ${(0, utils_1.formatObject)(updateArgs)}`);\n                    }\n                    return db[model].update(updateArgs);\n                }));\n                return { count: result.length };\n            }\n        });\n    }\n    injectUpdateHierarchy(db, model, args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const visitor = new cross_1.NestedWriteVisitor(this.options.modelMeta, {\n                update: (model, args, _context) => {\n                    this.injectWhereHierarchy(model, args === null || args === void 0 ? void 0 : args.where);\n                    this.doProcessUpdatePayload(model, args === null || args === void 0 ? void 0 : args.data);\n                },\n                updateMany: (model, args, context) => __awaiter(this, void 0, void 0, function* () {\n                    let simpleUpdateMany = Object.keys(args.data).every((key) => {\n                        // check if the `data` clause involves base fields\n                        const fieldInfo = (0, cross_1.resolveField)(this.options.modelMeta, model, key);\n                        return !(fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.inheritedFrom);\n                    });\n                    if (simpleUpdateMany) {\n                        // check if the `where` clause involves base fields\n                        simpleUpdateMany = Object.keys(args.where || {}).every((key) => {\n                            const fieldInfo = (0, cross_1.resolveField)(this.options.modelMeta, model, key);\n                            return !(fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.inheritedFrom);\n                        });\n                    }\n                    if (simpleUpdateMany) {\n                        this.injectWhereHierarchy(model, args === null || args === void 0 ? void 0 : args.where);\n                        this.doProcessUpdatePayload(model, args === null || args === void 0 ? void 0 : args.data);\n                    }\n                    else {\n                        const where = this.queryUtils.buildReversedQuery(context, false, false);\n                        yield this.queryUtils.transaction(db, (tx) => __awaiter(this, void 0, void 0, function* () {\n                            yield this.doUpdateMany(tx, model, Object.assign(Object.assign({}, args), { where }), simpleUpdateMany);\n                        }));\n                        delete context.parent['updateMany'];\n                    }\n                }),\n                upsert: (model, args, _context) => {\n                    this.injectWhereHierarchy(model, args === null || args === void 0 ? void 0 : args.where);\n                    if (args.create) {\n                        this.doProcessCreatePayload(model, args === null || args === void 0 ? void 0 : args.create);\n                    }\n                    if (args.update) {\n                        this.doProcessUpdatePayload(model, args === null || args === void 0 ? void 0 : args.update);\n                    }\n                },\n                create: (model, args, _context) => {\n                    if ((0, cross_1.isDelegateModel)(this.options.modelMeta, model)) {\n                        throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, `Model \"${model}\" is a delegate and cannot be created directly`);\n                    }\n                    this.doProcessCreatePayload(model, args);\n                },\n                createMany: (model, args, _context) => {\n                    if (args.skipDuplicates) {\n                        throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, '`createMany` with `skipDuplicates` set to true is not supported for delegated models');\n                    }\n                    for (const item of (0, cross_1.enumerate)(args === null || args === void 0 ? void 0 : args.data)) {\n                        this.doProcessCreatePayload(model, item);\n                    }\n                },\n                connect: (model, args, _context) => {\n                    this.injectWhereHierarchy(model, args);\n                },\n                connectOrCreate: (model, args, _context) => {\n                    this.injectWhereHierarchy(model, args.where);\n                    if (args.create) {\n                        this.doProcessCreatePayload(model, args.create);\n                    }\n                },\n                disconnect: (model, args, _context) => {\n                    this.injectWhereHierarchy(model, args);\n                },\n                set: (model, args, _context) => {\n                    this.injectWhereHierarchy(model, args);\n                },\n                delete: (model, _args, context) => __awaiter(this, void 0, void 0, function* () {\n                    const where = this.queryUtils.buildReversedQuery(context, false, false);\n                    yield this.queryUtils.transaction(db, (tx) => __awaiter(this, void 0, void 0, function* () {\n                        yield this.doDelete(tx, model, { where });\n                    }));\n                    delete context.parent['delete'];\n                }),\n                deleteMany: (model, _args, context) => __awaiter(this, void 0, void 0, function* () {\n                    const where = this.queryUtils.buildReversedQuery(context, false, false);\n                    yield this.queryUtils.transaction(db, (tx) => __awaiter(this, void 0, void 0, function* () {\n                        yield this.doDeleteMany(tx, model, where);\n                    }));\n                    delete context.parent['deleteMany'];\n                }),\n            });\n            yield visitor.visit(model, 'update', args);\n        });\n    }\n    doProcessUpdatePayload(model, data) {\n        if (!data) {\n            return;\n        }\n        for (const [field, value] of Object.entries(data)) {\n            const fieldInfo = (0, cross_1.resolveField)(this.options.modelMeta, model, field);\n            if (fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.inheritedFrom) {\n                this.injectBaseFieldData(model, fieldInfo, value, data, 'update');\n                delete data[field];\n            }\n        }\n    }\n    // #endregion\n    // #region delete\n    delete(args) {\n        if (!args) {\n            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'query argument is required');\n        }\n        if (!this.involvesDelegateModel(this.model)) {\n            return super.delete(args);\n        }\n        return this.queryUtils.transaction(this.prisma, (tx) => __awaiter(this, void 0, void 0, function* () {\n            const selectInclude = this.buildSelectIncludeHierarchy(this.model, args);\n            // make sure id fields are selected\n            const idFields = this.getIdFields(this.model);\n            for (const idField of idFields) {\n                if ((selectInclude === null || selectInclude === void 0 ? void 0 : selectInclude.select) && !(idField.name in selectInclude.select)) {\n                    selectInclude.select[idField.name] = true;\n                }\n            }\n            const deleteArgs = Object.assign(Object.assign({}, (0, deepcopy_1.default)(args)), selectInclude);\n            return this.doDelete(tx, this.model, deleteArgs);\n        }));\n    }\n    deleteMany(args) {\n        if (!this.involvesDelegateModel(this.model)) {\n            return super.deleteMany(args);\n        }\n        return this.queryUtils.transaction(this.prisma, (tx) => this.doDeleteMany(tx, this.model, args === null || args === void 0 ? void 0 : args.where));\n    }\n    doDeleteMany(db, model, where) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // query existing entities with id\n            const idSelection = this.queryUtils.makeIdSelection(model);\n            const findArgs = { where: (0, deepcopy_1.default)(where), select: idSelection };\n            this.injectWhereHierarchy(model, findArgs.where);\n            if (this.options.logPrismaQuery) {\n                this.logger.info(`[delegate] \\`deleteMany\\` find candidates: ${this.getModelName(model)}: ${(0, utils_1.formatObject)(findArgs)}`);\n            }\n            const entities = yield db[model].findMany(findArgs);\n            // recursively delete base entities (they all have the same id values)\n            yield Promise.all(entities.map((entity) => this.doDelete(db, model, { where: entity })));\n            return { count: entities.length };\n        });\n    }\n    deleteBaseRecursively(db, model, idValues) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let base = this.getBaseModel(model);\n            while (base) {\n                yield db[base.name].delete({ where: idValues });\n                base = this.getBaseModel(base.name);\n            }\n        });\n    }\n    doDelete(db, model, args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.injectWhereHierarchy(model, args.where);\n            if (this.options.logPrismaQuery) {\n                this.logger.info(`[delegate] \\`delete\\` ${this.getModelName(model)}: ${(0, utils_1.formatObject)(args)}`);\n            }\n            const result = yield db[model].delete(args);\n            const idValues = this.queryUtils.getEntityIds(model, result);\n            // recursively delete base entities (they all have the same id values)\n            yield this.deleteBaseRecursively(db, model, idValues);\n            return this.assembleHierarchy(model, result);\n        });\n    }\n    // #endregion\n    // #region aggregation\n    aggregate(args) {\n        if (!args) {\n            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'query argument is required');\n        }\n        if (!this.involvesDelegateModel(this.model)) {\n            return super.aggregate(args);\n        }\n        // check if any aggregation operator is using fields from base\n        this.checkAggregationArgs('aggregate', args);\n        args = (0, deepcopy_1.default)(args);\n        if (args.cursor) {\n            args.cursor = this.buildWhereHierarchy(this.model, args.cursor);\n        }\n        if (args.orderBy) {\n            args.orderBy = this.buildWhereHierarchy(this.model, args.orderBy);\n        }\n        if (args.where) {\n            args.where = this.buildWhereHierarchy(this.model, args.where);\n        }\n        if (this.options.logPrismaQuery) {\n            this.logger.info(`[delegate] \\`aggregate\\` ${this.getModelName(this.model)}: ${(0, utils_1.formatObject)(args)}`);\n        }\n        return super.aggregate(args);\n    }\n    count(args) {\n        if (!this.involvesDelegateModel(this.model)) {\n            return super.count(args);\n        }\n        // check if count select is using fields from base\n        this.checkAggregationArgs('count', args);\n        args = (0, deepcopy_1.default)(args);\n        if (args === null || args === void 0 ? void 0 : args.cursor) {\n            args.cursor = this.buildWhereHierarchy(this.model, args.cursor);\n        }\n        if (args === null || args === void 0 ? void 0 : args.where) {\n            args.where = this.buildWhereHierarchy(this.model, args.where);\n        }\n        if (this.options.logPrismaQuery) {\n            this.logger.info(`[delegate] \\`count\\` ${this.getModelName(this.model)}: ${(0, utils_1.formatObject)(args)}`);\n        }\n        return super.count(args);\n    }\n    groupBy(args) {\n        if (!args) {\n            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, 'query argument is required');\n        }\n        if (!this.involvesDelegateModel(this.model)) {\n            return super.groupBy(args);\n        }\n        // check if count select is using fields from base\n        this.checkAggregationArgs('groupBy', args);\n        if (args.by) {\n            for (const by of (0, cross_1.enumerate)(args.by)) {\n                const fieldInfo = (0, cross_1.resolveField)(this.options.modelMeta, this.model, by);\n                if (fieldInfo && fieldInfo.inheritedFrom) {\n                    throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, `groupBy with fields from base type is not supported yet: \"${by}\"`);\n                }\n            }\n        }\n        args = (0, deepcopy_1.default)(args);\n        if (args.where) {\n            args.where = this.buildWhereHierarchy(this.model, args.where);\n        }\n        if (this.options.logPrismaQuery) {\n            this.logger.info(`[delegate] \\`groupBy\\` ${this.getModelName(this.model)}: ${(0, utils_1.formatObject)(args)}`);\n        }\n        return super.groupBy(args);\n    }\n    checkAggregationArgs(operation, args) {\n        if (!args) {\n            return;\n        }\n        for (const op of ['_count', '_sum', '_avg', '_min', '_max', 'select', 'having']) {\n            if (args[op] && typeof args[op] === 'object') {\n                for (const field of Object.keys(args[op])) {\n                    const fieldInfo = (0, cross_1.resolveField)(this.options.modelMeta, this.model, field);\n                    if (fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.inheritedFrom) {\n                        throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, `${operation} with fields from base type is not supported yet: \"${field}\"`);\n                    }\n                }\n            }\n        }\n    }\n    // #endregion\n    // #region utils\n    extractSelectInclude(args) {\n        if (!args) {\n            return undefined;\n        }\n        args = (0, deepcopy_1.default)(args);\n        return 'select' in args\n            ? { select: args['select'] }\n            : 'include' in args\n                ? { include: args['include'] }\n                : undefined;\n    }\n    makeAuxRelationName(model) {\n        return `${constants_1.DELEGATE_AUX_RELATION_PREFIX}_${(0, lower_case_first_1.lowerCaseFirst)(model.name)}`;\n    }\n    getModelName(model) {\n        const info = (0, cross_1.getModelInfo)(this.options.modelMeta, model, true);\n        return info.name;\n    }\n    getIdFields(model) {\n        const idFields = (0, cross_1.getIdFields)(this.options.modelMeta, model);\n        if (idFields && idFields.length > 0) {\n            return idFields;\n        }\n        const base = this.getBaseModel(model);\n        return base ? this.getIdFields(base.name) : [];\n    }\n    getModelInfo(model) {\n        return (0, cross_1.getModelInfo)(this.options.modelMeta, model, true);\n    }\n    getBaseModel(model) {\n        const baseNames = (0, cross_1.getModelInfo)(this.options.modelMeta, model, true).baseTypes;\n        if (!baseNames) {\n            return undefined;\n        }\n        if (baseNames.length > 1) {\n            throw new Error('Multi-inheritance is not supported');\n        }\n        return this.options.modelMeta.models[(0, lower_case_first_1.lowerCaseFirst)(baseNames[0])];\n    }\n    involvesDelegateModel(model, visited) {\n        if (this.isDelegateOrDescendantOfDelegate(model)) {\n            return true;\n        }\n        visited = visited !== null && visited !== void 0 ? visited : new Set();\n        if (visited.has(model)) {\n            return false;\n        }\n        visited.add(model);\n        const modelInfo = (0, cross_1.getModelInfo)(this.options.modelMeta, model, true);\n        return Object.values(modelInfo.fields).some((field) => field.isDataModel && this.involvesDelegateModel(field.type, visited));\n    }\n    isDelegateOrDescendantOfDelegate(model) {\n        var _a;\n        if ((0, cross_1.isDelegateModel)(this.options.modelMeta, model)) {\n            return true;\n        }\n        const baseTypes = (_a = (0, cross_1.getModelInfo)(this.options.modelMeta, model)) === null || _a === void 0 ? void 0 : _a.baseTypes;\n        return !!(baseTypes &&\n            baseTypes.length > 0 &&\n            baseTypes.some((base) => this.isDelegateOrDescendantOfDelegate(base)));\n    }\n    assembleHierarchy(model, entity) {\n        if (!entity || typeof entity !== 'object') {\n            return entity;\n        }\n        const upMerged = this.assembleUp(model, entity);\n        const downMerged = this.assembleDown(model, entity);\n        // https://www.npmjs.com/package/deepmerge#arraymerge-example-combine-arrays\n        const combineMerge = (target, source, options) => {\n            const destination = target.slice();\n            source.forEach((item, index) => {\n                if (typeof destination[index] === 'undefined') {\n                    destination[index] = options.cloneUnlessOtherwiseSpecified(item, options);\n                }\n                else if (options.isMergeableObject(item)) {\n                    destination[index] = (0, deepmerge_1.default)(target[index], item, options);\n                }\n                else if (target.indexOf(item) === -1) {\n                    destination.push(item);\n                }\n            });\n            return destination;\n        };\n        const result = (0, deepmerge_1.default)(upMerged, downMerged, {\n            arrayMerge: combineMerge,\n            isMergeableObject: (v) => (0, is_plain_object_1.isPlainObject)(v) || Array.isArray(v), // avoid messing with Decimal, Date, etc.\n        });\n        return result;\n    }\n    assembleUp(model, entity) {\n        if (!entity) {\n            return entity;\n        }\n        const result = {};\n        const base = this.getBaseModel(model);\n        if (base) {\n            // merge base fields\n            const baseRelationName = this.makeAuxRelationName(base);\n            const baseData = entity[baseRelationName];\n            if (baseData && typeof baseData === 'object') {\n                const baseAssembled = this.assembleUp(base.name, baseData);\n                Object.assign(result, baseAssembled);\n            }\n        }\n        const modelInfo = (0, cross_1.getModelInfo)(this.options.modelMeta, model, true);\n        for (const [key, value] of Object.entries(entity)) {\n            if (key.startsWith(constants_1.DELEGATE_AUX_RELATION_PREFIX)) {\n                continue;\n            }\n            const field = modelInfo.fields[key];\n            if (!field) {\n                // not a field, could be `_count`, `_sum`, etc.\n                result[key] = value;\n                continue;\n            }\n            if (field.inheritedFrom) {\n                // already merged from base\n                continue;\n            }\n            if (field.isDataModel) {\n                if (Array.isArray(value)) {\n                    result[field.name] = value.map((item) => this.assembleUp(field.type, item));\n                }\n                else {\n                    result[field.name] = this.assembleUp(field.type, value);\n                }\n            }\n            else {\n                result[field.name] = value;\n            }\n        }\n        return result;\n    }\n    assembleDown(model, entity) {\n        if (!entity) {\n            return entity;\n        }\n        const result = {};\n        const modelInfo = (0, cross_1.getModelInfo)(this.options.modelMeta, model, true);\n        if (modelInfo.discriminator) {\n            // model is a delegate, merge sub model fields\n            const subModelName = entity[modelInfo.discriminator];\n            if (subModelName) {\n                const subModel = (0, cross_1.getModelInfo)(this.options.modelMeta, subModelName, true);\n                const subRelationName = this.makeAuxRelationName(subModel);\n                const subData = entity[subRelationName];\n                if (subData && typeof subData === 'object') {\n                    const subAssembled = this.assembleDown(subModel.name, subData);\n                    Object.assign(result, subAssembled);\n                }\n            }\n        }\n        for (const [key, value] of Object.entries(entity)) {\n            if (key.startsWith(constants_1.DELEGATE_AUX_RELATION_PREFIX)) {\n                continue;\n            }\n            const field = modelInfo.fields[key];\n            if (!field) {\n                // not a field, could be `_count`, `_sum`, etc.\n                result[key] = value;\n                continue;\n            }\n            if (field.isDataModel) {\n                if (Array.isArray(value)) {\n                    result[field.name] = value.map((item) => this.assembleDown(field.type, item));\n                }\n                else {\n                    result[field.name] = this.assembleDown(field.type, value);\n                }\n            }\n            else {\n                result[field.name] = value;\n            }\n        }\n        return result;\n    }\n}\nexports.DelegateProxyHandler = DelegateProxyHandler;\n//# sourceMappingURL=delegate.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHplbnN0YWNraHErcnVudGltZUAyLjIuNF9AcHJpc21hK2NsaWVudEA1LjE3LjBfcHJpc21hQDUuMTcuMF8vbm9kZV9tb2R1bGVzL0B6ZW5zdGFja2hxL3J1bnRpbWUvZW5oYW5jZW1lbnRzL2RlbGVnYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLG9CQUFvQjtBQUNuRDtBQUNBLG1DQUFtQyxtQkFBTyxDQUFDLDJGQUFVO0FBQ3JELG9DQUFvQyxtQkFBTyxDQUFDLGdHQUFXO0FBQ3ZELDBCQUEwQixtQkFBTyxDQUFDLDhIQUFpQjtBQUNuRCwyQkFBMkIsbUJBQU8sQ0FBQyw4SEFBa0I7QUFDckQsb0JBQW9CLG1CQUFPLENBQUMsNkpBQWM7QUFDMUMsZ0JBQWdCLG1CQUFPLENBQUMsMkpBQVU7QUFDbEMsaUJBQWlCLG1CQUFPLENBQUMsbUtBQVU7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsaUtBQVM7QUFDakMsc0JBQXNCLG1CQUFPLENBQUMsNktBQWU7QUFDN0MsZ0JBQWdCLG1CQUFPLENBQUMsaUtBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPLEtBQUsseUJBQXlCLElBQUksZ0NBQWdDO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsd0JBQXdCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx3QkFBd0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLFFBQVEsNkZBQTZGO0FBQzVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHVCQUF1QjtBQUMvRTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsdUJBQXVCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSEFBaUgsV0FBVztBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsWUFBWTtBQUNuRSxhQUFhO0FBQ2I7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHlCQUF5QixJQUFJLGdDQUFnQztBQUN2SDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0hBQWtILGVBQWU7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSEFBaUgsV0FBVztBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELDhCQUE4QixJQUFJLGdDQUFnQztBQUM1SDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQseUJBQXlCLElBQUksZ0NBQWdDO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLHlCQUF5QixJQUFJLGdDQUFnQztBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLHlCQUF5QixJQUFJLG9DQUFvQztBQUNwSjtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSx1REFBdUQsZUFBZTtBQUN0RTtBQUNBLDhFQUE4RSx5QkFBeUIsSUFBSSxzQ0FBc0M7QUFDako7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQix5QkFBeUI7QUFDekI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixXQUFXLE9BQU87QUFDL0cseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EseUhBQXlILE1BQU07QUFDL0g7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxPQUFPO0FBQ2hFLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsK0VBQStFLHlCQUF5QixJQUFJLG9DQUFvQztBQUNoSjtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsZUFBZTtBQUNqRyxxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaUJBQWlCO0FBQzlEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCx5QkFBeUIsSUFBSSxnQ0FBZ0M7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsOEJBQThCLElBQUksZ0NBQWdDO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsOEJBQThCLElBQUksZ0NBQWdDO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0tBQXdLLEdBQUc7QUFDM0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCw4QkFBOEIsSUFBSSxnQ0FBZ0M7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0hBQWtILFdBQVcsb0RBQW9ELE1BQU07QUFDdkw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlDQUF5QyxHQUFHLG1EQUFtRDtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXJibGlzbS9uZXh0LWpzLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B6ZW5zdGFja2hxK3J1bnRpbWVAMi4yLjRfQHByaXNtYStjbGllbnRANS4xNy4wX3ByaXNtYUA1LjE3LjBfL25vZGVfbW9kdWxlcy9AemVuc3RhY2tocS9ydW50aW1lL2VuaGFuY2VtZW50cy9kZWxlZ2F0ZS5qcz85MWNkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRlbGVnYXRlUHJveHlIYW5kbGVyID0gZXhwb3J0cy53aXRoRGVsZWdhdGUgPSB2b2lkIDA7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5jb25zdCBkZWVwY29weV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWVwY29weVwiKSk7XG5jb25zdCBkZWVwbWVyZ2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVlcG1lcmdlXCIpKTtcbmNvbnN0IGlzX3BsYWluX29iamVjdF8xID0gcmVxdWlyZShcImlzLXBsYWluLW9iamVjdFwiKTtcbmNvbnN0IGxvd2VyX2Nhc2VfZmlyc3RfMSA9IHJlcXVpcmUoXCJsb3dlci1jYXNlLWZpcnN0XCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xuY29uc3QgY3Jvc3NfMSA9IHJlcXVpcmUoXCIuLi9jcm9zc1wiKTtcbmNvbnN0IGxvZ2dlcl8xID0gcmVxdWlyZShcIi4vbG9nZ2VyXCIpO1xuY29uc3QgcHJveHlfMSA9IHJlcXVpcmUoXCIuL3Byb3h5XCIpO1xuY29uc3QgcXVlcnlfdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3F1ZXJ5LXV0aWxzXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuZnVuY3Rpb24gd2l0aERlbGVnYXRlKHByaXNtYSwgb3B0aW9ucykge1xuICAgIHJldHVybiAoMCwgcHJveHlfMS5tYWtlUHJveHkpKHByaXNtYSwgb3B0aW9ucy5tb2RlbE1ldGEsIChfcHJpc21hLCBtb2RlbCkgPT4gbmV3IERlbGVnYXRlUHJveHlIYW5kbGVyKF9wcmlzbWEsIG1vZGVsLCBvcHRpb25zKSwgJ2RlbGVnYXRlJyk7XG59XG5leHBvcnRzLndpdGhEZWxlZ2F0ZSA9IHdpdGhEZWxlZ2F0ZTtcbmNsYXNzIERlbGVnYXRlUHJveHlIYW5kbGVyIGV4dGVuZHMgcHJveHlfMS5EZWZhdWx0UHJpc21hUHJveHlIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihwcmlzbWEsIG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKHByaXNtYSwgbW9kZWwsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IG5ldyBsb2dnZXJfMS5Mb2dnZXIocHJpc21hKTtcbiAgICAgICAgdGhpcy5xdWVyeVV0aWxzID0gbmV3IHF1ZXJ5X3V0aWxzXzEuUXVlcnlVdGlscyhwcmlzbWEsIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICAgIC8vICNyZWdpb24gZmluZFxuICAgIGZpbmRGaXJzdChhcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvRmluZCh0aGlzLnByaXNtYSwgdGhpcy5tb2RlbCwgJ2ZpbmRGaXJzdCcsIGFyZ3MpO1xuICAgIH1cbiAgICBmaW5kRmlyc3RPclRocm93KGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9GaW5kKHRoaXMucHJpc21hLCB0aGlzLm1vZGVsLCAnZmluZEZpcnN0T3JUaHJvdycsIGFyZ3MpO1xuICAgIH1cbiAgICBmaW5kVW5pcXVlKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9GaW5kKHRoaXMucHJpc21hLCB0aGlzLm1vZGVsLCAnZmluZFVuaXF1ZScsIGFyZ3MpO1xuICAgIH1cbiAgICBmaW5kVW5pcXVlT3JUaHJvdyhhcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvRmluZCh0aGlzLnByaXNtYSwgdGhpcy5tb2RlbCwgJ2ZpbmRVbmlxdWVPclRocm93JywgYXJncyk7XG4gICAgfVxuICAgIGZpbmRNYW55KGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvRmluZCh0aGlzLnByaXNtYSwgdGhpcy5tb2RlbCwgJ2ZpbmRNYW55JywgYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkb0ZpbmQoZGIsIG1vZGVsLCBtZXRob2QsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgX3N1cGVySW5kZXggPSBuYW1lID0+IHN1cGVyW25hbWVdO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmludm9sdmVzRGVsZWdhdGVNb2RlbChtb2RlbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVySW5kZXgobWV0aG9kKS5jYWxsKHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJncyA9IGFyZ3MgPyAoMCwgZGVlcGNvcHlfMS5kZWZhdWx0KShhcmdzKSA6IHt9O1xuICAgICAgICAgICAgdGhpcy5pbmplY3RXaGVyZUhpZXJhcmNoeShtb2RlbCwgYXJncyA9PT0gbnVsbCB8fCBhcmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcmdzLndoZXJlKTtcbiAgICAgICAgICAgIHRoaXMuaW5qZWN0U2VsZWN0SW5jbHVkZUhpZXJhcmNoeShtb2RlbCwgYXJncyk7XG4gICAgICAgICAgICBpZiAoYXJncy5vcmRlckJ5KSB7XG4gICAgICAgICAgICAgICAgLy8gYG9yZGVyQnlgIG1heSBjb250YWluIGZpZWxkcyBmcm9tIGJhc2UgdHlwZXNcbiAgICAgICAgICAgICAgICBhcmdzLm9yZGVyQnkgPSB0aGlzLmJ1aWxkV2hlcmVIaWVyYXJjaHkodGhpcy5tb2RlbCwgYXJncy5vcmRlckJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9nUHJpc21hUXVlcnkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKGBbZGVsZWdhdGVdIFxcYCR7bWV0aG9kfVxcYCAke3RoaXMuZ2V0TW9kZWxOYW1lKG1vZGVsKX06ICR7KDAsIHV0aWxzXzEuZm9ybWF0T2JqZWN0KShhcmdzKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVudGl0eSA9IHlpZWxkIGRiW21vZGVsXVttZXRob2RdKGFyZ3MpO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZW50aXR5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbnRpdHkubWFwKChpdGVtKSA9PiB0aGlzLmFzc2VtYmxlSGllcmFyY2h5KG1vZGVsLCBpdGVtKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hc3NlbWJsZUhpZXJhcmNoeShtb2RlbCwgZW50aXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGluamVjdFdoZXJlSGllcmFyY2h5KG1vZGVsLCB3aGVyZSkge1xuICAgICAgICBpZiAoIXdoZXJlIHx8IHR5cGVvZiB3aGVyZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZW50cmllcyh3aGVyZSkuZm9yRWFjaCgoW2ZpZWxkLCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmIChbJ0FORCcsICdPUicsICdOT1QnXS5pbmNsdWRlcyhmaWVsZCkpIHtcbiAgICAgICAgICAgICAgICAvLyByZWN1cnNlIGludG8gbG9naWNhbCBncm91cFxuICAgICAgICAgICAgICAgICgwLCBjcm9zc18xLmVudW1lcmF0ZSkodmFsdWUpLmZvckVhY2goKGl0ZW0pID0+IHRoaXMuaW5qZWN0V2hlcmVIaWVyYXJjaHkobW9kZWwsIGl0ZW0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaWVsZEluZm8gPSAoMCwgY3Jvc3NfMS5yZXNvbHZlRmllbGQpKHRoaXMub3B0aW9ucy5tb2RlbE1ldGEsIG1vZGVsLCBmaWVsZCk7XG4gICAgICAgICAgICBpZiAoIShmaWVsZEluZm8gPT09IG51bGwgfHwgZmllbGRJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWVsZEluZm8uaW5oZXJpdGVkRnJvbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHRoaXMuZ2V0QmFzZU1vZGVsKG1vZGVsKTtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB3aGVyZTtcbiAgICAgICAgICAgIHdoaWxlIChiYXNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZVJlbGF0aW9uTmFtZSA9IHRoaXMubWFrZUF1eFJlbGF0aW9uTmFtZShiYXNlKTtcbiAgICAgICAgICAgICAgICAvLyBwcmVwYXJlIGJhc2UgbGF5ZXIgd2hlcmVcbiAgICAgICAgICAgICAgICBsZXQgdGhpc0xheWVyO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRbYmFzZVJlbGF0aW9uTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc0xheWVyID0gdGFyZ2V0W2Jhc2VSZWxhdGlvbk5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc0xheWVyID0gdGFyZ2V0W2Jhc2VSZWxhdGlvbk5hbWVdID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChiYXNlLm5hbWUgPT09IGZpZWxkSW5mby5pbmhlcml0ZWRGcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNMYXllcltmaWVsZF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHdoZXJlW2ZpZWxkXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSB0aGlzTGF5ZXI7XG4gICAgICAgICAgICAgICAgICAgIGJhc2UgPSB0aGlzLmdldEJhc2VNb2RlbChiYXNlLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJ1aWxkV2hlcmVIaWVyYXJjaHkobW9kZWwsIHdoZXJlKSB7XG4gICAgICAgIGlmICghd2hlcmUpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgd2hlcmUgPSAoMCwgZGVlcGNvcHlfMS5kZWZhdWx0KSh3aGVyZSk7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHdoZXJlKS5mb3JFYWNoKChbZmllbGQsIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmllbGRJbmZvID0gKDAsIGNyb3NzXzEucmVzb2x2ZUZpZWxkKSh0aGlzLm9wdGlvbnMubW9kZWxNZXRhLCBtb2RlbCwgZmllbGQpO1xuICAgICAgICAgICAgaWYgKCEoZmllbGRJbmZvID09PSBudWxsIHx8IGZpZWxkSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmllbGRJbmZvLmluaGVyaXRlZEZyb20pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGJhc2UgPSB0aGlzLmdldEJhc2VNb2RlbChtb2RlbCk7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gd2hlcmU7XG4gICAgICAgICAgICB3aGlsZSAoYmFzZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VSZWxhdGlvbk5hbWUgPSB0aGlzLm1ha2VBdXhSZWxhdGlvbk5hbWUoYmFzZSk7XG4gICAgICAgICAgICAgICAgLy8gcHJlcGFyZSBiYXNlIGxheWVyIHdoZXJlXG4gICAgICAgICAgICAgICAgbGV0IHRoaXNMYXllcjtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0W2Jhc2VSZWxhdGlvbk5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNMYXllciA9IHRhcmdldFtiYXNlUmVsYXRpb25OYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNMYXllciA9IHRhcmdldFtiYXNlUmVsYXRpb25OYW1lXSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmFzZS5uYW1lID09PSBmaWVsZEluZm8uaW5oZXJpdGVkRnJvbSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzTGF5ZXJbZmllbGRdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB3aGVyZVtmaWVsZF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGhpc0xheWVyO1xuICAgICAgICAgICAgICAgICAgICBiYXNlID0gdGhpcy5nZXRCYXNlTW9kZWwoYmFzZS5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gd2hlcmU7XG4gICAgfVxuICAgIGluamVjdFNlbGVjdEluY2x1ZGVIaWVyYXJjaHkobW9kZWwsIGFyZ3MpIHtcbiAgICAgICAgaWYgKCFhcmdzIHx8IHR5cGVvZiBhcmdzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2luZCBvZiBbJ3NlbGVjdCcsICdpbmNsdWRlJ10pIHtcbiAgICAgICAgICAgIGlmIChhcmdzW2tpbmRdICYmIHR5cGVvZiBhcmdzW2tpbmRdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2ZpZWxkLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYXJnc1traW5kXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGRJbmZvID0gKDAsIGNyb3NzXzEucmVzb2x2ZUZpZWxkKSh0aGlzLm9wdGlvbnMubW9kZWxNZXRhLCBtb2RlbCwgZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRJbmZvICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUub3JkZXJCeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBvcmRlckJ5YCBtYXkgY29udGFpbiBmaWVsZHMgZnJvbSBiYXNlIHR5cGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUub3JkZXJCeSA9IHRoaXMuYnVpbGRXaGVyZUhpZXJhcmNoeShmaWVsZEluZm8udHlwZSwgdmFsdWUub3JkZXJCeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmplY3RCYXNlRmllbGRTZWxlY3QobW9kZWwsIGZpZWxkLCB2YWx1ZSwgYXJncywga2luZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXJnc1traW5kXVtmaWVsZF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWVsZEluZm8uaXNEYXRhTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRWYWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIHBheWxvYWQgaXMgYW4gb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3Nba2luZF1bZmllbGRdID0gbmV4dFZhbHVlID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5qZWN0U2VsZWN0SW5jbHVkZUhpZXJhcmNoeShmaWVsZEluZm8udHlwZSwgbmV4dFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFyZ3Muc2VsZWN0KSB7XG4gICAgICAgICAgICAvLyBpbmNsdWRlIGJhc2UgbW9kZWxzIHVwd2FyZHNcbiAgICAgICAgICAgIHRoaXMuaW5qZWN0QmFzZUluY2x1ZGVSZWN1cnNpdmVseShtb2RlbCwgYXJncyk7XG4gICAgICAgICAgICAvLyBpbmNsdWRlIHN1YiBtb2RlbHMgZG93bndhcmRzXG4gICAgICAgICAgICB0aGlzLmluamVjdENvbmNyZXRlSW5jbHVkZVJlY3Vyc2l2ZWx5KG1vZGVsLCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBidWlsZFNlbGVjdEluY2x1ZGVIaWVyYXJjaHkobW9kZWwsIGFyZ3MpIHtcbiAgICAgICAgYXJncyA9ICgwLCBkZWVwY29weV8xLmRlZmF1bHQpKGFyZ3MpO1xuICAgICAgICBjb25zdCBzZWxlY3RJbmNsdWRlID0gdGhpcy5leHRyYWN0U2VsZWN0SW5jbHVkZShhcmdzKSB8fCB7fTtcbiAgICAgICAgaWYgKHNlbGVjdEluY2x1ZGUuc2VsZWN0ICYmIHR5cGVvZiBzZWxlY3RJbmNsdWRlLnNlbGVjdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHNlbGVjdEluY2x1ZGUuc2VsZWN0KS5mb3JFYWNoKChbZmllbGQsIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmplY3RCYXNlRmllbGRTZWxlY3QobW9kZWwsIGZpZWxkLCB2YWx1ZSwgc2VsZWN0SW5jbHVkZSwgJ3NlbGVjdCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2VsZWN0SW5jbHVkZS5zZWxlY3RbZmllbGRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VsZWN0SW5jbHVkZS5pbmNsdWRlICYmIHR5cGVvZiBzZWxlY3RJbmNsdWRlLmluY2x1ZGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhzZWxlY3RJbmNsdWRlLmluY2x1ZGUpLmZvckVhY2goKFtmaWVsZCwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmluamVjdEJhc2VGaWVsZFNlbGVjdChtb2RlbCwgZmllbGQsIHZhbHVlLCBzZWxlY3RJbmNsdWRlLCAnaW5jbHVkZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2VsZWN0SW5jbHVkZS5pbmNsdWRlW2ZpZWxkXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2VsZWN0SW5jbHVkZS5zZWxlY3QpIHtcbiAgICAgICAgICAgIHRoaXMuaW5qZWN0QmFzZUluY2x1ZGVSZWN1cnNpdmVseShtb2RlbCwgc2VsZWN0SW5jbHVkZSk7XG4gICAgICAgICAgICB0aGlzLmluamVjdENvbmNyZXRlSW5jbHVkZVJlY3Vyc2l2ZWx5KG1vZGVsLCBzZWxlY3RJbmNsdWRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZWN0SW5jbHVkZTtcbiAgICB9XG4gICAgaW5qZWN0QmFzZUZpZWxkU2VsZWN0KG1vZGVsLCBmaWVsZCwgdmFsdWUsIHNlbGVjdEluY2x1ZGUsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgZmllbGRJbmZvID0gKDAsIGNyb3NzXzEucmVzb2x2ZUZpZWxkKSh0aGlzLm9wdGlvbnMubW9kZWxNZXRhLCBtb2RlbCwgZmllbGQpO1xuICAgICAgICBpZiAoIShmaWVsZEluZm8gPT09IG51bGwgfHwgZmllbGRJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWVsZEluZm8uaW5oZXJpdGVkRnJvbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYmFzZSA9IHRoaXMuZ2V0QmFzZU1vZGVsKG1vZGVsKTtcbiAgICAgICAgbGV0IHRhcmdldCA9IHNlbGVjdEluY2x1ZGU7XG4gICAgICAgIHdoaWxlIChiYXNlKSB7XG4gICAgICAgICAgICBjb25zdCBiYXNlUmVsYXRpb25OYW1lID0gdGhpcy5tYWtlQXV4UmVsYXRpb25OYW1lKGJhc2UpO1xuICAgICAgICAgICAgLy8gcHJlcGFyZSBiYXNlIGxheWVyIHNlbGVjdC9pbmNsdWRlXG4gICAgICAgICAgICAvLyBsZXQgc2VsZWN0T3JJbmNsdWRlID0gJ3NlbGVjdCc7XG4gICAgICAgICAgICBsZXQgdGhpc0xheWVyO1xuICAgICAgICAgICAgaWYgKHRhcmdldC5pbmNsdWRlKSB7XG4gICAgICAgICAgICAgICAgLy8gc2VsZWN0T3JJbmNsdWRlID0gJ2luY2x1ZGUnO1xuICAgICAgICAgICAgICAgIHRoaXNMYXllciA9IHRhcmdldC5pbmNsdWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0LnNlbGVjdCkge1xuICAgICAgICAgICAgICAgIC8vIHNlbGVjdE9ySW5jbHVkZSA9ICdzZWxlY3QnO1xuICAgICAgICAgICAgICAgIHRoaXNMYXllciA9IHRhcmdldC5zZWxlY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzZWxlY3RJbmNsdWRlID0gJ2luY2x1ZGUnO1xuICAgICAgICAgICAgICAgIHRoaXNMYXllciA9IHRhcmdldC5zZWxlY3QgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiYXNlLm5hbWUgPT09IGZpZWxkSW5mby5pbmhlcml0ZWRGcm9tKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzTGF5ZXJbYmFzZVJlbGF0aW9uTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc0xheWVyW2Jhc2VSZWxhdGlvbk5hbWVdID0geyBbY29udGV4dF06IHt9IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXNMYXllcltiYXNlUmVsYXRpb25OYW1lXVtjb250ZXh0XVtmaWVsZF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghdGhpc0xheWVyW2Jhc2VSZWxhdGlvbk5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNMYXllcltiYXNlUmVsYXRpb25OYW1lXSA9IHsgc2VsZWN0OiB7fSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB0aGlzTGF5ZXJbYmFzZVJlbGF0aW9uTmFtZV07XG4gICAgICAgICAgICAgICAgYmFzZSA9IHRoaXMuZ2V0QmFzZU1vZGVsKGJhc2UubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGluamVjdEJhc2VJbmNsdWRlUmVjdXJzaXZlbHkobW9kZWwsIHNlbGVjdEluY2x1ZGUpIHtcbiAgICAgICAgY29uc3QgYmFzZSA9IHRoaXMuZ2V0QmFzZU1vZGVsKG1vZGVsKTtcbiAgICAgICAgaWYgKCFiYXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmFzZVJlbGF0aW9uTmFtZSA9IHRoaXMubWFrZUF1eFJlbGF0aW9uTmFtZShiYXNlKTtcbiAgICAgICAgaWYgKHNlbGVjdEluY2x1ZGUuc2VsZWN0KSB7XG4gICAgICAgICAgICBzZWxlY3RJbmNsdWRlLmluY2x1ZGUgPSBPYmplY3QuYXNzaWduKHsgW2Jhc2VSZWxhdGlvbk5hbWVdOiB7fSB9LCBzZWxlY3RJbmNsdWRlLnNlbGVjdCk7XG4gICAgICAgICAgICBkZWxldGUgc2VsZWN0SW5jbHVkZS5zZWxlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWxlY3RJbmNsdWRlLmluY2x1ZGUgPSBPYmplY3QuYXNzaWduKHsgW2Jhc2VSZWxhdGlvbk5hbWVdOiB7fSB9LCBzZWxlY3RJbmNsdWRlLmluY2x1ZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5qZWN0QmFzZUluY2x1ZGVSZWN1cnNpdmVseShiYXNlLm5hbWUsIHNlbGVjdEluY2x1ZGUuaW5jbHVkZVtiYXNlUmVsYXRpb25OYW1lXSk7XG4gICAgfVxuICAgIGluamVjdENvbmNyZXRlSW5jbHVkZVJlY3Vyc2l2ZWx5KG1vZGVsLCBzZWxlY3RJbmNsdWRlKSB7XG4gICAgICAgIGNvbnN0IG1vZGVsSW5mbyA9ICgwLCBjcm9zc18xLmdldE1vZGVsSW5mbykodGhpcy5vcHRpb25zLm1vZGVsTWV0YSwgbW9kZWwpO1xuICAgICAgICBpZiAoIW1vZGVsSW5mbykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCBzdWIgbW9kZWxzIG9mIHRoaXMgbW9kZWxcbiAgICAgICAgY29uc3Qgc3ViTW9kZWxzID0gT2JqZWN0LnZhbHVlcyh0aGlzLm9wdGlvbnMubW9kZWxNZXRhLm1vZGVscykuZmlsdGVyKChtKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IG0uYmFzZVR5cGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5jbHVkZXMobW9kZWxJbmZvLm5hbWUpOyB9KTtcbiAgICAgICAgZm9yIChjb25zdCBzdWJNb2RlbCBvZiBzdWJNb2RlbHMpIHtcbiAgICAgICAgICAgIC8vIGluY2x1ZGUgc3ViIG1vZGVsIHJlbGF0aW9uIGZpZWxkXG4gICAgICAgICAgICBjb25zdCBzdWJSZWxhdGlvbk5hbWUgPSB0aGlzLm1ha2VBdXhSZWxhdGlvbk5hbWUoc3ViTW9kZWwpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdEluY2x1ZGUuc2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0SW5jbHVkZS5pbmNsdWRlID0gT2JqZWN0LmFzc2lnbih7IFtzdWJSZWxhdGlvbk5hbWVdOiB7fSB9LCBzZWxlY3RJbmNsdWRlLnNlbGVjdCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNlbGVjdEluY2x1ZGUuc2VsZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0SW5jbHVkZS5pbmNsdWRlID0gT2JqZWN0LmFzc2lnbih7IFtzdWJSZWxhdGlvbk5hbWVdOiB7fSB9LCBzZWxlY3RJbmNsdWRlLmluY2x1ZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbmplY3RDb25jcmV0ZUluY2x1ZGVSZWN1cnNpdmVseShzdWJNb2RlbC5uYW1lLCBzZWxlY3RJbmNsdWRlLmluY2x1ZGVbc3ViUmVsYXRpb25OYW1lXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gI2VuZHJlZ2lvblxuICAgIC8vICNyZWdpb24gY3JlYXRlXG4gICAgY3JlYXRlKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICAgICAgICBjcmVhdGU6IHsgZ2V0OiAoKSA9PiBzdXBlci5jcmVhdGUgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghYXJncykge1xuICAgICAgICAgICAgICAgIHRocm93ICgwLCB1dGlsc18xLnByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvcikodGhpcy5wcmlzbWEsIHRoaXMub3B0aW9ucy5wcmlzbWFNb2R1bGUsICdxdWVyeSBhcmd1bWVudCBpcyByZXF1aXJlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhcmdzLmRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAoMCwgdXRpbHNfMS5wcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IpKHRoaXMucHJpc21hLCB0aGlzLm9wdGlvbnMucHJpc21hTW9kdWxlLCAnZGF0YSBmaWVsZCBpcyByZXF1aXJlZCBpbiBxdWVyeSBhcmd1bWVudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCgwLCBjcm9zc18xLmlzRGVsZWdhdGVNb2RlbCkodGhpcy5vcHRpb25zLm1vZGVsTWV0YSwgdGhpcy5tb2RlbCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAoMCwgdXRpbHNfMS5wcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IpKHRoaXMucHJpc21hLCB0aGlzLm9wdGlvbnMucHJpc21hTW9kdWxlLCBgTW9kZWwgXCIke3RoaXMubW9kZWx9XCIgaXMgYSBkZWxlZ2F0ZSBhbmQgY2Fubm90IGJlIGNyZWF0ZWQgZGlyZWN0bHlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5pbnZvbHZlc0RlbGVnYXRlTW9kZWwodGhpcy5tb2RlbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLmNyZWF0ZS5jYWxsKHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9DcmVhdGUodGhpcy5wcmlzbWEsIHRoaXMubW9kZWwsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlTWFueShhcmdzKSB7XG4gICAgICAgIGlmICghYXJncykge1xuICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxzXzEucHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yKSh0aGlzLnByaXNtYSwgdGhpcy5vcHRpb25zLnByaXNtYU1vZHVsZSwgJ3F1ZXJ5IGFyZ3VtZW50IGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhcmdzLmRhdGEpIHtcbiAgICAgICAgICAgIHRocm93ICgwLCB1dGlsc18xLnByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvcikodGhpcy5wcmlzbWEsIHRoaXMub3B0aW9ucy5wcmlzbWFNb2R1bGUsICdkYXRhIGZpZWxkIGlzIHJlcXVpcmVkIGluIHF1ZXJ5IGFyZ3VtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmludm9sdmVzRGVsZWdhdGVNb2RlbCh0aGlzLm1vZGVsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmNyZWF0ZU1hbnkoYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNEZWxlZ2F0ZU9yRGVzY2VuZGFudE9mRGVsZWdhdGUodGhpcy5tb2RlbCkgJiYgYXJncy5za2lwRHVwbGljYXRlcykge1xuICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxzXzEucHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yKSh0aGlzLnByaXNtYSwgdGhpcy5vcHRpb25zLnByaXNtYU1vZHVsZSwgJ2BjcmVhdGVNYW55YCB3aXRoIGBza2lwRHVwbGljYXRlc2Agc2V0IHRvIHRydWUgaXMgbm90IHN1cHBvcnRlZCBmb3IgZGVsZWdhdGVkIG1vZGVscycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGBjcmVhdGVNYW55YCBkb2Vzbid0IHN1cHBvcnQgbmVzdGVkIGNyZWF0ZSwgd2hpY2ggaXMgbmVlZGVkIGZvciBjcmVhdGluZyBlbnRpdGllc1xuICAgICAgICAvLyBpbmhlcml0aW5nIGEgZGVsZWdhdGUgYmFzZSwgc28gd2UgbmVlZCB0byBjb252ZXJ0IGl0IHRvIGEgcmVndWxhciBgY3JlYXRlYCBoZXJlLlxuICAgICAgICAvLyBOb3RlIHRoYXQgdGhlIG1haW4gZGlmZmVyZW5jZSBpcyBgY3JlYXRlYCBkb2Vzbid0IHN1cHBvcnQgYHNraXBEdXBsaWNhdGVzYCBhc1xuICAgICAgICAvLyBgY3JlYXRlTWFueWAgZG9lcy5cbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlVdGlscy50cmFuc2FjdGlvbih0aGlzLnByaXNtYSwgKHR4KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByID0geWllbGQgUHJvbWlzZS5hbGwoKDAsIGNyb3NzXzEuZW51bWVyYXRlKShhcmdzLmRhdGEpLm1hcCgoaXRlbSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRvQ3JlYXRlKHR4LCB0aGlzLm1vZGVsLCB7IGRhdGE6IGl0ZW0gfSk7XG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgLy8gZmlsdGVyIG91dCB1bmRlZmluZWQgdmFsdWUgKGR1ZSB0byBza2lwcGluZyBkdXBsaWNhdGVzKVxuICAgICAgICAgICAgcmV0dXJuIHsgY291bnQ6IHIuZmlsdGVyKChpdGVtKSA9PiAhIWl0ZW0pLmxlbmd0aCB9O1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGRvQ3JlYXRlKGRiLCBtb2RlbCwgYXJncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgYXJncyA9ICgwLCBkZWVwY29weV8xLmRlZmF1bHQpKGFyZ3MpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5pbmplY3RDcmVhdGVIaWVyYXJjaHkobW9kZWwsIGFyZ3MpO1xuICAgICAgICAgICAgdGhpcy5pbmplY3RTZWxlY3RJbmNsdWRlSGllcmFyY2h5KG1vZGVsLCBhcmdzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9nUHJpc21hUXVlcnkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKGBbZGVsZWdhdGVdIFxcYGNyZWF0ZVxcYCAke3RoaXMuZ2V0TW9kZWxOYW1lKG1vZGVsKX06ICR7KDAsIHV0aWxzXzEuZm9ybWF0T2JqZWN0KShhcmdzKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIGRiW21vZGVsXS5jcmVhdGUoYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hc3NlbWJsZUhpZXJhcmNoeShtb2RlbCwgcmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGluamVjdENyZWF0ZUhpZXJhcmNoeShtb2RlbCwgYXJncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgdmlzaXRvciA9IG5ldyBjcm9zc18xLk5lc3RlZFdyaXRlVmlzaXRvcih0aGlzLm9wdGlvbnMubW9kZWxNZXRhLCB7XG4gICAgICAgICAgICAgICAgY3JlYXRlOiAobW9kZWwsIGFyZ3MsIF9jb250ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9Qcm9jZXNzQ3JlYXRlUGF5bG9hZChtb2RlbCwgYXJncyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjcmVhdGVNYW55OiAobW9kZWwsIGFyZ3MsIGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYGNyZWF0ZU1hbnlgIGRvZXNuJ3Qgc3VwcG9ydCBuZXN0ZWQgY3JlYXRlLCB3aGljaCBpcyBuZWVkZWQgZm9yIGNyZWF0aW5nIGVudGl0aWVzXG4gICAgICAgICAgICAgICAgICAgIC8vIGluaGVyaXRpbmcgYSBkZWxlZ2F0ZSBiYXNlLCBzbyB3ZSBuZWVkIHRvIGNvbnZlcnQgaXQgdG8gYSByZWd1bGFyIGBjcmVhdGVgIGhlcmUuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGUgbWFpbiBkaWZmZXJlbmNlIGlzIGBjcmVhdGVgIGRvZXNuJ3Qgc3VwcG9ydCBgc2tpcER1cGxpY2F0ZXNgIGFzXG4gICAgICAgICAgICAgICAgICAgIC8vIGBjcmVhdGVNYW55YCBkb2VzLlxuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRGVsZWdhdGVPckRlc2NlbmRhbnRPZkRlbGVnYXRlKG1vZGVsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3Muc2tpcER1cGxpY2F0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAoMCwgdXRpbHNfMS5wcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IpKHRoaXMucHJpc21hLCB0aGlzLm9wdGlvbnMucHJpc21hTW9kdWxlLCAnYGNyZWF0ZU1hbnlgIHdpdGggYHNraXBEdXBsaWNhdGVzYCBzZXQgdG8gdHJ1ZSBpcyBub3Qgc3VwcG9ydGVkIGZvciBkZWxlZ2F0ZWQgbW9kZWxzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHRvIHJlZ3VsYXIgYGNyZWF0ZWBcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjcmVhdGVQYXlsb2FkID0gKF9hID0gY29udGV4dC5wYXJlbnQuY3JlYXRlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjcmVhdGVQYXlsb2FkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZVBheWxvYWQgPSBbY3JlYXRlUGF5bG9hZF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgKDAsIGNyb3NzXzEuZW51bWVyYXRlKShhcmdzLmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb1Byb2Nlc3NDcmVhdGVQYXlsb2FkKG1vZGVsLCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVQYXlsb2FkLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnBhcmVudC5jcmVhdGUgPSBjcmVhdGVQYXlsb2FkO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNvbnRleHQucGFyZW50WydjcmVhdGVNYW55J107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB5aWVsZCB2aXNpdG9yLnZpc2l0KG1vZGVsLCAnY3JlYXRlJywgYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkb1Byb2Nlc3NDcmVhdGVQYXlsb2FkKG1vZGVsLCBhcmdzKSB7XG4gICAgICAgIGlmICghYXJncykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW5zdXJlQmFzZUNyZWF0ZUhpZXJhcmNoeShtb2RlbCwgYXJncyk7XG4gICAgICAgIGZvciAoY29uc3QgW2ZpZWxkLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYXJncykpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkSW5mbyA9ICgwLCBjcm9zc18xLnJlc29sdmVGaWVsZCkodGhpcy5vcHRpb25zLm1vZGVsTWV0YSwgbW9kZWwsIGZpZWxkKTtcbiAgICAgICAgICAgIGlmIChmaWVsZEluZm8gPT09IG51bGwgfHwgZmllbGRJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWVsZEluZm8uaW5oZXJpdGVkRnJvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5qZWN0QmFzZUZpZWxkRGF0YShtb2RlbCwgZmllbGRJbmZvLCB2YWx1ZSwgYXJncywgJ2NyZWF0ZScpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBhcmdzW2ZpZWxkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBlbnN1cmUgdGhlIGZ1bGwgbmVzdGVkIFwiY3JlYXRlXCIgc3RydWN0dXJlIGlzIGNyZWF0ZWQgZm9yIGJhc2UgdHlwZXNcbiAgICBlbnN1cmVCYXNlQ3JlYXRlSGllcmFyY2h5KG1vZGVsLCBhcmdzKSB7XG4gICAgICAgIGxldCBjdXJyID0gYXJncztcbiAgICAgICAgbGV0IGJhc2UgPSB0aGlzLmdldEJhc2VNb2RlbChtb2RlbCk7XG4gICAgICAgIGxldCBzdWIgPSB0aGlzLmdldE1vZGVsSW5mbyhtb2RlbCk7XG4gICAgICAgIHdoaWxlIChiYXNlKSB7XG4gICAgICAgICAgICBjb25zdCBiYXNlUmVsYXRpb25OYW1lID0gdGhpcy5tYWtlQXV4UmVsYXRpb25OYW1lKGJhc2UpO1xuICAgICAgICAgICAgaWYgKCFjdXJyW2Jhc2VSZWxhdGlvbk5hbWVdKSB7XG4gICAgICAgICAgICAgICAgY3VycltiYXNlUmVsYXRpb25OYW1lXSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjdXJyW2Jhc2VSZWxhdGlvbk5hbWVdLmNyZWF0ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJbYmFzZVJlbGF0aW9uTmFtZV0uY3JlYXRlID0ge307XG4gICAgICAgICAgICAgICAgaWYgKGJhc2UuZGlzY3JpbWluYXRvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgZGlzY3JpbWluYXRvciBmaWVsZFxuICAgICAgICAgICAgICAgICAgICBjdXJyW2Jhc2VSZWxhdGlvbk5hbWVdLmNyZWF0ZVtiYXNlLmRpc2NyaW1pbmF0b3JdID0gc3ViLm5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTG9vayBmb3IgYmFzZSBpZCBmaWVsZCBhc3NpZ25tZW50cyBpbiB0aGUgY3VycmVudCBsZXZlbCwgYW5kIHB1c2hcbiAgICAgICAgICAgIC8vIHRoZW0gZG93biB0byB0aGUgYmFzZSBsZXZlbFxuICAgICAgICAgICAgZm9yIChjb25zdCBpZEZpZWxkIG9mICgwLCBjcm9zc18xLmdldElkRmllbGRzKSh0aGlzLm9wdGlvbnMubW9kZWxNZXRhLCBiYXNlLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJbaWRGaWVsZC5uYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJbYmFzZVJlbGF0aW9uTmFtZV0uY3JlYXRlW2lkRmllbGQubmFtZV0gPSBjdXJyW2lkRmllbGQubmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjdXJyW2lkRmllbGQubmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyciA9IGN1cnJbYmFzZVJlbGF0aW9uTmFtZV0uY3JlYXRlO1xuICAgICAgICAgICAgc3ViID0gYmFzZTtcbiAgICAgICAgICAgIGJhc2UgPSB0aGlzLmdldEJhc2VNb2RlbChiYXNlLm5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGluamVjdCBmaWVsZCBkYXRhIHRoYXQgYmVsb25ncyB0byBiYXNlIHR5cGUgaW50byBwcm9wZXIgbmVzdGluZyBzdHJ1Y3R1cmVcbiAgICBpbmplY3RCYXNlRmllbGREYXRhKG1vZGVsLCBmaWVsZEluZm8sIHZhbHVlLCBhcmdzLCBtb2RlKSB7XG4gICAgICAgIGxldCBiYXNlID0gdGhpcy5nZXRCYXNlTW9kZWwobW9kZWwpO1xuICAgICAgICBsZXQgY3VyciA9IGFyZ3M7XG4gICAgICAgIHdoaWxlIChiYXNlKSB7XG4gICAgICAgICAgICBpZiAoYmFzZS5kaXNjcmltaW5hdG9yID09PSBmaWVsZEluZm8ubmFtZSkge1xuICAgICAgICAgICAgICAgIHRocm93ICgwLCB1dGlsc18xLnByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvcikodGhpcy5wcmlzbWEsIHRoaXMub3B0aW9ucy5wcmlzbWFNb2R1bGUsIGBmaWVsZHMgXCIke2ZpZWxkSW5mby5uYW1lfVwiIGlzIGEgZGlzY3JpbWluYXRvciBhbmQgY2Fubm90IGJlIHNldCBkaXJlY3RseWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYmFzZVJlbGF0aW9uTmFtZSA9IHRoaXMubWFrZUF1eFJlbGF0aW9uTmFtZShiYXNlKTtcbiAgICAgICAgICAgIGlmICghY3VycltiYXNlUmVsYXRpb25OYW1lXSkge1xuICAgICAgICAgICAgICAgIGN1cnJbYmFzZVJlbGF0aW9uTmFtZV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY3VycltiYXNlUmVsYXRpb25OYW1lXVttb2RlXSkge1xuICAgICAgICAgICAgICAgIGN1cnJbYmFzZVJlbGF0aW9uTmFtZV1bbW9kZV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnIgPSBjdXJyW2Jhc2VSZWxhdGlvbk5hbWVdW21vZGVdO1xuICAgICAgICAgICAgaWYgKGZpZWxkSW5mby5pbmhlcml0ZWRGcm9tID09PSBiYXNlLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyW2ZpZWxkSW5mby5uYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmFzZSA9IHRoaXMuZ2V0QmFzZU1vZGVsKGJhc2UubmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gI2VuZHJlZ2lvblxuICAgIC8vICNyZWdpb24gdXBkYXRlXG4gICAgdXBkYXRlKGFyZ3MpIHtcbiAgICAgICAgaWYgKCFhcmdzKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgdXRpbHNfMS5wcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IpKHRoaXMucHJpc21hLCB0aGlzLm9wdGlvbnMucHJpc21hTW9kdWxlLCAncXVlcnkgYXJndW1lbnQgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFyZ3MuZGF0YSkge1xuICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxzXzEucHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yKSh0aGlzLnByaXNtYSwgdGhpcy5vcHRpb25zLnByaXNtYU1vZHVsZSwgJ2RhdGEgZmllbGQgaXMgcmVxdWlyZWQgaW4gcXVlcnkgYXJndW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaW52b2x2ZXNEZWxlZ2F0ZU1vZGVsKHRoaXMubW9kZWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIudXBkYXRlKGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5VXRpbHMudHJhbnNhY3Rpb24odGhpcy5wcmlzbWEsICh0eCkgPT4gdGhpcy5kb1VwZGF0ZSh0eCwgdGhpcy5tb2RlbCwgYXJncykpO1xuICAgIH1cbiAgICB1cGRhdGVNYW55KGFyZ3MpIHtcbiAgICAgICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICAgICAgICB1cGRhdGVNYW55OiB7IGdldDogKCkgPT4gc3VwZXIudXBkYXRlTWFueSB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCFhcmdzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxzXzEucHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yKSh0aGlzLnByaXNtYSwgdGhpcy5vcHRpb25zLnByaXNtYU1vZHVsZSwgJ3F1ZXJ5IGFyZ3VtZW50IGlzIHJlcXVpcmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFyZ3MuZGF0YSkge1xuICAgICAgICAgICAgICAgIHRocm93ICgwLCB1dGlsc18xLnByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvcikodGhpcy5wcmlzbWEsIHRoaXMub3B0aW9ucy5wcmlzbWFNb2R1bGUsICdkYXRhIGZpZWxkIGlzIHJlcXVpcmVkIGluIHF1ZXJ5IGFyZ3VtZW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuaW52b2x2ZXNEZWxlZ2F0ZU1vZGVsKHRoaXMubW9kZWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci51cGRhdGVNYW55LmNhbGwodGhpcywgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzaW1wbGVVcGRhdGVNYW55ID0gT2JqZWN0LmtleXMoYXJncy5kYXRhKS5ldmVyeSgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGBkYXRhYCBjbGF1c2UgaW52b2x2ZXMgYmFzZSBmaWVsZHNcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZEluZm8gPSAoMCwgY3Jvc3NfMS5yZXNvbHZlRmllbGQpKHRoaXMub3B0aW9ucy5tb2RlbE1ldGEsIHRoaXMubW9kZWwsIGtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEoZmllbGRJbmZvID09PSBudWxsIHx8IGZpZWxkSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmllbGRJbmZvLmluaGVyaXRlZEZyb20pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWVyeVV0aWxzLnRyYW5zYWN0aW9uKHRoaXMucHJpc21hLCAodHgpID0+IHRoaXMuZG9VcGRhdGVNYW55KHR4LCB0aGlzLm1vZGVsLCBhcmdzLCBzaW1wbGVVcGRhdGVNYW55KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cHNlcnQoYXJncykge1xuICAgICAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgICAgICAgIHVwc2VydDogeyBnZXQ6ICgpID0+IHN1cGVyLnVwc2VydCB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCFhcmdzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxzXzEucHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yKSh0aGlzLnByaXNtYSwgdGhpcy5vcHRpb25zLnByaXNtYU1vZHVsZSwgJ3F1ZXJ5IGFyZ3VtZW50IGlzIHJlcXVpcmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFyZ3Mud2hlcmUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAoMCwgdXRpbHNfMS5wcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IpKHRoaXMucHJpc21hLCB0aGlzLm9wdGlvbnMucHJpc21hTW9kdWxlLCAnd2hlcmUgZmllbGQgaXMgcmVxdWlyZWQgaW4gcXVlcnkgYXJndW1lbnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoMCwgY3Jvc3NfMS5pc0RlbGVnYXRlTW9kZWwpKHRoaXMub3B0aW9ucy5tb2RlbE1ldGEsIHRoaXMubW9kZWwpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxzXzEucHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yKSh0aGlzLnByaXNtYSwgdGhpcy5vcHRpb25zLnByaXNtYU1vZHVsZSwgYE1vZGVsIFwiJHt0aGlzLm1vZGVsfVwiIGlzIGEgZGVsZWdhdGUgYW5kIGRvZXNuJ3Qgc3VwcG9ydCB1cHNlcnRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5pbnZvbHZlc0RlbGVnYXRlTW9kZWwodGhpcy5tb2RlbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLnVwc2VydC5jYWxsKHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJncyA9ICgwLCBkZWVwY29weV8xLmRlZmF1bHQpKGFyZ3MpO1xuICAgICAgICAgICAgdGhpcy5pbmplY3RXaGVyZUhpZXJhcmNoeSh0aGlzLm1vZGVsLCBhcmdzID09PSBudWxsIHx8IGFyZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFyZ3Mud2hlcmUpO1xuICAgICAgICAgICAgdGhpcy5pbmplY3RTZWxlY3RJbmNsdWRlSGllcmFyY2h5KHRoaXMubW9kZWwsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKGFyZ3MuY3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb1Byb2Nlc3NDcmVhdGVQYXlsb2FkKHRoaXMubW9kZWwsIGFyZ3MuY3JlYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhcmdzLnVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9Qcm9jZXNzVXBkYXRlUGF5bG9hZCh0aGlzLm1vZGVsLCBhcmdzLnVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxvZ1ByaXNtYVF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgW2RlbGVnYXRlXSBcXGB1cHNlcnRcXGAgJHt0aGlzLmdldE1vZGVsTmFtZSh0aGlzLm1vZGVsKX06ICR7KDAsIHV0aWxzXzEuZm9ybWF0T2JqZWN0KShhcmdzKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMucHJpc21hW3RoaXMubW9kZWxdLnVwc2VydChhcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFzc2VtYmxlSGllcmFyY2h5KHRoaXMubW9kZWwsIHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkb1VwZGF0ZShkYiwgbW9kZWwsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGFyZ3MgPSAoMCwgZGVlcGNvcHlfMS5kZWZhdWx0KShhcmdzKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuaW5qZWN0VXBkYXRlSGllcmFyY2h5KGRiLCBtb2RlbCwgYXJncyk7XG4gICAgICAgICAgICB0aGlzLmluamVjdFNlbGVjdEluY2x1ZGVIaWVyYXJjaHkobW9kZWwsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2dQcmlzbWFRdWVyeSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oYFtkZWxlZ2F0ZV0gXFxgdXBkYXRlXFxgICR7dGhpcy5nZXRNb2RlbE5hbWUobW9kZWwpfTogJHsoMCwgdXRpbHNfMS5mb3JtYXRPYmplY3QpKGFyZ3MpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgZGJbbW9kZWxdLnVwZGF0ZShhcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFzc2VtYmxlSGllcmFyY2h5KG1vZGVsLCByZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZG9VcGRhdGVNYW55KGRiLCBtb2RlbCwgYXJncywgc2ltcGxlVXBkYXRlTWFueSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHNpbXBsZVVwZGF0ZU1hbnkpIHtcbiAgICAgICAgICAgICAgICAvLyBkbyBhIGRpcmVjdCBgdXBkYXRlTWFueWBcbiAgICAgICAgICAgICAgICBhcmdzID0gKDAsIGRlZXBjb3B5XzEuZGVmYXVsdCkoYXJncyk7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5pbmplY3RVcGRhdGVIaWVyYXJjaHkoZGIsIG1vZGVsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxvZ1ByaXNtYVF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oYFtkZWxlZ2F0ZV0gXFxgdXBkYXRlTWFueVxcYCAke3RoaXMuZ2V0TW9kZWxOYW1lKG1vZGVsKX06ICR7KDAsIHV0aWxzXzEuZm9ybWF0T2JqZWN0KShhcmdzKX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRiW21vZGVsXS51cGRhdGVNYW55KGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdHJhbnNsYXRlIHRvIHBsYWluIGB1cGRhdGVgIGZvciBuZXN0ZWQgd3JpdGUgaW50byBiYXNlIGZpZWxkc1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmRBcmdzID0ge1xuICAgICAgICAgICAgICAgICAgICB3aGVyZTogKDAsIGRlZXBjb3B5XzEuZGVmYXVsdCkoYXJncy53aGVyZSksXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdDogdGhpcy5xdWVyeVV0aWxzLm1ha2VJZFNlbGVjdGlvbihtb2RlbCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmluamVjdFVwZGF0ZUhpZXJhcmNoeShkYiwgbW9kZWwsIGZpbmRBcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxvZ1ByaXNtYVF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oYFtkZWxlZ2F0ZV0gXFxgdXBkYXRlTWFueVxcYCBmaW5kIGNhbmRpZGF0ZXM6ICR7dGhpcy5nZXRNb2RlbE5hbWUobW9kZWwpfTogJHsoMCwgdXRpbHNfMS5mb3JtYXRPYmplY3QpKGZpbmRBcmdzKX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZW50aXRpZXMgPSB5aWVsZCBkYlttb2RlbF0uZmluZE1hbnkoZmluZEFyZ3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZVBheWxvYWQgPSB7IGRhdGE6ICgwLCBkZWVwY29weV8xLmRlZmF1bHQpKGFyZ3MuZGF0YSksIHNlbGVjdDogdGhpcy5xdWVyeVV0aWxzLm1ha2VJZFNlbGVjdGlvbihtb2RlbCkgfTtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmluamVjdFVwZGF0ZUhpZXJhcmNoeShkYiwgbW9kZWwsIHVwZGF0ZVBheWxvYWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIFByb21pc2UuYWxsKGVudGl0aWVzLm1hcCgoZW50aXR5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZUFyZ3MgPSBPYmplY3QuYXNzaWduKHsgd2hlcmU6IGVudGl0eSB9LCB1cGRhdGVQYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2dQcmlzbWFRdWVyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgW2RlbGVnYXRlXSBcXGB1cGRhdGVNYW55XFxgIHVwZGF0ZTogJHt0aGlzLmdldE1vZGVsTmFtZShtb2RlbCl9OiAkeygwLCB1dGlsc18xLmZvcm1hdE9iamVjdCkodXBkYXRlQXJncyl9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRiW21vZGVsXS51cGRhdGUodXBkYXRlQXJncyk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGNvdW50OiByZXN1bHQubGVuZ3RoIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbmplY3RVcGRhdGVIaWVyYXJjaHkoZGIsIG1vZGVsLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB2aXNpdG9yID0gbmV3IGNyb3NzXzEuTmVzdGVkV3JpdGVWaXNpdG9yKHRoaXMub3B0aW9ucy5tb2RlbE1ldGEsIHtcbiAgICAgICAgICAgICAgICB1cGRhdGU6IChtb2RlbCwgYXJncywgX2NvbnRleHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmplY3RXaGVyZUhpZXJhcmNoeShtb2RlbCwgYXJncyA9PT0gbnVsbCB8fCBhcmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcmdzLndoZXJlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb1Byb2Nlc3NVcGRhdGVQYXlsb2FkKG1vZGVsLCBhcmdzID09PSBudWxsIHx8IGFyZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFyZ3MuZGF0YSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB1cGRhdGVNYW55OiAobW9kZWwsIGFyZ3MsIGNvbnRleHQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNpbXBsZVVwZGF0ZU1hbnkgPSBPYmplY3Qua2V5cyhhcmdzLmRhdGEpLmV2ZXJ5KChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBgZGF0YWAgY2xhdXNlIGludm9sdmVzIGJhc2UgZmllbGRzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZEluZm8gPSAoMCwgY3Jvc3NfMS5yZXNvbHZlRmllbGQpKHRoaXMub3B0aW9ucy5tb2RlbE1ldGEsIG1vZGVsLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEoZmllbGRJbmZvID09PSBudWxsIHx8IGZpZWxkSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmllbGRJbmZvLmluaGVyaXRlZEZyb20pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpbXBsZVVwZGF0ZU1hbnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBgd2hlcmVgIGNsYXVzZSBpbnZvbHZlcyBiYXNlIGZpZWxkc1xuICAgICAgICAgICAgICAgICAgICAgICAgc2ltcGxlVXBkYXRlTWFueSA9IE9iamVjdC5rZXlzKGFyZ3Mud2hlcmUgfHwge30pLmV2ZXJ5KChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZEluZm8gPSAoMCwgY3Jvc3NfMS5yZXNvbHZlRmllbGQpKHRoaXMub3B0aW9ucy5tb2RlbE1ldGEsIG1vZGVsLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhKGZpZWxkSW5mbyA9PT0gbnVsbCB8fCBmaWVsZEluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpZWxkSW5mby5pbmhlcml0ZWRGcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaW1wbGVVcGRhdGVNYW55KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluamVjdFdoZXJlSGllcmFyY2h5KG1vZGVsLCBhcmdzID09PSBudWxsIHx8IGFyZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFyZ3Mud2hlcmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb1Byb2Nlc3NVcGRhdGVQYXlsb2FkKG1vZGVsLCBhcmdzID09PSBudWxsIHx8IGFyZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFyZ3MuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3aGVyZSA9IHRoaXMucXVlcnlVdGlscy5idWlsZFJldmVyc2VkUXVlcnkoY29udGV4dCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucXVlcnlVdGlscy50cmFuc2FjdGlvbihkYiwgKHR4KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5kb1VwZGF0ZU1hbnkodHgsIG1vZGVsLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFyZ3MpLCB7IHdoZXJlIH0pLCBzaW1wbGVVcGRhdGVNYW55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjb250ZXh0LnBhcmVudFsndXBkYXRlTWFueSddO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgdXBzZXJ0OiAobW9kZWwsIGFyZ3MsIF9jb250ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5qZWN0V2hlcmVIaWVyYXJjaHkobW9kZWwsIGFyZ3MgPT09IG51bGwgfHwgYXJncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXJncy53aGVyZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmNyZWF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb1Byb2Nlc3NDcmVhdGVQYXlsb2FkKG1vZGVsLCBhcmdzID09PSBudWxsIHx8IGFyZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFyZ3MuY3JlYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy51cGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9Qcm9jZXNzVXBkYXRlUGF5bG9hZChtb2RlbCwgYXJncyA9PT0gbnVsbCB8fCBhcmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcmdzLnVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNyZWF0ZTogKG1vZGVsLCBhcmdzLCBfY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIGNyb3NzXzEuaXNEZWxlZ2F0ZU1vZGVsKSh0aGlzLm9wdGlvbnMubW9kZWxNZXRhLCBtb2RlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICgwLCB1dGlsc18xLnByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvcikodGhpcy5wcmlzbWEsIHRoaXMub3B0aW9ucy5wcmlzbWFNb2R1bGUsIGBNb2RlbCBcIiR7bW9kZWx9XCIgaXMgYSBkZWxlZ2F0ZSBhbmQgY2Fubm90IGJlIGNyZWF0ZWQgZGlyZWN0bHlgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvUHJvY2Vzc0NyZWF0ZVBheWxvYWQobW9kZWwsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY3JlYXRlTWFueTogKG1vZGVsLCBhcmdzLCBfY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5za2lwRHVwbGljYXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxzXzEucHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yKSh0aGlzLnByaXNtYSwgdGhpcy5vcHRpb25zLnByaXNtYU1vZHVsZSwgJ2BjcmVhdGVNYW55YCB3aXRoIGBza2lwRHVwbGljYXRlc2Agc2V0IHRvIHRydWUgaXMgbm90IHN1cHBvcnRlZCBmb3IgZGVsZWdhdGVkIG1vZGVscycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiAoMCwgY3Jvc3NfMS5lbnVtZXJhdGUpKGFyZ3MgPT09IG51bGwgfHwgYXJncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXJncy5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb1Byb2Nlc3NDcmVhdGVQYXlsb2FkKG1vZGVsLCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29ubmVjdDogKG1vZGVsLCBhcmdzLCBfY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluamVjdFdoZXJlSGllcmFyY2h5KG1vZGVsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvbm5lY3RPckNyZWF0ZTogKG1vZGVsLCBhcmdzLCBfY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluamVjdFdoZXJlSGllcmFyY2h5KG1vZGVsLCBhcmdzLndoZXJlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MuY3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvUHJvY2Vzc0NyZWF0ZVBheWxvYWQobW9kZWwsIGFyZ3MuY3JlYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGlzY29ubmVjdDogKG1vZGVsLCBhcmdzLCBfY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluamVjdFdoZXJlSGllcmFyY2h5KG1vZGVsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogKG1vZGVsLCBhcmdzLCBfY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluamVjdFdoZXJlSGllcmFyY2h5KG1vZGVsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRlbGV0ZTogKG1vZGVsLCBfYXJncywgY29udGV4dCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB3aGVyZSA9IHRoaXMucXVlcnlVdGlscy5idWlsZFJldmVyc2VkUXVlcnkoY29udGV4dCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5xdWVyeVV0aWxzLnRyYW5zYWN0aW9uKGRiLCAodHgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZG9EZWxldGUodHgsIG1vZGVsLCB7IHdoZXJlIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjb250ZXh0LnBhcmVudFsnZGVsZXRlJ107XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgZGVsZXRlTWFueTogKG1vZGVsLCBfYXJncywgY29udGV4dCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB3aGVyZSA9IHRoaXMucXVlcnlVdGlscy5idWlsZFJldmVyc2VkUXVlcnkoY29udGV4dCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5xdWVyeVV0aWxzLnRyYW5zYWN0aW9uKGRiLCAodHgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZG9EZWxldGVNYW55KHR4LCBtb2RlbCwgd2hlcmUpO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjb250ZXh0LnBhcmVudFsnZGVsZXRlTWFueSddO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB5aWVsZCB2aXNpdG9yLnZpc2l0KG1vZGVsLCAndXBkYXRlJywgYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkb1Byb2Nlc3NVcGRhdGVQYXlsb2FkKG1vZGVsLCBkYXRhKSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2ZpZWxkLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkSW5mbyA9ICgwLCBjcm9zc18xLnJlc29sdmVGaWVsZCkodGhpcy5vcHRpb25zLm1vZGVsTWV0YSwgbW9kZWwsIGZpZWxkKTtcbiAgICAgICAgICAgIGlmIChmaWVsZEluZm8gPT09IG51bGwgfHwgZmllbGRJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWVsZEluZm8uaW5oZXJpdGVkRnJvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5qZWN0QmFzZUZpZWxkRGF0YShtb2RlbCwgZmllbGRJbmZvLCB2YWx1ZSwgZGF0YSwgJ3VwZGF0ZScpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBkYXRhW2ZpZWxkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyAjZW5kcmVnaW9uXG4gICAgLy8gI3JlZ2lvbiBkZWxldGVcbiAgICBkZWxldGUoYXJncykge1xuICAgICAgICBpZiAoIWFyZ3MpIHtcbiAgICAgICAgICAgIHRocm93ICgwLCB1dGlsc18xLnByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvcikodGhpcy5wcmlzbWEsIHRoaXMub3B0aW9ucy5wcmlzbWFNb2R1bGUsICdxdWVyeSBhcmd1bWVudCBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pbnZvbHZlc0RlbGVnYXRlTW9kZWwodGhpcy5tb2RlbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5kZWxldGUoYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlVdGlscy50cmFuc2FjdGlvbih0aGlzLnByaXNtYSwgKHR4KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RJbmNsdWRlID0gdGhpcy5idWlsZFNlbGVjdEluY2x1ZGVIaWVyYXJjaHkodGhpcy5tb2RlbCwgYXJncyk7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgaWQgZmllbGRzIGFyZSBzZWxlY3RlZFxuICAgICAgICAgICAgY29uc3QgaWRGaWVsZHMgPSB0aGlzLmdldElkRmllbGRzKHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpZEZpZWxkIG9mIGlkRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKChzZWxlY3RJbmNsdWRlID09PSBudWxsIHx8IHNlbGVjdEluY2x1ZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbGVjdEluY2x1ZGUuc2VsZWN0KSAmJiAhKGlkRmllbGQubmFtZSBpbiBzZWxlY3RJbmNsdWRlLnNlbGVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0SW5jbHVkZS5zZWxlY3RbaWRGaWVsZC5uYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVsZXRlQXJncyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKDAsIGRlZXBjb3B5XzEuZGVmYXVsdCkoYXJncykpLCBzZWxlY3RJbmNsdWRlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvRGVsZXRlKHR4LCB0aGlzLm1vZGVsLCBkZWxldGVBcmdzKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBkZWxldGVNYW55KGFyZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLmludm9sdmVzRGVsZWdhdGVNb2RlbCh0aGlzLm1vZGVsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmRlbGV0ZU1hbnkoYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlVdGlscy50cmFuc2FjdGlvbih0aGlzLnByaXNtYSwgKHR4KSA9PiB0aGlzLmRvRGVsZXRlTWFueSh0eCwgdGhpcy5tb2RlbCwgYXJncyA9PT0gbnVsbCB8fCBhcmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcmdzLndoZXJlKSk7XG4gICAgfVxuICAgIGRvRGVsZXRlTWFueShkYiwgbW9kZWwsIHdoZXJlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBxdWVyeSBleGlzdGluZyBlbnRpdGllcyB3aXRoIGlkXG4gICAgICAgICAgICBjb25zdCBpZFNlbGVjdGlvbiA9IHRoaXMucXVlcnlVdGlscy5tYWtlSWRTZWxlY3Rpb24obW9kZWwpO1xuICAgICAgICAgICAgY29uc3QgZmluZEFyZ3MgPSB7IHdoZXJlOiAoMCwgZGVlcGNvcHlfMS5kZWZhdWx0KSh3aGVyZSksIHNlbGVjdDogaWRTZWxlY3Rpb24gfTtcbiAgICAgICAgICAgIHRoaXMuaW5qZWN0V2hlcmVIaWVyYXJjaHkobW9kZWwsIGZpbmRBcmdzLndoZXJlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9nUHJpc21hUXVlcnkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKGBbZGVsZWdhdGVdIFxcYGRlbGV0ZU1hbnlcXGAgZmluZCBjYW5kaWRhdGVzOiAke3RoaXMuZ2V0TW9kZWxOYW1lKG1vZGVsKX06ICR7KDAsIHV0aWxzXzEuZm9ybWF0T2JqZWN0KShmaW5kQXJncyl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlbnRpdGllcyA9IHlpZWxkIGRiW21vZGVsXS5maW5kTWFueShmaW5kQXJncyk7XG4gICAgICAgICAgICAvLyByZWN1cnNpdmVseSBkZWxldGUgYmFzZSBlbnRpdGllcyAodGhleSBhbGwgaGF2ZSB0aGUgc2FtZSBpZCB2YWx1ZXMpXG4gICAgICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChlbnRpdGllcy5tYXAoKGVudGl0eSkgPT4gdGhpcy5kb0RlbGV0ZShkYiwgbW9kZWwsIHsgd2hlcmU6IGVudGl0eSB9KSkpO1xuICAgICAgICAgICAgcmV0dXJuIHsgY291bnQ6IGVudGl0aWVzLmxlbmd0aCB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVsZXRlQmFzZVJlY3Vyc2l2ZWx5KGRiLCBtb2RlbCwgaWRWYWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCBiYXNlID0gdGhpcy5nZXRCYXNlTW9kZWwobW9kZWwpO1xuICAgICAgICAgICAgd2hpbGUgKGJhc2UpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBkYltiYXNlLm5hbWVdLmRlbGV0ZSh7IHdoZXJlOiBpZFZhbHVlcyB9KTtcbiAgICAgICAgICAgICAgICBiYXNlID0gdGhpcy5nZXRCYXNlTW9kZWwoYmFzZS5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRvRGVsZXRlKGRiLCBtb2RlbCwgYXJncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5pbmplY3RXaGVyZUhpZXJhcmNoeShtb2RlbCwgYXJncy53aGVyZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxvZ1ByaXNtYVF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgW2RlbGVnYXRlXSBcXGBkZWxldGVcXGAgJHt0aGlzLmdldE1vZGVsTmFtZShtb2RlbCl9OiAkeygwLCB1dGlsc18xLmZvcm1hdE9iamVjdCkoYXJncyl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBkYlttb2RlbF0uZGVsZXRlKGFyZ3MpO1xuICAgICAgICAgICAgY29uc3QgaWRWYWx1ZXMgPSB0aGlzLnF1ZXJ5VXRpbHMuZ2V0RW50aXR5SWRzKG1vZGVsLCByZXN1bHQpO1xuICAgICAgICAgICAgLy8gcmVjdXJzaXZlbHkgZGVsZXRlIGJhc2UgZW50aXRpZXMgKHRoZXkgYWxsIGhhdmUgdGhlIHNhbWUgaWQgdmFsdWVzKVxuICAgICAgICAgICAgeWllbGQgdGhpcy5kZWxldGVCYXNlUmVjdXJzaXZlbHkoZGIsIG1vZGVsLCBpZFZhbHVlcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hc3NlbWJsZUhpZXJhcmNoeShtb2RlbCwgcmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vICNlbmRyZWdpb25cbiAgICAvLyAjcmVnaW9uIGFnZ3JlZ2F0aW9uXG4gICAgYWdncmVnYXRlKGFyZ3MpIHtcbiAgICAgICAgaWYgKCFhcmdzKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgdXRpbHNfMS5wcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IpKHRoaXMucHJpc21hLCB0aGlzLm9wdGlvbnMucHJpc21hTW9kdWxlLCAncXVlcnkgYXJndW1lbnQgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaW52b2x2ZXNEZWxlZ2F0ZU1vZGVsKHRoaXMubW9kZWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuYWdncmVnYXRlKGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGlmIGFueSBhZ2dyZWdhdGlvbiBvcGVyYXRvciBpcyB1c2luZyBmaWVsZHMgZnJvbSBiYXNlXG4gICAgICAgIHRoaXMuY2hlY2tBZ2dyZWdhdGlvbkFyZ3MoJ2FnZ3JlZ2F0ZScsIGFyZ3MpO1xuICAgICAgICBhcmdzID0gKDAsIGRlZXBjb3B5XzEuZGVmYXVsdCkoYXJncyk7XG4gICAgICAgIGlmIChhcmdzLmN1cnNvcikge1xuICAgICAgICAgICAgYXJncy5jdXJzb3IgPSB0aGlzLmJ1aWxkV2hlcmVIaWVyYXJjaHkodGhpcy5tb2RlbCwgYXJncy5jdXJzb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdzLm9yZGVyQnkpIHtcbiAgICAgICAgICAgIGFyZ3Mub3JkZXJCeSA9IHRoaXMuYnVpbGRXaGVyZUhpZXJhcmNoeSh0aGlzLm1vZGVsLCBhcmdzLm9yZGVyQnkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdzLndoZXJlKSB7XG4gICAgICAgICAgICBhcmdzLndoZXJlID0gdGhpcy5idWlsZFdoZXJlSGllcmFyY2h5KHRoaXMubW9kZWwsIGFyZ3Mud2hlcmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9nUHJpc21hUXVlcnkpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oYFtkZWxlZ2F0ZV0gXFxgYWdncmVnYXRlXFxgICR7dGhpcy5nZXRNb2RlbE5hbWUodGhpcy5tb2RlbCl9OiAkeygwLCB1dGlsc18xLmZvcm1hdE9iamVjdCkoYXJncyl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmFnZ3JlZ2F0ZShhcmdzKTtcbiAgICB9XG4gICAgY291bnQoYXJncykge1xuICAgICAgICBpZiAoIXRoaXMuaW52b2x2ZXNEZWxlZ2F0ZU1vZGVsKHRoaXMubW9kZWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuY291bnQoYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgaWYgY291bnQgc2VsZWN0IGlzIHVzaW5nIGZpZWxkcyBmcm9tIGJhc2VcbiAgICAgICAgdGhpcy5jaGVja0FnZ3JlZ2F0aW9uQXJncygnY291bnQnLCBhcmdzKTtcbiAgICAgICAgYXJncyA9ICgwLCBkZWVwY29weV8xLmRlZmF1bHQpKGFyZ3MpO1xuICAgICAgICBpZiAoYXJncyA9PT0gbnVsbCB8fCBhcmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcmdzLmN1cnNvcikge1xuICAgICAgICAgICAgYXJncy5jdXJzb3IgPSB0aGlzLmJ1aWxkV2hlcmVIaWVyYXJjaHkodGhpcy5tb2RlbCwgYXJncy5jdXJzb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdzID09PSBudWxsIHx8IGFyZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFyZ3Mud2hlcmUpIHtcbiAgICAgICAgICAgIGFyZ3Mud2hlcmUgPSB0aGlzLmJ1aWxkV2hlcmVIaWVyYXJjaHkodGhpcy5tb2RlbCwgYXJncy53aGVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2dQcmlzbWFRdWVyeSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgW2RlbGVnYXRlXSBcXGBjb3VudFxcYCAke3RoaXMuZ2V0TW9kZWxOYW1lKHRoaXMubW9kZWwpfTogJHsoMCwgdXRpbHNfMS5mb3JtYXRPYmplY3QpKGFyZ3MpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5jb3VudChhcmdzKTtcbiAgICB9XG4gICAgZ3JvdXBCeShhcmdzKSB7XG4gICAgICAgIGlmICghYXJncykge1xuICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxzXzEucHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yKSh0aGlzLnByaXNtYSwgdGhpcy5vcHRpb25zLnByaXNtYU1vZHVsZSwgJ3F1ZXJ5IGFyZ3VtZW50IGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmludm9sdmVzRGVsZWdhdGVNb2RlbCh0aGlzLm1vZGVsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmdyb3VwQnkoYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgaWYgY291bnQgc2VsZWN0IGlzIHVzaW5nIGZpZWxkcyBmcm9tIGJhc2VcbiAgICAgICAgdGhpcy5jaGVja0FnZ3JlZ2F0aW9uQXJncygnZ3JvdXBCeScsIGFyZ3MpO1xuICAgICAgICBpZiAoYXJncy5ieSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBieSBvZiAoMCwgY3Jvc3NfMS5lbnVtZXJhdGUpKGFyZ3MuYnkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRJbmZvID0gKDAsIGNyb3NzXzEucmVzb2x2ZUZpZWxkKSh0aGlzLm9wdGlvbnMubW9kZWxNZXRhLCB0aGlzLm1vZGVsLCBieSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkSW5mbyAmJiBmaWVsZEluZm8uaW5oZXJpdGVkRnJvbSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyAoMCwgdXRpbHNfMS5wcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IpKHRoaXMucHJpc21hLCB0aGlzLm9wdGlvbnMucHJpc21hTW9kdWxlLCBgZ3JvdXBCeSB3aXRoIGZpZWxkcyBmcm9tIGJhc2UgdHlwZSBpcyBub3Qgc3VwcG9ydGVkIHlldDogXCIke2J5fVwiYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFyZ3MgPSAoMCwgZGVlcGNvcHlfMS5kZWZhdWx0KShhcmdzKTtcbiAgICAgICAgaWYgKGFyZ3Mud2hlcmUpIHtcbiAgICAgICAgICAgIGFyZ3Mud2hlcmUgPSB0aGlzLmJ1aWxkV2hlcmVIaWVyYXJjaHkodGhpcy5tb2RlbCwgYXJncy53aGVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2dQcmlzbWFRdWVyeSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgW2RlbGVnYXRlXSBcXGBncm91cEJ5XFxgICR7dGhpcy5nZXRNb2RlbE5hbWUodGhpcy5tb2RlbCl9OiAkeygwLCB1dGlsc18xLmZvcm1hdE9iamVjdCkoYXJncyl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmdyb3VwQnkoYXJncyk7XG4gICAgfVxuICAgIGNoZWNrQWdncmVnYXRpb25BcmdzKG9wZXJhdGlvbiwgYXJncykge1xuICAgICAgICBpZiAoIWFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG9wIG9mIFsnX2NvdW50JywgJ19zdW0nLCAnX2F2ZycsICdfbWluJywgJ19tYXgnLCAnc2VsZWN0JywgJ2hhdmluZyddKSB7XG4gICAgICAgICAgICBpZiAoYXJnc1tvcF0gJiYgdHlwZW9mIGFyZ3Nbb3BdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgT2JqZWN0LmtleXMoYXJnc1tvcF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkSW5mbyA9ICgwLCBjcm9zc18xLnJlc29sdmVGaWVsZCkodGhpcy5vcHRpb25zLm1vZGVsTWV0YSwgdGhpcy5tb2RlbCwgZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRJbmZvID09PSBudWxsIHx8IGZpZWxkSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmllbGRJbmZvLmluaGVyaXRlZEZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICgwLCB1dGlsc18xLnByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvcikodGhpcy5wcmlzbWEsIHRoaXMub3B0aW9ucy5wcmlzbWFNb2R1bGUsIGAke29wZXJhdGlvbn0gd2l0aCBmaWVsZHMgZnJvbSBiYXNlIHR5cGUgaXMgbm90IHN1cHBvcnRlZCB5ZXQ6IFwiJHtmaWVsZH1cImApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vICNlbmRyZWdpb25cbiAgICAvLyAjcmVnaW9uIHV0aWxzXG4gICAgZXh0cmFjdFNlbGVjdEluY2x1ZGUoYXJncykge1xuICAgICAgICBpZiAoIWFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXJncyA9ICgwLCBkZWVwY29weV8xLmRlZmF1bHQpKGFyZ3MpO1xuICAgICAgICByZXR1cm4gJ3NlbGVjdCcgaW4gYXJnc1xuICAgICAgICAgICAgPyB7IHNlbGVjdDogYXJnc1snc2VsZWN0J10gfVxuICAgICAgICAgICAgOiAnaW5jbHVkZScgaW4gYXJnc1xuICAgICAgICAgICAgICAgID8geyBpbmNsdWRlOiBhcmdzWydpbmNsdWRlJ10gfVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBtYWtlQXV4UmVsYXRpb25OYW1lKG1vZGVsKSB7XG4gICAgICAgIHJldHVybiBgJHtjb25zdGFudHNfMS5ERUxFR0FURV9BVVhfUkVMQVRJT05fUFJFRklYfV8keygwLCBsb3dlcl9jYXNlX2ZpcnN0XzEubG93ZXJDYXNlRmlyc3QpKG1vZGVsLm5hbWUpfWA7XG4gICAgfVxuICAgIGdldE1vZGVsTmFtZShtb2RlbCkge1xuICAgICAgICBjb25zdCBpbmZvID0gKDAsIGNyb3NzXzEuZ2V0TW9kZWxJbmZvKSh0aGlzLm9wdGlvbnMubW9kZWxNZXRhLCBtb2RlbCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBpbmZvLm5hbWU7XG4gICAgfVxuICAgIGdldElkRmllbGRzKG1vZGVsKSB7XG4gICAgICAgIGNvbnN0IGlkRmllbGRzID0gKDAsIGNyb3NzXzEuZ2V0SWRGaWVsZHMpKHRoaXMub3B0aW9ucy5tb2RlbE1ldGEsIG1vZGVsKTtcbiAgICAgICAgaWYgKGlkRmllbGRzICYmIGlkRmllbGRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBpZEZpZWxkcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5nZXRCYXNlTW9kZWwobW9kZWwpO1xuICAgICAgICByZXR1cm4gYmFzZSA/IHRoaXMuZ2V0SWRGaWVsZHMoYmFzZS5uYW1lKSA6IFtdO1xuICAgIH1cbiAgICBnZXRNb2RlbEluZm8obW9kZWwpIHtcbiAgICAgICAgcmV0dXJuICgwLCBjcm9zc18xLmdldE1vZGVsSW5mbykodGhpcy5vcHRpb25zLm1vZGVsTWV0YSwgbW9kZWwsIHRydWUpO1xuICAgIH1cbiAgICBnZXRCYXNlTW9kZWwobW9kZWwpIHtcbiAgICAgICAgY29uc3QgYmFzZU5hbWVzID0gKDAsIGNyb3NzXzEuZ2V0TW9kZWxJbmZvKSh0aGlzLm9wdGlvbnMubW9kZWxNZXRhLCBtb2RlbCwgdHJ1ZSkuYmFzZVR5cGVzO1xuICAgICAgICBpZiAoIWJhc2VOYW1lcykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFzZU5hbWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVsdGktaW5oZXJpdGFuY2UgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMubW9kZWxNZXRhLm1vZGVsc1soMCwgbG93ZXJfY2FzZV9maXJzdF8xLmxvd2VyQ2FzZUZpcnN0KShiYXNlTmFtZXNbMF0pXTtcbiAgICB9XG4gICAgaW52b2x2ZXNEZWxlZ2F0ZU1vZGVsKG1vZGVsLCB2aXNpdGVkKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGVsZWdhdGVPckRlc2NlbmRhbnRPZkRlbGVnYXRlKG1vZGVsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmlzaXRlZCA9IHZpc2l0ZWQgIT09IG51bGwgJiYgdmlzaXRlZCAhPT0gdm9pZCAwID8gdmlzaXRlZCA6IG5ldyBTZXQoKTtcbiAgICAgICAgaWYgKHZpc2l0ZWQuaGFzKG1vZGVsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZpc2l0ZWQuYWRkKG1vZGVsKTtcbiAgICAgICAgY29uc3QgbW9kZWxJbmZvID0gKDAsIGNyb3NzXzEuZ2V0TW9kZWxJbmZvKSh0aGlzLm9wdGlvbnMubW9kZWxNZXRhLCBtb2RlbCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKG1vZGVsSW5mby5maWVsZHMpLnNvbWUoKGZpZWxkKSA9PiBmaWVsZC5pc0RhdGFNb2RlbCAmJiB0aGlzLmludm9sdmVzRGVsZWdhdGVNb2RlbChmaWVsZC50eXBlLCB2aXNpdGVkKSk7XG4gICAgfVxuICAgIGlzRGVsZWdhdGVPckRlc2NlbmRhbnRPZkRlbGVnYXRlKG1vZGVsKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCgwLCBjcm9zc18xLmlzRGVsZWdhdGVNb2RlbCkodGhpcy5vcHRpb25zLm1vZGVsTWV0YSwgbW9kZWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiYXNlVHlwZXMgPSAoX2EgPSAoMCwgY3Jvc3NfMS5nZXRNb2RlbEluZm8pKHRoaXMub3B0aW9ucy5tb2RlbE1ldGEsIG1vZGVsKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJhc2VUeXBlcztcbiAgICAgICAgcmV0dXJuICEhKGJhc2VUeXBlcyAmJlxuICAgICAgICAgICAgYmFzZVR5cGVzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIGJhc2VUeXBlcy5zb21lKChiYXNlKSA9PiB0aGlzLmlzRGVsZWdhdGVPckRlc2NlbmRhbnRPZkRlbGVnYXRlKGJhc2UpKSk7XG4gICAgfVxuICAgIGFzc2VtYmxlSGllcmFyY2h5KG1vZGVsLCBlbnRpdHkpIHtcbiAgICAgICAgaWYgKCFlbnRpdHkgfHwgdHlwZW9mIGVudGl0eSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRpdHk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXBNZXJnZWQgPSB0aGlzLmFzc2VtYmxlVXAobW9kZWwsIGVudGl0eSk7XG4gICAgICAgIGNvbnN0IGRvd25NZXJnZWQgPSB0aGlzLmFzc2VtYmxlRG93bihtb2RlbCwgZW50aXR5KTtcbiAgICAgICAgLy8gaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZGVlcG1lcmdlI2FycmF5bWVyZ2UtZXhhbXBsZS1jb21iaW5lLWFycmF5c1xuICAgICAgICBjb25zdCBjb21iaW5lTWVyZ2UgPSAodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gdGFyZ2V0LnNsaWNlKCk7XG4gICAgICAgICAgICBzb3VyY2UuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlc3RpbmF0aW9uW2luZGV4XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb25baW5kZXhdID0gb3B0aW9ucy5jbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChpdGVtLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdChpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbltpbmRleF0gPSAoMCwgZGVlcG1lcmdlXzEuZGVmYXVsdCkodGFyZ2V0W2luZGV4XSwgaXRlbSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRhcmdldC5pbmRleE9mKGl0ZW0pID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXN1bHQgPSAoMCwgZGVlcG1lcmdlXzEuZGVmYXVsdCkodXBNZXJnZWQsIGRvd25NZXJnZWQsIHtcbiAgICAgICAgICAgIGFycmF5TWVyZ2U6IGNvbWJpbmVNZXJnZSxcbiAgICAgICAgICAgIGlzTWVyZ2VhYmxlT2JqZWN0OiAodikgPT4gKDAsIGlzX3BsYWluX29iamVjdF8xLmlzUGxhaW5PYmplY3QpKHYpIHx8IEFycmF5LmlzQXJyYXkodiksIC8vIGF2b2lkIG1lc3Npbmcgd2l0aCBEZWNpbWFsLCBEYXRlLCBldGMuXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3NlbWJsZVVwKG1vZGVsLCBlbnRpdHkpIHtcbiAgICAgICAgaWYgKCFlbnRpdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRpdHk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGNvbnN0IGJhc2UgPSB0aGlzLmdldEJhc2VNb2RlbChtb2RlbCk7XG4gICAgICAgIGlmIChiYXNlKSB7XG4gICAgICAgICAgICAvLyBtZXJnZSBiYXNlIGZpZWxkc1xuICAgICAgICAgICAgY29uc3QgYmFzZVJlbGF0aW9uTmFtZSA9IHRoaXMubWFrZUF1eFJlbGF0aW9uTmFtZShiYXNlKTtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VEYXRhID0gZW50aXR5W2Jhc2VSZWxhdGlvbk5hbWVdO1xuICAgICAgICAgICAgaWYgKGJhc2VEYXRhICYmIHR5cGVvZiBiYXNlRGF0YSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlQXNzZW1ibGVkID0gdGhpcy5hc3NlbWJsZVVwKGJhc2UubmFtZSwgYmFzZURhdGEpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LCBiYXNlQXNzZW1ibGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2RlbEluZm8gPSAoMCwgY3Jvc3NfMS5nZXRNb2RlbEluZm8pKHRoaXMub3B0aW9ucy5tb2RlbE1ldGEsIG1vZGVsLCB0cnVlKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZW50aXR5KSkge1xuICAgICAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKGNvbnN0YW50c18xLkRFTEVHQVRFX0FVWF9SRUxBVElPTl9QUkVGSVgpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IG1vZGVsSW5mby5maWVsZHNba2V5XTtcbiAgICAgICAgICAgIGlmICghZmllbGQpIHtcbiAgICAgICAgICAgICAgICAvLyBub3QgYSBmaWVsZCwgY291bGQgYmUgYF9jb3VudGAsIGBfc3VtYCwgZXRjLlxuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmllbGQuaW5oZXJpdGVkRnJvbSkge1xuICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgbWVyZ2VkIGZyb20gYmFzZVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpZWxkLmlzRGF0YU1vZGVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtmaWVsZC5uYW1lXSA9IHZhbHVlLm1hcCgoaXRlbSkgPT4gdGhpcy5hc3NlbWJsZVVwKGZpZWxkLnR5cGUsIGl0ZW0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtmaWVsZC5uYW1lXSA9IHRoaXMuYXNzZW1ibGVVcChmaWVsZC50eXBlLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ZpZWxkLm5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXNzZW1ibGVEb3duKG1vZGVsLCBlbnRpdHkpIHtcbiAgICAgICAgaWYgKCFlbnRpdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRpdHk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGNvbnN0IG1vZGVsSW5mbyA9ICgwLCBjcm9zc18xLmdldE1vZGVsSW5mbykodGhpcy5vcHRpb25zLm1vZGVsTWV0YSwgbW9kZWwsIHRydWUpO1xuICAgICAgICBpZiAobW9kZWxJbmZvLmRpc2NyaW1pbmF0b3IpIHtcbiAgICAgICAgICAgIC8vIG1vZGVsIGlzIGEgZGVsZWdhdGUsIG1lcmdlIHN1YiBtb2RlbCBmaWVsZHNcbiAgICAgICAgICAgIGNvbnN0IHN1Yk1vZGVsTmFtZSA9IGVudGl0eVttb2RlbEluZm8uZGlzY3JpbWluYXRvcl07XG4gICAgICAgICAgICBpZiAoc3ViTW9kZWxOYW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViTW9kZWwgPSAoMCwgY3Jvc3NfMS5nZXRNb2RlbEluZm8pKHRoaXMub3B0aW9ucy5tb2RlbE1ldGEsIHN1Yk1vZGVsTmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViUmVsYXRpb25OYW1lID0gdGhpcy5tYWtlQXV4UmVsYXRpb25OYW1lKHN1Yk1vZGVsKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJEYXRhID0gZW50aXR5W3N1YlJlbGF0aW9uTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHN1YkRhdGEgJiYgdHlwZW9mIHN1YkRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1YkFzc2VtYmxlZCA9IHRoaXMuYXNzZW1ibGVEb3duKHN1Yk1vZGVsLm5hbWUsIHN1YkRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHJlc3VsdCwgc3ViQXNzZW1ibGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZW50aXR5KSkge1xuICAgICAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKGNvbnN0YW50c18xLkRFTEVHQVRFX0FVWF9SRUxBVElPTl9QUkVGSVgpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IG1vZGVsSW5mby5maWVsZHNba2V5XTtcbiAgICAgICAgICAgIGlmICghZmllbGQpIHtcbiAgICAgICAgICAgICAgICAvLyBub3QgYSBmaWVsZCwgY291bGQgYmUgYF9jb3VudGAsIGBfc3VtYCwgZXRjLlxuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmllbGQuaXNEYXRhTW9kZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ZpZWxkLm5hbWVdID0gdmFsdWUubWFwKChpdGVtKSA9PiB0aGlzLmFzc2VtYmxlRG93bihmaWVsZC50eXBlLCBpdGVtKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbZmllbGQubmFtZV0gPSB0aGlzLmFzc2VtYmxlRG93bihmaWVsZC50eXBlLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ZpZWxkLm5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5leHBvcnRzLkRlbGVnYXRlUHJveHlIYW5kbGVyID0gRGVsZWdhdGVQcm94eUhhbmRsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWxlZ2F0ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/delegate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/index.js":
/*!**************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/index.js ***!
  \**************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ../cross */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/cross/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./create-enhancement */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/create-enhancement.js\"), exports);\n__exportStar(__webpack_require__(/*! ./types */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/types.js\"), exports);\n__exportStar(__webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/utils.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHplbnN0YWNraHErcnVudGltZUAyLjIuNF9AcHJpc21hK2NsaWVudEA1LjE3LjBfcHJpc21hQDUuMTcuMF8vbm9kZV9tb2R1bGVzL0B6ZW5zdGFja2hxL3J1bnRpbWUvZW5oYW5jZW1lbnRzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQywySkFBVTtBQUMvQixhQUFhLG1CQUFPLENBQUMsMkxBQXNCO0FBQzNDLGFBQWEsbUJBQU8sQ0FBQyxpS0FBUztBQUM5QixhQUFhLG1CQUFPLENBQUMsaUtBQVM7QUFDOUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFyYmxpc20vbmV4dC1qcy8uL25vZGVfbW9kdWxlcy8ucG5wbS9AemVuc3RhY2tocStydW50aW1lQDIuMi40X0BwcmlzbWErY2xpZW50QDUuMTcuMF9wcmlzbWFANS4xNy4wXy9ub2RlX21vZHVsZXMvQHplbnN0YWNraHEvcnVudGltZS9lbmhhbmNlbWVudHMvaW5kZXguanM/ZDM4NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuLi9jcm9zc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY3JlYXRlLWVuaGFuY2VtZW50XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdXRpbHNcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/logger.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/logger.js ***!
  \***************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/* eslint-disable @typescript-eslint/no-explicit-any */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Logger = void 0;\n/**\n * A logger that uses an existing Prisma client to emit.\n */\nclass Logger {\n    constructor(prisma) {\n        this.prisma = prisma;\n        this.eventNames = [];\n        const engine = this.prisma._engine;\n        this.emitter = engine ? engine.logEmitter : undefined;\n        if (this.emitter) {\n            if (typeof this.emitter.eventNames === 'function') {\n                // Node.js\n                this.eventNames = this.emitter.eventNames();\n            }\n            else if ('events' in this.emitter && this.emitter.events && typeof this.emitter.events === 'object') {\n                // edge runtime\n                this.eventNames = Object.keys(this.emitter.events);\n            }\n            else {\n                this.eventNames = [];\n            }\n        }\n    }\n    /**\n     * Checks if a log level is enabled.\n     */\n    enabled(level) {\n        return !!this.eventNames.includes(level);\n    }\n    /**\n     * Generates a message with the given level.\n     */\n    log(level, message) {\n        var _a;\n        (_a = this.emitter) === null || _a === void 0 ? void 0 : _a.emit(level, {\n            timestamp: new Date(),\n            message,\n            target: 'zenstack',\n        });\n    }\n    /**\n     * Generates a log message with info level.\n     */\n    info(message) {\n        this.log('info', message);\n    }\n    /**\n     * Generates a log message with warn level.\n     */\n    warn(message) {\n        this.log('warn', message);\n    }\n    /**\n     * Generates a log message with error level.\n     */\n    error(message) {\n        this.log('error', message);\n    }\n}\nexports.Logger = Logger;\n//# sourceMappingURL=logger.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHplbnN0YWNraHErcnVudGltZUAyLjIuNF9AcHJpc21hK2NsaWVudEA1LjE3LjBfcHJpc21hQDUuMTcuMF8vbm9kZV9tb2R1bGVzL0B6ZW5zdGFja2hxL3J1bnRpbWUvZW5oYW5jZW1lbnRzL2xvZ2dlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFyYmxpc20vbmV4dC1qcy8uL25vZGVfbW9kdWxlcy8ucG5wbS9AemVuc3RhY2tocStydW50aW1lQDIuMi40X0BwcmlzbWErY2xpZW50QDUuMTcuMF9wcmlzbWFANS4xNy4wXy9ub2RlX21vZHVsZXMvQHplbnN0YWNraHEvcnVudGltZS9lbmhhbmNlbWVudHMvbG9nZ2VyLmpzPzQ5ZmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxvZ2dlciA9IHZvaWQgMDtcbi8qKlxuICogQSBsb2dnZXIgdGhhdCB1c2VzIGFuIGV4aXN0aW5nIFByaXNtYSBjbGllbnQgdG8gZW1pdC5cbiAqL1xuY2xhc3MgTG9nZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihwcmlzbWEpIHtcbiAgICAgICAgdGhpcy5wcmlzbWEgPSBwcmlzbWE7XG4gICAgICAgIHRoaXMuZXZlbnROYW1lcyA9IFtdO1xuICAgICAgICBjb25zdCBlbmdpbmUgPSB0aGlzLnByaXNtYS5fZW5naW5lO1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBlbmdpbmUgPyBlbmdpbmUubG9nRW1pdHRlciA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMuZW1pdHRlcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmVtaXR0ZXIuZXZlbnROYW1lcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIC8vIE5vZGUuanNcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50TmFtZXMgPSB0aGlzLmVtaXR0ZXIuZXZlbnROYW1lcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoJ2V2ZW50cycgaW4gdGhpcy5lbWl0dGVyICYmIHRoaXMuZW1pdHRlci5ldmVudHMgJiYgdHlwZW9mIHRoaXMuZW1pdHRlci5ldmVudHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgLy8gZWRnZSBydW50aW1lXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudE5hbWVzID0gT2JqZWN0LmtleXModGhpcy5lbWl0dGVyLmV2ZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50TmFtZXMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBsb2cgbGV2ZWwgaXMgZW5hYmxlZC5cbiAgICAgKi9cbiAgICBlbmFibGVkKGxldmVsKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuZXZlbnROYW1lcy5pbmNsdWRlcyhsZXZlbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIG1lc3NhZ2Ugd2l0aCB0aGUgZ2l2ZW4gbGV2ZWwuXG4gICAgICovXG4gICAgbG9nKGxldmVsLCBtZXNzYWdlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5lbWl0dGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW1pdChsZXZlbCwge1xuICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIHRhcmdldDogJ3plbnN0YWNrJyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIGxvZyBtZXNzYWdlIHdpdGggaW5mbyBsZXZlbC5cbiAgICAgKi9cbiAgICBpbmZvKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5sb2coJ2luZm8nLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgbG9nIG1lc3NhZ2Ugd2l0aCB3YXJuIGxldmVsLlxuICAgICAqL1xuICAgIHdhcm4obWVzc2FnZSkge1xuICAgICAgICB0aGlzLmxvZygnd2FybicsIG1lc3NhZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBsb2cgbWVzc2FnZSB3aXRoIGVycm9yIGxldmVsLlxuICAgICAqL1xuICAgIGVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5sb2coJ2Vycm9yJywgbWVzc2FnZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Mb2dnZXIgPSBMb2dnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dnZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/logger.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/omit.js":
/*!*************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/omit.js ***!
  \*************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.withOmit = void 0;\nconst cross_1 = __webpack_require__(/*! ../cross */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/cross/index.js\");\nconst proxy_1 = __webpack_require__(/*! ./proxy */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/proxy.js\");\n/**\n * Gets an enhanced Prisma client that supports `@omit` attribute.\n *\n * @private\n */\nfunction withOmit(prisma, options) {\n    return (0, proxy_1.makeProxy)(prisma, options.modelMeta, (_prisma, model) => new OmitHandler(_prisma, model, options), 'omit');\n}\nexports.withOmit = withOmit;\nclass OmitHandler extends proxy_1.DefaultPrismaProxyHandler {\n    constructor(prisma, model, options) {\n        super(prisma, model, options);\n    }\n    // base override\n    processResultEntity(data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (data) {\n                for (const value of (0, cross_1.enumerate)(data)) {\n                    yield this.doPostProcess(value, this.model);\n                }\n            }\n            return data;\n        });\n    }\n    doPostProcess(entityData, model) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            for (const field of (0, cross_1.getModelFields)(entityData)) {\n                const fieldInfo = yield (0, cross_1.resolveField)(this.options.modelMeta, model, field);\n                if (!fieldInfo) {\n                    continue;\n                }\n                const shouldOmit = (_a = fieldInfo.attributes) === null || _a === void 0 ? void 0 : _a.find((attr) => attr.name === '@omit');\n                if (shouldOmit) {\n                    delete entityData[field];\n                }\n                if (fieldInfo.isDataModel) {\n                    const items = fieldInfo.isArray && Array.isArray(entityData[field]) ? entityData[field] : [entityData[field]];\n                    for (const item of items) {\n                        // recurse\n                        yield this.doPostProcess(item, fieldInfo.type);\n                    }\n                }\n            }\n        });\n    }\n}\n//# sourceMappingURL=omit.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHplbnN0YWNraHErcnVudGltZUAyLjIuNF9AcHJpc21hK2NsaWVudEA1LjE3LjBfcHJpc21hQDUuMTcuMF8vbm9kZV9tb2R1bGVzL0B6ZW5zdGFja2hxL3J1bnRpbWUvZW5oYW5jZW1lbnRzL29taXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsZ0JBQWdCLG1CQUFPLENBQUMsMkpBQVU7QUFDbEMsZ0JBQWdCLG1CQUFPLENBQUMsaUtBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hcmJsaXNtL25leHQtanMvLi9ub2RlX21vZHVsZXMvLnBucG0vQHplbnN0YWNraHErcnVudGltZUAyLjIuNF9AcHJpc21hK2NsaWVudEA1LjE3LjBfcHJpc21hQDUuMTcuMF8vbm9kZV9tb2R1bGVzL0B6ZW5zdGFja2hxL3J1bnRpbWUvZW5oYW5jZW1lbnRzL29taXQuanM/ZGFkNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLndpdGhPbWl0ID0gdm9pZCAwO1xuY29uc3QgY3Jvc3NfMSA9IHJlcXVpcmUoXCIuLi9jcm9zc1wiKTtcbmNvbnN0IHByb3h5XzEgPSByZXF1aXJlKFwiLi9wcm94eVwiKTtcbi8qKlxuICogR2V0cyBhbiBlbmhhbmNlZCBQcmlzbWEgY2xpZW50IHRoYXQgc3VwcG9ydHMgYEBvbWl0YCBhdHRyaWJ1dGUuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gd2l0aE9taXQocHJpc21hLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuICgwLCBwcm94eV8xLm1ha2VQcm94eSkocHJpc21hLCBvcHRpb25zLm1vZGVsTWV0YSwgKF9wcmlzbWEsIG1vZGVsKSA9PiBuZXcgT21pdEhhbmRsZXIoX3ByaXNtYSwgbW9kZWwsIG9wdGlvbnMpLCAnb21pdCcpO1xufVxuZXhwb3J0cy53aXRoT21pdCA9IHdpdGhPbWl0O1xuY2xhc3MgT21pdEhhbmRsZXIgZXh0ZW5kcyBwcm94eV8xLkRlZmF1bHRQcmlzbWFQcm94eUhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKHByaXNtYSwgbW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIocHJpc21hLCBtb2RlbCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIGJhc2Ugb3ZlcnJpZGVcbiAgICBwcm9jZXNzUmVzdWx0RW50aXR5KGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiAoMCwgY3Jvc3NfMS5lbnVtZXJhdGUpKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZG9Qb3N0UHJvY2Vzcyh2YWx1ZSwgdGhpcy5tb2RlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkb1Bvc3RQcm9jZXNzKGVudGl0eURhdGEsIG1vZGVsKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mICgwLCBjcm9zc18xLmdldE1vZGVsRmllbGRzKShlbnRpdHlEYXRhKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkSW5mbyA9IHlpZWxkICgwLCBjcm9zc18xLnJlc29sdmVGaWVsZCkodGhpcy5vcHRpb25zLm1vZGVsTWV0YSwgbW9kZWwsIGZpZWxkKTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpZWxkSW5mbykge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkT21pdCA9IChfYSA9IGZpZWxkSW5mby5hdHRyaWJ1dGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmluZCgoYXR0cikgPT4gYXR0ci5uYW1lID09PSAnQG9taXQnKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkT21pdCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZW50aXR5RGF0YVtmaWVsZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmaWVsZEluZm8uaXNEYXRhTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBmaWVsZEluZm8uaXNBcnJheSAmJiBBcnJheS5pc0FycmF5KGVudGl0eURhdGFbZmllbGRdKSA/IGVudGl0eURhdGFbZmllbGRdIDogW2VudGl0eURhdGFbZmllbGRdXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWN1cnNlXG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmRvUG9zdFByb2Nlc3MoaXRlbSwgZmllbGRJbmZvLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vbWl0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/omit.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/password.js":
/*!*****************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/password.js ***!
  \*****************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/no-unused-vars */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.withPassword = void 0;\nconst constants_1 = __webpack_require__(/*! ../constants */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/constants.js\");\nconst cross_1 = __webpack_require__(/*! ../cross */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/cross/index.js\");\nconst proxy_1 = __webpack_require__(/*! ./proxy */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/proxy.js\");\n/**\n * Gets an enhanced Prisma client that supports `@password` attribute.\n *\n * @private\n */\nfunction withPassword(prisma, options) {\n    return (0, proxy_1.makeProxy)(prisma, options.modelMeta, (_prisma, model) => new PasswordHandler(_prisma, model, options), 'password');\n}\nexports.withPassword = withPassword;\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst hashFunc = typeof EdgeRuntime === 'string' ? (__webpack_require__(/*! bcryptjs */ \"(rsc)/./node_modules/.pnpm/bcryptjs@2.4.3/node_modules/bcryptjs/index.js\").hashSync) : (__webpack_require__(/*! bcryptjs */ \"(rsc)/./node_modules/.pnpm/bcryptjs@2.4.3/node_modules/bcryptjs/index.js\").hash);\nclass PasswordHandler extends proxy_1.DefaultPrismaProxyHandler {\n    constructor(prisma, model, options) {\n        super(prisma, model, options);\n    }\n    // base override\n    preprocessArgs(action, args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const actionsOfInterest = ['create', 'createMany', 'update', 'updateMany', 'upsert'];\n            if (args && args.data && actionsOfInterest.includes(action)) {\n                yield this.preprocessWritePayload(this.model, action, args);\n            }\n            return args;\n        });\n    }\n    preprocessWritePayload(model, action, args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const visitor = new cross_1.NestedWriteVisitor(this.options.modelMeta, {\n                field: (field, _action, data, context) => __awaiter(this, void 0, void 0, function* () {\n                    var _a, _b, _c;\n                    const pwdAttr = (_a = field.attributes) === null || _a === void 0 ? void 0 : _a.find((attr) => attr.name === '@password');\n                    if (pwdAttr && field.type === 'String') {\n                        // hash password value\n                        let salt = (_b = pwdAttr.args.find((arg) => arg.name === 'salt')) === null || _b === void 0 ? void 0 : _b.value;\n                        if (!salt) {\n                            salt = (_c = pwdAttr.args.find((arg) => arg.name === 'saltLength')) === null || _c === void 0 ? void 0 : _c.value;\n                        }\n                        if (!salt) {\n                            salt = constants_1.DEFAULT_PASSWORD_SALT_LENGTH;\n                        }\n                        context.parent[field.name] = yield hashFunc(data, salt);\n                    }\n                }),\n            });\n            yield visitor.visit(model, action, args);\n        });\n    }\n}\n//# sourceMappingURL=password.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHplbnN0YWNraHErcnVudGltZUAyLjIuNF9AcHJpc21hK2NsaWVudEA1LjE3LjBfcHJpc21hQDUuMTcuMF8vbm9kZV9tb2R1bGVzL0B6ZW5zdGFja2hxL3J1bnRpbWUvZW5oYW5jZW1lbnRzL3Bhc3N3b3JkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CO0FBQ3BCLG9CQUFvQixtQkFBTyxDQUFDLDZKQUFjO0FBQzFDLGdCQUFnQixtQkFBTyxDQUFDLDJKQUFVO0FBQ2xDLGdCQUFnQixtQkFBTyxDQUFDLGlLQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxtREFBbUQsMEhBQTRCLEdBQUcsc0hBQXdCO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXJibGlzbS9uZXh0LWpzLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B6ZW5zdGFja2hxK3J1bnRpbWVAMi4yLjRfQHByaXNtYStjbGllbnRANS4xNy4wX3ByaXNtYUA1LjE3LjBfL25vZGVfbW9kdWxlcy9AemVuc3RhY2tocS9ydW50aW1lL2VuaGFuY2VtZW50cy9wYXNzd29yZC5qcz9iMzllIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMud2l0aFBhc3N3b3JkID0gdm9pZCAwO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xuY29uc3QgY3Jvc3NfMSA9IHJlcXVpcmUoXCIuLi9jcm9zc1wiKTtcbmNvbnN0IHByb3h5XzEgPSByZXF1aXJlKFwiLi9wcm94eVwiKTtcbi8qKlxuICogR2V0cyBhbiBlbmhhbmNlZCBQcmlzbWEgY2xpZW50IHRoYXQgc3VwcG9ydHMgYEBwYXNzd29yZGAgYXR0cmlidXRlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHdpdGhQYXNzd29yZChwcmlzbWEsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKDAsIHByb3h5XzEubWFrZVByb3h5KShwcmlzbWEsIG9wdGlvbnMubW9kZWxNZXRhLCAoX3ByaXNtYSwgbW9kZWwpID0+IG5ldyBQYXNzd29yZEhhbmRsZXIoX3ByaXNtYSwgbW9kZWwsIG9wdGlvbnMpLCAncGFzc3dvcmQnKTtcbn1cbmV4cG9ydHMud2l0aFBhc3N3b3JkID0gd2l0aFBhc3N3b3JkO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXNcbmNvbnN0IGhhc2hGdW5jID0gdHlwZW9mIEVkZ2VSdW50aW1lID09PSAnc3RyaW5nJyA/IHJlcXVpcmUoJ2JjcnlwdGpzJykuaGFzaFN5bmMgOiByZXF1aXJlKCdiY3J5cHRqcycpLmhhc2g7XG5jbGFzcyBQYXNzd29yZEhhbmRsZXIgZXh0ZW5kcyBwcm94eV8xLkRlZmF1bHRQcmlzbWFQcm94eUhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKHByaXNtYSwgbW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIocHJpc21hLCBtb2RlbCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIGJhc2Ugb3ZlcnJpZGVcbiAgICBwcmVwcm9jZXNzQXJncyhhY3Rpb24sIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbnNPZkludGVyZXN0ID0gWydjcmVhdGUnLCAnY3JlYXRlTWFueScsICd1cGRhdGUnLCAndXBkYXRlTWFueScsICd1cHNlcnQnXTtcbiAgICAgICAgICAgIGlmIChhcmdzICYmIGFyZ3MuZGF0YSAmJiBhY3Rpb25zT2ZJbnRlcmVzdC5pbmNsdWRlcyhhY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5wcmVwcm9jZXNzV3JpdGVQYXlsb2FkKHRoaXMubW9kZWwsIGFjdGlvbiwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHByZXByb2Nlc3NXcml0ZVBheWxvYWQobW9kZWwsIGFjdGlvbiwgYXJncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgdmlzaXRvciA9IG5ldyBjcm9zc18xLk5lc3RlZFdyaXRlVmlzaXRvcih0aGlzLm9wdGlvbnMubW9kZWxNZXRhLCB7XG4gICAgICAgICAgICAgICAgZmllbGQ6IChmaWVsZCwgX2FjdGlvbiwgZGF0YSwgY29udGV4dCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHdkQXR0ciA9IChfYSA9IGZpZWxkLmF0dHJpYnV0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maW5kKChhdHRyKSA9PiBhdHRyLm5hbWUgPT09ICdAcGFzc3dvcmQnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHB3ZEF0dHIgJiYgZmllbGQudHlwZSA9PT0gJ1N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhc2ggcGFzc3dvcmQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzYWx0ID0gKF9iID0gcHdkQXR0ci5hcmdzLmZpbmQoKGFyZykgPT4gYXJnLm5hbWUgPT09ICdzYWx0JykpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2FsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhbHQgPSAoX2MgPSBwd2RBdHRyLmFyZ3MuZmluZCgoYXJnKSA9PiBhcmcubmFtZSA9PT0gJ3NhbHRMZW5ndGgnKSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzYWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2FsdCA9IGNvbnN0YW50c18xLkRFRkFVTFRfUEFTU1dPUkRfU0FMVF9MRU5HVEg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnBhcmVudFtmaWVsZC5uYW1lXSA9IHlpZWxkIGhhc2hGdW5jKGRhdGEsIHNhbHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHlpZWxkIHZpc2l0b3IudmlzaXQobW9kZWwsIGFjdGlvbiwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhc3N3b3JkLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/password.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/policy/constraint-solver.js":
/*!*********************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/policy/constraint-solver.js ***!
  \*********************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConstraintSolver = void 0;\nconst logic_solver_1 = __importDefault(__webpack_require__(/*! logic-solver */ \"(rsc)/./node_modules/.pnpm/logic-solver@2.0.1/node_modules/logic-solver/logic-solver.js\"));\nconst ts_pattern_1 = __webpack_require__(/*! ts-pattern */ \"(rsc)/./node_modules/.pnpm/ts-pattern@4.3.0/node_modules/ts-pattern/dist/index.cjs\");\n/**\n * A boolean constraint solver based on `logic-solver`. Only boolean and integer types are supported.\n */\nclass ConstraintSolver {\n    constructor() {\n        // a table for internalizing string literals\n        this.stringTable = [];\n        // a map for storing variable names and their corresponding formulas\n        this.variables = new Map();\n    }\n    /**\n     * Check the satisfiability of the given constraint.\n     */\n    checkSat(constraint) {\n        // reset state\n        this.stringTable = [];\n        this.variables = new Map();\n        // convert the constraint to a \"logic-solver\" formula\n        const formula = this.buildFormula(constraint);\n        // solve the formula\n        const solver = new logic_solver_1.default.Solver();\n        solver.require(formula);\n        // DEBUG:\n        // const solution = solver.solve();\n        // if (solution) {\n        //     console.log('Solution:');\n        //     this.variables.forEach((v, k) => console.log(`\\t${k}=${solution?.evaluate(v)}`));\n        // } else {\n        //     console.log('No solution');\n        // }\n        return !!solver.solve();\n    }\n    buildFormula(constraint) {\n        return (0, ts_pattern_1.match)(constraint)\n            .when((c) => c.kind === 'value', (c) => this.buildValueFormula(c))\n            .when((c) => c.kind === 'variable', (c) => this.buildVariableFormula(c))\n            .when((c) => ['eq', 'ne', 'gt', 'gte', 'lt', 'lte'].includes(c.kind), (c) => this.buildComparisonFormula(c))\n            .when((c) => ['and', 'or', 'not'].includes(c.kind), (c) => this.buildLogicalFormula(c))\n            .otherwise(() => {\n            throw new Error(`Unsupported constraint format: ${JSON.stringify(constraint)}`);\n        });\n    }\n    buildLogicalFormula(constraint) {\n        return (0, ts_pattern_1.match)(constraint.kind)\n            .with('and', () => this.buildAndFormula(constraint))\n            .with('or', () => this.buildOrFormula(constraint))\n            .with('not', () => this.buildNotFormula(constraint))\n            .exhaustive();\n    }\n    buildAndFormula(constraint) {\n        if (constraint.children.some((c) => this.isFalse(c))) {\n            // short-circuit\n            return logic_solver_1.default.FALSE;\n        }\n        return logic_solver_1.default.and(...constraint.children.map((c) => this.buildFormula(c)));\n    }\n    buildOrFormula(constraint) {\n        if (constraint.children.some((c) => this.isTrue(c))) {\n            // short-circuit\n            return logic_solver_1.default.TRUE;\n        }\n        return logic_solver_1.default.or(...constraint.children.map((c) => this.buildFormula(c)));\n    }\n    buildNotFormula(constraint) {\n        if (constraint.children.length !== 1) {\n            throw new Error('\"not\" constraint must have exactly one child');\n        }\n        return logic_solver_1.default.not(this.buildFormula(constraint.children[0]));\n    }\n    isTrue(constraint) {\n        return constraint.kind === 'value' && constraint.value === true;\n    }\n    isFalse(constraint) {\n        return constraint.kind === 'value' && constraint.value === false;\n    }\n    buildComparisonFormula(constraint) {\n        if (constraint.left.kind === 'value' && constraint.right.kind === 'value') {\n            // constant comparison\n            const left = constraint.left;\n            const right = constraint.right;\n            return (0, ts_pattern_1.match)(constraint.kind)\n                .with('eq', () => (left.value === right.value ? logic_solver_1.default.TRUE : logic_solver_1.default.FALSE))\n                .with('ne', () => (left.value !== right.value ? logic_solver_1.default.TRUE : logic_solver_1.default.FALSE))\n                .with('gt', () => (left.value > right.value ? logic_solver_1.default.TRUE : logic_solver_1.default.FALSE))\n                .with('gte', () => (left.value >= right.value ? logic_solver_1.default.TRUE : logic_solver_1.default.FALSE))\n                .with('lt', () => (left.value < right.value ? logic_solver_1.default.TRUE : logic_solver_1.default.FALSE))\n                .with('lte', () => (left.value <= right.value ? logic_solver_1.default.TRUE : logic_solver_1.default.FALSE))\n                .exhaustive();\n        }\n        return (0, ts_pattern_1.match)(constraint.kind)\n            .with('eq', () => this.transformEquality(constraint.left, constraint.right))\n            .with('ne', () => this.transformInequality(constraint.left, constraint.right))\n            .with('gt', () => this.transformComparison(constraint.left, constraint.right, (l, r) => logic_solver_1.default.greaterThan(l, r)))\n            .with('gte', () => this.transformComparison(constraint.left, constraint.right, (l, r) => logic_solver_1.default.greaterThanOrEqual(l, r)))\n            .with('lt', () => this.transformComparison(constraint.left, constraint.right, (l, r) => logic_solver_1.default.lessThan(l, r)))\n            .with('lte', () => this.transformComparison(constraint.left, constraint.right, (l, r) => logic_solver_1.default.lessThanOrEqual(l, r)))\n            .exhaustive();\n    }\n    buildVariableFormula(constraint) {\n        return ((0, ts_pattern_1.match)(constraint.type)\n            .with('boolean', () => this.booleanVariable(constraint.name))\n            .with('number', () => this.intVariable(constraint.name))\n            // strings are internalized and represented by their indices\n            .with('string', () => this.intVariable(constraint.name))\n            .exhaustive());\n    }\n    buildValueFormula(constraint) {\n        return (0, ts_pattern_1.match)(constraint.value)\n            .when((v) => typeof v === 'boolean', (v) => (v === true ? logic_solver_1.default.TRUE : logic_solver_1.default.FALSE))\n            .when((v) => typeof v === 'number', (v) => logic_solver_1.default.constantBits(v))\n            .when((v) => typeof v === 'string', (v) => {\n            // internalize the string and use its index as formula representation\n            const index = this.stringTable.indexOf(v);\n            if (index === -1) {\n                this.stringTable.push(v);\n                return logic_solver_1.default.constantBits(this.stringTable.length - 1);\n            }\n            else {\n                return logic_solver_1.default.constantBits(index);\n            }\n        })\n            .exhaustive();\n    }\n    booleanVariable(name) {\n        this.variables.set(name, name);\n        return name;\n    }\n    intVariable(name) {\n        const r = logic_solver_1.default.variableBits(name, 32);\n        this.variables.set(name, r);\n        return r;\n    }\n    transformEquality(left, right) {\n        if (left.type !== right.type) {\n            throw new Error(`Type mismatch in equality constraint: ${JSON.stringify(left)}, ${JSON.stringify(right)}`);\n        }\n        const leftFormula = this.buildFormula(left);\n        const rightFormula = this.buildFormula(right);\n        if (left.type === 'boolean' && right.type === 'boolean') {\n            // logical equivalence\n            return logic_solver_1.default.equiv(leftFormula, rightFormula);\n        }\n        else {\n            // integer equality\n            return logic_solver_1.default.equalBits(leftFormula, rightFormula);\n        }\n    }\n    transformInequality(left, right) {\n        return logic_solver_1.default.not(this.transformEquality(left, right));\n    }\n    transformComparison(left, right, func) {\n        return func(this.buildFormula(left), this.buildFormula(right));\n    }\n}\nexports.ConstraintSolver = ConstraintSolver;\n//# sourceMappingURL=constraint-solver.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHplbnN0YWNraHErcnVudGltZUAyLjIuNF9AcHJpc21hK2NsaWVudEA1LjE3LjBfcHJpc21hQDUuMTcuMF8vbm9kZV9tb2R1bGVzL0B6ZW5zdGFja2hxL3J1bnRpbWUvZW5oYW5jZW1lbnRzL3BvbGljeS9jb25zdHJhaW50LXNvbHZlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QjtBQUN4Qix1Q0FBdUMsbUJBQU8sQ0FBQyw2R0FBYztBQUM3RCxxQkFBcUIsbUJBQU8sQ0FBQyxzR0FBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLEVBQUUsR0FBRyxzQkFBc0I7QUFDNUYsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsMkJBQTJCO0FBQ3pGLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxxQkFBcUIsSUFBSSxzQkFBc0I7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFyYmxpc20vbmV4dC1qcy8uL25vZGVfbW9kdWxlcy8ucG5wbS9AemVuc3RhY2tocStydW50aW1lQDIuMi40X0BwcmlzbWErY2xpZW50QDUuMTcuMF9wcmlzbWFANS4xNy4wXy9ub2RlX21vZHVsZXMvQHplbnN0YWNraHEvcnVudGltZS9lbmhhbmNlbWVudHMvcG9saWN5L2NvbnN0cmFpbnQtc29sdmVyLmpzP2M2MTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbnN0cmFpbnRTb2x2ZXIgPSB2b2lkIDA7XG5jb25zdCBsb2dpY19zb2x2ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9naWMtc29sdmVyXCIpKTtcbmNvbnN0IHRzX3BhdHRlcm5fMSA9IHJlcXVpcmUoXCJ0cy1wYXR0ZXJuXCIpO1xuLyoqXG4gKiBBIGJvb2xlYW4gY29uc3RyYWludCBzb2x2ZXIgYmFzZWQgb24gYGxvZ2ljLXNvbHZlcmAuIE9ubHkgYm9vbGVhbiBhbmQgaW50ZWdlciB0eXBlcyBhcmUgc3VwcG9ydGVkLlxuICovXG5jbGFzcyBDb25zdHJhaW50U29sdmVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8gYSB0YWJsZSBmb3IgaW50ZXJuYWxpemluZyBzdHJpbmcgbGl0ZXJhbHNcbiAgICAgICAgdGhpcy5zdHJpbmdUYWJsZSA9IFtdO1xuICAgICAgICAvLyBhIG1hcCBmb3Igc3RvcmluZyB2YXJpYWJsZSBuYW1lcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBmb3JtdWxhc1xuICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhlIHNhdGlzZmlhYmlsaXR5IG9mIHRoZSBnaXZlbiBjb25zdHJhaW50LlxuICAgICAqL1xuICAgIGNoZWNrU2F0KGNvbnN0cmFpbnQpIHtcbiAgICAgICAgLy8gcmVzZXQgc3RhdGVcbiAgICAgICAgdGhpcy5zdHJpbmdUYWJsZSA9IFtdO1xuICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gY29udmVydCB0aGUgY29uc3RyYWludCB0byBhIFwibG9naWMtc29sdmVyXCIgZm9ybXVsYVxuICAgICAgICBjb25zdCBmb3JtdWxhID0gdGhpcy5idWlsZEZvcm11bGEoY29uc3RyYWludCk7XG4gICAgICAgIC8vIHNvbHZlIHRoZSBmb3JtdWxhXG4gICAgICAgIGNvbnN0IHNvbHZlciA9IG5ldyBsb2dpY19zb2x2ZXJfMS5kZWZhdWx0LlNvbHZlcigpO1xuICAgICAgICBzb2x2ZXIucmVxdWlyZShmb3JtdWxhKTtcbiAgICAgICAgLy8gREVCVUc6XG4gICAgICAgIC8vIGNvbnN0IHNvbHV0aW9uID0gc29sdmVyLnNvbHZlKCk7XG4gICAgICAgIC8vIGlmIChzb2x1dGlvbikge1xuICAgICAgICAvLyAgICAgY29uc29sZS5sb2coJ1NvbHV0aW9uOicpO1xuICAgICAgICAvLyAgICAgdGhpcy52YXJpYWJsZXMuZm9yRWFjaCgodiwgaykgPT4gY29uc29sZS5sb2coYFxcdCR7a309JHtzb2x1dGlvbj8uZXZhbHVhdGUodil9YCkpO1xuICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAvLyAgICAgY29uc29sZS5sb2coJ05vIHNvbHV0aW9uJyk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgcmV0dXJuICEhc29sdmVyLnNvbHZlKCk7XG4gICAgfVxuICAgIGJ1aWxkRm9ybXVsYShjb25zdHJhaW50KSB7XG4gICAgICAgIHJldHVybiAoMCwgdHNfcGF0dGVybl8xLm1hdGNoKShjb25zdHJhaW50KVxuICAgICAgICAgICAgLndoZW4oKGMpID0+IGMua2luZCA9PT0gJ3ZhbHVlJywgKGMpID0+IHRoaXMuYnVpbGRWYWx1ZUZvcm11bGEoYykpXG4gICAgICAgICAgICAud2hlbigoYykgPT4gYy5raW5kID09PSAndmFyaWFibGUnLCAoYykgPT4gdGhpcy5idWlsZFZhcmlhYmxlRm9ybXVsYShjKSlcbiAgICAgICAgICAgIC53aGVuKChjKSA9PiBbJ2VxJywgJ25lJywgJ2d0JywgJ2d0ZScsICdsdCcsICdsdGUnXS5pbmNsdWRlcyhjLmtpbmQpLCAoYykgPT4gdGhpcy5idWlsZENvbXBhcmlzb25Gb3JtdWxhKGMpKVxuICAgICAgICAgICAgLndoZW4oKGMpID0+IFsnYW5kJywgJ29yJywgJ25vdCddLmluY2x1ZGVzKGMua2luZCksIChjKSA9PiB0aGlzLmJ1aWxkTG9naWNhbEZvcm11bGEoYykpXG4gICAgICAgICAgICAub3RoZXJ3aXNlKCgpID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY29uc3RyYWludCBmb3JtYXQ6ICR7SlNPTi5zdHJpbmdpZnkoY29uc3RyYWludCl9YCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBidWlsZExvZ2ljYWxGb3JtdWxhKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgcmV0dXJuICgwLCB0c19wYXR0ZXJuXzEubWF0Y2gpKGNvbnN0cmFpbnQua2luZClcbiAgICAgICAgICAgIC53aXRoKCdhbmQnLCAoKSA9PiB0aGlzLmJ1aWxkQW5kRm9ybXVsYShjb25zdHJhaW50KSlcbiAgICAgICAgICAgIC53aXRoKCdvcicsICgpID0+IHRoaXMuYnVpbGRPckZvcm11bGEoY29uc3RyYWludCkpXG4gICAgICAgICAgICAud2l0aCgnbm90JywgKCkgPT4gdGhpcy5idWlsZE5vdEZvcm11bGEoY29uc3RyYWludCkpXG4gICAgICAgICAgICAuZXhoYXVzdGl2ZSgpO1xuICAgIH1cbiAgICBidWlsZEFuZEZvcm11bGEoY29uc3RyYWludCkge1xuICAgICAgICBpZiAoY29uc3RyYWludC5jaGlsZHJlbi5zb21lKChjKSA9PiB0aGlzLmlzRmFsc2UoYykpKSB7XG4gICAgICAgICAgICAvLyBzaG9ydC1jaXJjdWl0XG4gICAgICAgICAgICByZXR1cm4gbG9naWNfc29sdmVyXzEuZGVmYXVsdC5GQUxTRTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9naWNfc29sdmVyXzEuZGVmYXVsdC5hbmQoLi4uY29uc3RyYWludC5jaGlsZHJlbi5tYXAoKGMpID0+IHRoaXMuYnVpbGRGb3JtdWxhKGMpKSk7XG4gICAgfVxuICAgIGJ1aWxkT3JGb3JtdWxhKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgaWYgKGNvbnN0cmFpbnQuY2hpbGRyZW4uc29tZSgoYykgPT4gdGhpcy5pc1RydWUoYykpKSB7XG4gICAgICAgICAgICAvLyBzaG9ydC1jaXJjdWl0XG4gICAgICAgICAgICByZXR1cm4gbG9naWNfc29sdmVyXzEuZGVmYXVsdC5UUlVFO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dpY19zb2x2ZXJfMS5kZWZhdWx0Lm9yKC4uLmNvbnN0cmFpbnQuY2hpbGRyZW4ubWFwKChjKSA9PiB0aGlzLmJ1aWxkRm9ybXVsYShjKSkpO1xuICAgIH1cbiAgICBidWlsZE5vdEZvcm11bGEoY29uc3RyYWludCkge1xuICAgICAgICBpZiAoY29uc3RyYWludC5jaGlsZHJlbi5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCJub3RcIiBjb25zdHJhaW50IG11c3QgaGF2ZSBleGFjdGx5IG9uZSBjaGlsZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dpY19zb2x2ZXJfMS5kZWZhdWx0Lm5vdCh0aGlzLmJ1aWxkRm9ybXVsYShjb25zdHJhaW50LmNoaWxkcmVuWzBdKSk7XG4gICAgfVxuICAgIGlzVHJ1ZShjb25zdHJhaW50KSB7XG4gICAgICAgIHJldHVybiBjb25zdHJhaW50LmtpbmQgPT09ICd2YWx1ZScgJiYgY29uc3RyYWludC52YWx1ZSA9PT0gdHJ1ZTtcbiAgICB9XG4gICAgaXNGYWxzZShjb25zdHJhaW50KSB7XG4gICAgICAgIHJldHVybiBjb25zdHJhaW50LmtpbmQgPT09ICd2YWx1ZScgJiYgY29uc3RyYWludC52YWx1ZSA9PT0gZmFsc2U7XG4gICAgfVxuICAgIGJ1aWxkQ29tcGFyaXNvbkZvcm11bGEoY29uc3RyYWludCkge1xuICAgICAgICBpZiAoY29uc3RyYWludC5sZWZ0LmtpbmQgPT09ICd2YWx1ZScgJiYgY29uc3RyYWludC5yaWdodC5raW5kID09PSAndmFsdWUnKSB7XG4gICAgICAgICAgICAvLyBjb25zdGFudCBjb21wYXJpc29uXG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gY29uc3RyYWludC5sZWZ0O1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBjb25zdHJhaW50LnJpZ2h0O1xuICAgICAgICAgICAgcmV0dXJuICgwLCB0c19wYXR0ZXJuXzEubWF0Y2gpKGNvbnN0cmFpbnQua2luZClcbiAgICAgICAgICAgICAgICAud2l0aCgnZXEnLCAoKSA9PiAobGVmdC52YWx1ZSA9PT0gcmlnaHQudmFsdWUgPyBsb2dpY19zb2x2ZXJfMS5kZWZhdWx0LlRSVUUgOiBsb2dpY19zb2x2ZXJfMS5kZWZhdWx0LkZBTFNFKSlcbiAgICAgICAgICAgICAgICAud2l0aCgnbmUnLCAoKSA9PiAobGVmdC52YWx1ZSAhPT0gcmlnaHQudmFsdWUgPyBsb2dpY19zb2x2ZXJfMS5kZWZhdWx0LlRSVUUgOiBsb2dpY19zb2x2ZXJfMS5kZWZhdWx0LkZBTFNFKSlcbiAgICAgICAgICAgICAgICAud2l0aCgnZ3QnLCAoKSA9PiAobGVmdC52YWx1ZSA+IHJpZ2h0LnZhbHVlID8gbG9naWNfc29sdmVyXzEuZGVmYXVsdC5UUlVFIDogbG9naWNfc29sdmVyXzEuZGVmYXVsdC5GQUxTRSkpXG4gICAgICAgICAgICAgICAgLndpdGgoJ2d0ZScsICgpID0+IChsZWZ0LnZhbHVlID49IHJpZ2h0LnZhbHVlID8gbG9naWNfc29sdmVyXzEuZGVmYXVsdC5UUlVFIDogbG9naWNfc29sdmVyXzEuZGVmYXVsdC5GQUxTRSkpXG4gICAgICAgICAgICAgICAgLndpdGgoJ2x0JywgKCkgPT4gKGxlZnQudmFsdWUgPCByaWdodC52YWx1ZSA/IGxvZ2ljX3NvbHZlcl8xLmRlZmF1bHQuVFJVRSA6IGxvZ2ljX3NvbHZlcl8xLmRlZmF1bHQuRkFMU0UpKVxuICAgICAgICAgICAgICAgIC53aXRoKCdsdGUnLCAoKSA9PiAobGVmdC52YWx1ZSA8PSByaWdodC52YWx1ZSA/IGxvZ2ljX3NvbHZlcl8xLmRlZmF1bHQuVFJVRSA6IGxvZ2ljX3NvbHZlcl8xLmRlZmF1bHQuRkFMU0UpKVxuICAgICAgICAgICAgICAgIC5leGhhdXN0aXZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCB0c19wYXR0ZXJuXzEubWF0Y2gpKGNvbnN0cmFpbnQua2luZClcbiAgICAgICAgICAgIC53aXRoKCdlcScsICgpID0+IHRoaXMudHJhbnNmb3JtRXF1YWxpdHkoY29uc3RyYWludC5sZWZ0LCBjb25zdHJhaW50LnJpZ2h0KSlcbiAgICAgICAgICAgIC53aXRoKCduZScsICgpID0+IHRoaXMudHJhbnNmb3JtSW5lcXVhbGl0eShjb25zdHJhaW50LmxlZnQsIGNvbnN0cmFpbnQucmlnaHQpKVxuICAgICAgICAgICAgLndpdGgoJ2d0JywgKCkgPT4gdGhpcy50cmFuc2Zvcm1Db21wYXJpc29uKGNvbnN0cmFpbnQubGVmdCwgY29uc3RyYWludC5yaWdodCwgKGwsIHIpID0+IGxvZ2ljX3NvbHZlcl8xLmRlZmF1bHQuZ3JlYXRlclRoYW4obCwgcikpKVxuICAgICAgICAgICAgLndpdGgoJ2d0ZScsICgpID0+IHRoaXMudHJhbnNmb3JtQ29tcGFyaXNvbihjb25zdHJhaW50LmxlZnQsIGNvbnN0cmFpbnQucmlnaHQsIChsLCByKSA9PiBsb2dpY19zb2x2ZXJfMS5kZWZhdWx0LmdyZWF0ZXJUaGFuT3JFcXVhbChsLCByKSkpXG4gICAgICAgICAgICAud2l0aCgnbHQnLCAoKSA9PiB0aGlzLnRyYW5zZm9ybUNvbXBhcmlzb24oY29uc3RyYWludC5sZWZ0LCBjb25zdHJhaW50LnJpZ2h0LCAobCwgcikgPT4gbG9naWNfc29sdmVyXzEuZGVmYXVsdC5sZXNzVGhhbihsLCByKSkpXG4gICAgICAgICAgICAud2l0aCgnbHRlJywgKCkgPT4gdGhpcy50cmFuc2Zvcm1Db21wYXJpc29uKGNvbnN0cmFpbnQubGVmdCwgY29uc3RyYWludC5yaWdodCwgKGwsIHIpID0+IGxvZ2ljX3NvbHZlcl8xLmRlZmF1bHQubGVzc1RoYW5PckVxdWFsKGwsIHIpKSlcbiAgICAgICAgICAgIC5leGhhdXN0aXZlKCk7XG4gICAgfVxuICAgIGJ1aWxkVmFyaWFibGVGb3JtdWxhKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgcmV0dXJuICgoMCwgdHNfcGF0dGVybl8xLm1hdGNoKShjb25zdHJhaW50LnR5cGUpXG4gICAgICAgICAgICAud2l0aCgnYm9vbGVhbicsICgpID0+IHRoaXMuYm9vbGVhblZhcmlhYmxlKGNvbnN0cmFpbnQubmFtZSkpXG4gICAgICAgICAgICAud2l0aCgnbnVtYmVyJywgKCkgPT4gdGhpcy5pbnRWYXJpYWJsZShjb25zdHJhaW50Lm5hbWUpKVxuICAgICAgICAgICAgLy8gc3RyaW5ncyBhcmUgaW50ZXJuYWxpemVkIGFuZCByZXByZXNlbnRlZCBieSB0aGVpciBpbmRpY2VzXG4gICAgICAgICAgICAud2l0aCgnc3RyaW5nJywgKCkgPT4gdGhpcy5pbnRWYXJpYWJsZShjb25zdHJhaW50Lm5hbWUpKVxuICAgICAgICAgICAgLmV4aGF1c3RpdmUoKSk7XG4gICAgfVxuICAgIGJ1aWxkVmFsdWVGb3JtdWxhKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgcmV0dXJuICgwLCB0c19wYXR0ZXJuXzEubWF0Y2gpKGNvbnN0cmFpbnQudmFsdWUpXG4gICAgICAgICAgICAud2hlbigodikgPT4gdHlwZW9mIHYgPT09ICdib29sZWFuJywgKHYpID0+ICh2ID09PSB0cnVlID8gbG9naWNfc29sdmVyXzEuZGVmYXVsdC5UUlVFIDogbG9naWNfc29sdmVyXzEuZGVmYXVsdC5GQUxTRSkpXG4gICAgICAgICAgICAud2hlbigodikgPT4gdHlwZW9mIHYgPT09ICdudW1iZXInLCAodikgPT4gbG9naWNfc29sdmVyXzEuZGVmYXVsdC5jb25zdGFudEJpdHModikpXG4gICAgICAgICAgICAud2hlbigodikgPT4gdHlwZW9mIHYgPT09ICdzdHJpbmcnLCAodikgPT4ge1xuICAgICAgICAgICAgLy8gaW50ZXJuYWxpemUgdGhlIHN0cmluZyBhbmQgdXNlIGl0cyBpbmRleCBhcyBmb3JtdWxhIHJlcHJlc2VudGF0aW9uXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuc3RyaW5nVGFibGUuaW5kZXhPZih2KTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmluZ1RhYmxlLnB1c2godik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2ljX3NvbHZlcl8xLmRlZmF1bHQuY29uc3RhbnRCaXRzKHRoaXMuc3RyaW5nVGFibGUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9naWNfc29sdmVyXzEuZGVmYXVsdC5jb25zdGFudEJpdHMoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLmV4aGF1c3RpdmUoKTtcbiAgICB9XG4gICAgYm9vbGVhblZhcmlhYmxlKG5hbWUpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZXMuc2V0KG5hbWUsIG5hbWUpO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgaW50VmFyaWFibGUobmFtZSkge1xuICAgICAgICBjb25zdCByID0gbG9naWNfc29sdmVyXzEuZGVmYXVsdC52YXJpYWJsZUJpdHMobmFtZSwgMzIpO1xuICAgICAgICB0aGlzLnZhcmlhYmxlcy5zZXQobmFtZSwgcik7XG4gICAgICAgIHJldHVybiByO1xuICAgIH1cbiAgICB0cmFuc2Zvcm1FcXVhbGl0eShsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAobGVmdC50eXBlICE9PSByaWdodC50eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFR5cGUgbWlzbWF0Y2ggaW4gZXF1YWxpdHkgY29uc3RyYWludDogJHtKU09OLnN0cmluZ2lmeShsZWZ0KX0sICR7SlNPTi5zdHJpbmdpZnkocmlnaHQpfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlZnRGb3JtdWxhID0gdGhpcy5idWlsZEZvcm11bGEobGVmdCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0Rm9ybXVsYSA9IHRoaXMuYnVpbGRGb3JtdWxhKHJpZ2h0KTtcbiAgICAgICAgaWYgKGxlZnQudHlwZSA9PT0gJ2Jvb2xlYW4nICYmIHJpZ2h0LnR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgLy8gbG9naWNhbCBlcXVpdmFsZW5jZVxuICAgICAgICAgICAgcmV0dXJuIGxvZ2ljX3NvbHZlcl8xLmRlZmF1bHQuZXF1aXYobGVmdEZvcm11bGEsIHJpZ2h0Rm9ybXVsYSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpbnRlZ2VyIGVxdWFsaXR5XG4gICAgICAgICAgICByZXR1cm4gbG9naWNfc29sdmVyXzEuZGVmYXVsdC5lcXVhbEJpdHMobGVmdEZvcm11bGEsIHJpZ2h0Rm9ybXVsYSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJhbnNmb3JtSW5lcXVhbGl0eShsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gbG9naWNfc29sdmVyXzEuZGVmYXVsdC5ub3QodGhpcy50cmFuc2Zvcm1FcXVhbGl0eShsZWZ0LCByaWdodCkpO1xuICAgIH1cbiAgICB0cmFuc2Zvcm1Db21wYXJpc29uKGxlZnQsIHJpZ2h0LCBmdW5jKSB7XG4gICAgICAgIHJldHVybiBmdW5jKHRoaXMuYnVpbGRGb3JtdWxhKGxlZnQpLCB0aGlzLmJ1aWxkRm9ybXVsYShyaWdodCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29uc3RyYWludFNvbHZlciA9IENvbnN0cmFpbnRTb2x2ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdHJhaW50LXNvbHZlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/policy/constraint-solver.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/policy/handler.js":
/*!***********************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/policy/handler.js ***!
  \***********************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/* eslint-disable @typescript-eslint/no-explicit-any */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PolicyProxyHandler = void 0;\nconst deepmerge_1 = __importDefault(__webpack_require__(/*! deepmerge */ \"(rsc)/./node_modules/.pnpm/deepmerge@4.3.1/node_modules/deepmerge/dist/cjs.js\"));\nconst lower_case_first_1 = __webpack_require__(/*! lower-case-first */ \"(rsc)/./node_modules/.pnpm/lower-case-first@2.0.2/node_modules/lower-case-first/dist.es2015/index.js\");\nconst tiny_invariant_1 = __importDefault(__webpack_require__(/*! tiny-invariant */ \"(rsc)/./node_modules/.pnpm/tiny-invariant@1.3.3/node_modules/tiny-invariant/dist/tiny-invariant.cjs.js\"));\nconst ts_pattern_1 = __webpack_require__(/*! ts-pattern */ \"(rsc)/./node_modules/.pnpm/ts-pattern@4.3.0/node_modules/ts-pattern/dist/index.cjs\");\nconst upper_case_first_1 = __webpack_require__(/*! upper-case-first */ \"(rsc)/./node_modules/.pnpm/upper-case-first@2.0.2/node_modules/upper-case-first/dist.es2015/index.js\");\nconst zod_validation_error_1 = __webpack_require__(/*! zod-validation-error */ \"(rsc)/./node_modules/.pnpm/zod-validation-error@1.5.0_zod@3.23.8/node_modules/zod-validation-error/dist/esm/index.js\");\nconst constants_1 = __webpack_require__(/*! ../../constants */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/constants.js\");\nconst cross_1 = __webpack_require__(/*! ../../cross */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/cross/index.js\");\nconst logger_1 = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/logger.js\");\nconst promise_1 = __webpack_require__(/*! ../promise */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/promise.js\");\nconst query_utils_1 = __webpack_require__(/*! ../query-utils */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/query-utils.js\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/utils.js\");\nconst constraint_solver_1 = __webpack_require__(/*! ./constraint-solver */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/policy/constraint-solver.js\");\nconst policy_utils_1 = __webpack_require__(/*! ./policy-utils */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/policy/policy-utils.js\");\n/**\n * Prisma proxy handler for injecting access policy check.\n */\nclass PolicyProxyHandler {\n    constructor(prisma, model, options, context) {\n        this.prisma = prisma;\n        this.options = options;\n        this.context = context;\n        this.logger = new logger_1.Logger(prisma);\n        this.model = (0, lower_case_first_1.lowerCaseFirst)(model);\n        ({ modelMeta: this.modelMeta, prismaModule: this.prismaModule } = options);\n        this.policyUtils = new policy_utils_1.PolicyUtil(prisma, options, context, this.shouldLogQuery);\n        this.queryUtils = new query_utils_1.QueryUtils(prisma, options);\n    }\n    get modelClient() {\n        return this.prisma[this.model];\n    }\n    //#region Find\n    // find operations behaves as if the entities that don't match access policies don't exist\n    findUnique(args) {\n        if (!args) {\n            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.prismaModule, 'query argument is required');\n        }\n        if (!args.where) {\n            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.prismaModule, 'where field is required in query argument');\n        }\n        return this.findWithFluent('findUnique', args, () => null);\n    }\n    findUniqueOrThrow(args) {\n        if (!args) {\n            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.prismaModule, 'query argument is required');\n        }\n        if (!args.where) {\n            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.prismaModule, 'where field is required in query argument');\n        }\n        return this.findWithFluent('findUniqueOrThrow', args, () => {\n            throw this.policyUtils.notFound(this.model);\n        });\n    }\n    findFirst(args) {\n        return this.findWithFluent('findFirst', args, () => null);\n    }\n    findFirstOrThrow(args) {\n        return this.findWithFluent('findFirstOrThrow', args, () => {\n            throw this.policyUtils.notFound(this.model);\n        });\n    }\n    findMany(args) {\n        return (0, promise_1.createDeferredPromise)(() => this.doFind(args, 'findMany', () => []));\n    }\n    // make a find query promise with fluent API call stubs installed\n    findWithFluent(method, args, handleRejection) {\n        args = (0, utils_1.clone)(args);\n        return (0, promise_1.createFluentPromise)(() => this.doFind(args, method, handleRejection), args, this.options.modelMeta, this.model);\n    }\n    doFind(args, actionName, handleRejection) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const origArgs = args;\n            const _args = (0, utils_1.clone)(args);\n            if (!this.policyUtils.injectForRead(this.prisma, this.model, _args)) {\n                if (this.shouldLogQuery) {\n                    this.logger.info(`[policy] \\`${actionName}\\` ${this.model}: unconditionally denied`);\n                }\n                return handleRejection();\n            }\n            this.policyUtils.injectReadCheckSelect(this.model, _args);\n            if (this.shouldLogQuery) {\n                this.logger.info(`[policy] \\`${actionName}\\` ${this.model}:\\n${(0, utils_1.formatObject)(_args)}`);\n            }\n            const result = yield this.modelClient[actionName](_args);\n            return this.policyUtils.postProcessForRead(result, this.model, origArgs);\n        });\n    }\n    //#endregion\n    //#region Create\n    create(args) {\n        if (!args) {\n            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.prismaModule, 'query argument is required');\n        }\n        if (!args.data) {\n            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.prismaModule, 'data field is required in query argument');\n        }\n        return (0, promise_1.createDeferredPromise)(() => __awaiter(this, void 0, void 0, function* () {\n            this.policyUtils.tryReject(this.prisma, this.model, 'create');\n            const origArgs = args;\n            args = (0, utils_1.clone)(args);\n            // static input policy check for top-level create data\n            const inputCheck = this.policyUtils.checkInputGuard(this.model, args.data, 'create');\n            if (inputCheck === false) {\n                throw this.policyUtils.deniedByPolicy(this.model, 'create', undefined, constants_1.CrudFailureReason.ACCESS_POLICY_VIOLATION);\n            }\n            const hasNestedCreateOrConnect = yield this.hasNestedCreateOrConnect(args);\n            const { result, error } = yield this.queryUtils.transaction(this.prisma, (tx) => __awaiter(this, void 0, void 0, function* () {\n                if (\n                // MUST check true here since inputCheck can be undefined (meaning static input check not possible)\n                inputCheck === true &&\n                    // simple create: no nested create/connect\n                    !hasNestedCreateOrConnect) {\n                    // there's no nested write and we've passed input check, proceed with the create directly\n                    // validate zod schema if any\n                    args.data = this.validateCreateInputSchema(this.model, args.data);\n                    // make a create args only containing data and ID selection\n                    const createArgs = { data: args.data, select: this.policyUtils.makeIdSelection(this.model) };\n                    if (this.shouldLogQuery) {\n                        this.logger.info(`[policy] \\`create\\` ${this.model}: ${(0, utils_1.formatObject)(createArgs)}`);\n                    }\n                    const result = yield tx[this.model].create(createArgs);\n                    // filter the read-back data\n                    return this.policyUtils.readBack(tx, this.model, 'create', args, result);\n                }\n                else {\n                    // proceed with a complex create and collect post-write checks\n                    const { result, postWriteChecks } = yield this.doCreate(this.model, args, tx);\n                    // execute post-write checks\n                    yield this.runPostWriteChecks(postWriteChecks, tx);\n                    // filter the read-back data\n                    return this.policyUtils.readBack(tx, this.model, 'create', origArgs, result);\n                }\n            }));\n            if (error) {\n                throw error;\n            }\n            else {\n                return result;\n            }\n        }));\n    }\n    // create with nested write\n    doCreate(model, args, db) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // record id fields involved in the nesting context\n            const idSelections = [];\n            const pushIdFields = (model, context) => {\n                const idFields = (0, cross_1.getIdFields)(this.modelMeta, model);\n                idSelections.push({\n                    path: context.nestingPath.map((p) => p.field).filter((f) => !!f),\n                    ids: idFields.map((f) => f.name),\n                });\n            };\n            // create a string key that uniquely identifies an entity\n            const getEntityKey = (model, ids) => `${(0, upper_case_first_1.upperCaseFirst)(model)}#${Object.keys(ids)\n                .sort()\n                .map((f) => { var _a; return `${f}:${(_a = ids[f]) === null || _a === void 0 ? void 0 : _a.toString()}`; })\n                .join('_')}`;\n            // record keys of entities that are connected instead of created\n            const connectedEntities = new Set();\n            // visit the create payload\n            const visitor = new cross_1.NestedWriteVisitor(this.modelMeta, {\n                create: (model, args, context) => __awaiter(this, void 0, void 0, function* () {\n                    const validateResult = this.validateCreateInputSchema(model, args);\n                    if (validateResult !== args) {\n                        this.policyUtils.replace(args, validateResult);\n                    }\n                    pushIdFields(model, context);\n                }),\n                createMany: (model, args, context) => __awaiter(this, void 0, void 0, function* () {\n                    (0, cross_1.enumerate)(args.data).forEach((item) => {\n                        const r = this.validateCreateInputSchema(model, item);\n                        if (r !== item) {\n                            this.policyUtils.replace(item, r);\n                        }\n                    });\n                    pushIdFields(model, context);\n                }),\n                connectOrCreate: (model, args, context) => __awaiter(this, void 0, void 0, function* () {\n                    var _a;\n                    if (!args.where) {\n                        throw this.policyUtils.validationError(`'where' field is required for connectOrCreate`);\n                    }\n                    if (args.create) {\n                        args.create = this.validateCreateInputSchema(model, args.create);\n                    }\n                    const existing = yield this.policyUtils.checkExistence(db, model, args.where);\n                    if (existing) {\n                        // connect case\n                        if ((_a = context.field) === null || _a === void 0 ? void 0 : _a.backLink) {\n                            const backLinkField = (0, cross_1.resolveField)(this.modelMeta, model, context.field.backLink);\n                            if (backLinkField === null || backLinkField === void 0 ? void 0 : backLinkField.isRelationOwner) {\n                                // the target side of relation owns the relation,\n                                // check if it's updatable\n                                yield this.policyUtils.checkPolicyForUnique(model, args.where, 'update', db, args);\n                            }\n                        }\n                        this.mergeToParent(context.parent, 'connect', args.where);\n                        // record the key of connected entities so we can avoid validating them later\n                        connectedEntities.add(getEntityKey(model, existing));\n                    }\n                    else {\n                        // create case\n                        pushIdFields(model, context);\n                        // create a new \"create\" clause at the parent level\n                        this.mergeToParent(context.parent, 'create', args.create);\n                    }\n                    // remove the connectOrCreate clause\n                    this.removeFromParent(context.parent, 'connectOrCreate', args);\n                    // return false to prevent visiting the nested payload\n                    return false;\n                }),\n                connect: (model, args, context) => __awaiter(this, void 0, void 0, function* () {\n                    var _b;\n                    if (!args || typeof args !== 'object' || Object.keys(args).length === 0) {\n                        throw this.policyUtils.validationError(`'connect' field must be an non-empty object`);\n                    }\n                    if ((_b = context.field) === null || _b === void 0 ? void 0 : _b.backLink) {\n                        const backLinkField = (0, cross_1.resolveField)(this.modelMeta, model, context.field.backLink);\n                        if (backLinkField === null || backLinkField === void 0 ? void 0 : backLinkField.isRelationOwner) {\n                            // check existence\n                            yield this.policyUtils.checkExistence(db, model, args, true);\n                            // the target side of relation owns the relation,\n                            // check if it's updatable\n                            yield this.policyUtils.checkPolicyForUnique(model, args, 'update', db, args);\n                        }\n                    }\n                }),\n            });\n            yield visitor.visit(model, 'create', args);\n            // build the final \"select\" clause including all nested ID fields\n            let select = undefined;\n            if (idSelections.length > 0) {\n                select = {};\n                idSelections.forEach(({ path, ids }) => {\n                    let curr = select;\n                    for (const p of path) {\n                        if (!curr[p.name]) {\n                            curr[p.name] = { select: {} };\n                        }\n                        curr = curr[p.name].select;\n                    }\n                    Object.assign(curr, ...ids.map((f) => ({ [f]: true })));\n                });\n            }\n            // proceed with the create\n            const createArgs = { data: args.data, select };\n            if (this.shouldLogQuery) {\n                this.logger.info(`[policy] \\`create\\` ${model}: ${(0, utils_1.formatObject)(createArgs)}`);\n            }\n            const result = yield db[model].create(createArgs);\n            // post create policy check for the top-level and nested creates\n            const postCreateChecks = new Map();\n            // visit the create result and collect entities that need to be post-checked\n            const modelDataVisitor = new cross_1.ModelDataVisitor(this.modelMeta);\n            modelDataVisitor.visit(model, result, (model, _data, scalarData) => {\n                const key = getEntityKey(model, scalarData);\n                // only check if entity is created, not connected\n                if (!connectedEntities.has(key) && !postCreateChecks.has(key)) {\n                    const idFields = this.policyUtils.getIdFieldValues(model, scalarData);\n                    postCreateChecks.set(key, { model, operation: 'create', uniqueFilter: idFields });\n                }\n            });\n            // return only the ids of the top-level entity\n            const ids = this.policyUtils.getEntityIds(model, result);\n            return { result: ids, postWriteChecks: [...postCreateChecks.values()] };\n        });\n    }\n    // Checks if the given create payload has nested create or connect\n    hasNestedCreateOrConnect(args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let hasNestedCreateOrConnect = false;\n            const visitor = new cross_1.NestedWriteVisitor(this.modelMeta, {\n                create(_model, _args, context) {\n                    return __awaiter(this, void 0, void 0, function* () {\n                        if (context.field) {\n                            hasNestedCreateOrConnect = true;\n                            return false;\n                        }\n                        else {\n                            return true;\n                        }\n                    });\n                },\n                connect() {\n                    return __awaiter(this, void 0, void 0, function* () {\n                        hasNestedCreateOrConnect = true;\n                        return false;\n                    });\n                },\n                connectOrCreate() {\n                    return __awaiter(this, void 0, void 0, function* () {\n                        hasNestedCreateOrConnect = true;\n                        return false;\n                    });\n                },\n                createMany() {\n                    return __awaiter(this, void 0, void 0, function* () {\n                        hasNestedCreateOrConnect = true;\n                        return false;\n                    });\n                },\n            });\n            yield visitor.visit(this.model, 'create', args);\n            return hasNestedCreateOrConnect;\n        });\n    }\n    // Validates the given create payload against Zod schema if any\n    validateCreateInputSchema(model, data) {\n        const schema = this.policyUtils.getZodSchema(model, 'create');\n        if (schema && data) {\n            const parseResult = schema.safeParse(data);\n            if (!parseResult.success) {\n                throw this.policyUtils.deniedByPolicy(model, 'create', `input failed validation: ${(0, zod_validation_error_1.fromZodError)(parseResult.error)}`, constants_1.CrudFailureReason.DATA_VALIDATION_VIOLATION, parseResult.error);\n            }\n            return parseResult.data;\n        }\n        else {\n            return data;\n        }\n    }\n    createMany(args) {\n        if (!args) {\n            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.prismaModule, 'query argument is required');\n        }\n        if (!args.data) {\n            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.prismaModule, 'data field is required in query argument');\n        }\n        return (0, promise_1.createDeferredPromise)(() => __awaiter(this, void 0, void 0, function* () {\n            this.policyUtils.tryReject(this.prisma, this.model, 'create');\n            args = (0, utils_1.clone)(args);\n            // go through create items, statically check input to determine if post-create\n            // check is needed, and also validate zod schema\n            const needPostCreateCheck = this.validateCreateInput(args);\n            if (!needPostCreateCheck) {\n                // direct create\n                return this.modelClient.createMany(args);\n            }\n            else {\n                // create entities in a transaction with post-create checks\n                return this.queryUtils.transaction(this.prisma, (tx) => __awaiter(this, void 0, void 0, function* () {\n                    const { result, postWriteChecks } = yield this.doCreateMany(this.model, args, tx);\n                    // post-create check\n                    yield this.runPostWriteChecks(postWriteChecks, tx);\n                    return { count: result.length };\n                }));\n            }\n        }));\n    }\n    createManyAndReturn(args) {\n        if (!args) {\n            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.prismaModule, 'query argument is required');\n        }\n        if (!args.data) {\n            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.prismaModule, 'data field is required in query argument');\n        }\n        return (0, promise_1.createDeferredPromise)(() => __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            this.policyUtils.tryReject(this.prisma, this.model, 'create');\n            const origArgs = args;\n            args = (0, utils_1.clone)(args);\n            // go through create items, statically check input to determine if post-create\n            // check is needed, and also validate zod schema\n            const needPostCreateCheck = this.validateCreateInput(args);\n            let result;\n            if (!needPostCreateCheck) {\n                // direct create\n                const created = yield this.modelClient.createManyAndReturn(args);\n                // process read-back\n                result = yield Promise.all(created.map((item) => this.policyUtils.readBack(this.prisma, this.model, 'create', origArgs, item)));\n            }\n            else {\n                // create entities in a transaction with post-create checks\n                result = yield this.queryUtils.transaction(this.prisma, (tx) => __awaiter(this, void 0, void 0, function* () {\n                    const { result: created, postWriteChecks } = yield this.doCreateMany(this.model, args, tx);\n                    // post-create check\n                    yield this.runPostWriteChecks(postWriteChecks, tx);\n                    // process read-back\n                    return Promise.all(created.map((item) => this.policyUtils.readBack(tx, this.model, 'create', origArgs, item)));\n                }));\n            }\n            // throw read-back error if any of create result read-back fails\n            const error = (_a = result.find((r) => !!r.error)) === null || _a === void 0 ? void 0 : _a.error;\n            if (error) {\n                throw error;\n            }\n            else {\n                return result.map((r) => r.result);\n            }\n        }));\n    }\n    validateCreateInput(args) {\n        let needPostCreateCheck = false;\n        for (const item of (0, cross_1.enumerate)(args.data)) {\n            const validationResult = this.validateCreateInputSchema(this.model, item);\n            if (validationResult !== item) {\n                this.policyUtils.replace(item, validationResult);\n            }\n            const inputCheck = this.policyUtils.checkInputGuard(this.model, item, 'create');\n            if (inputCheck === false) {\n                // unconditionally deny\n                throw this.policyUtils.deniedByPolicy(this.model, 'create', undefined, constants_1.CrudFailureReason.ACCESS_POLICY_VIOLATION);\n            }\n            else if (inputCheck === true) {\n                // unconditionally allow\n            }\n            else if (inputCheck === undefined) {\n                // static policy check is not possible, need to do post-create check\n                needPostCreateCheck = true;\n            }\n        }\n        return needPostCreateCheck;\n    }\n    doCreateMany(model, args, db) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // We can't call the native \"createMany\" because we can't get back what was created\n            // for post-create checks. Instead, do a \"create\" for each item and collect the results.\n            let createResult = yield Promise.all((0, cross_1.enumerate)(args.data).map((item) => __awaiter(this, void 0, void 0, function* () {\n                if (args.skipDuplicates) {\n                    if (yield this.hasDuplicatedUniqueConstraint(model, item, undefined, db)) {\n                        if (this.shouldLogQuery) {\n                            this.logger.info(`[policy] \\`createMany\\` skipping duplicate ${(0, utils_1.formatObject)(item)}`);\n                        }\n                        return undefined;\n                    }\n                }\n                if (this.shouldLogQuery) {\n                    this.logger.info(`[policy] \\`create\\` for \\`createMany\\` ${model}: ${(0, utils_1.formatObject)(item)}`);\n                }\n                return yield db[model].create({ select: this.policyUtils.makeIdSelection(model), data: item });\n            })));\n            // filter undefined values due to skipDuplicates\n            createResult = createResult.filter((p) => !!p);\n            return {\n                result: createResult,\n                postWriteChecks: createResult.map((item) => ({\n                    model,\n                    operation: 'create',\n                    uniqueFilter: item,\n                })),\n            };\n        });\n    }\n    hasDuplicatedUniqueConstraint(model, createData, upstreamQuery, db) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // check unique constraint conflicts\n            // we can't rely on try/catch/ignore constraint violation error: https://github.com/prisma/prisma/issues/20496\n            // TODO: for simple cases we should be able to translate it to an `upsert` with empty `update` payload\n            var _a;\n            // for each unique constraint, check if the input item has all fields set, and if so, check if\n            // an entity already exists, and ignore accordingly\n            const uniqueConstraints = this.policyUtils.getUniqueConstraints(model);\n            for (const constraint of Object.values(uniqueConstraints)) {\n                // the unique filter used to check existence\n                const uniqueFilter = {};\n                // unique constraint fields not covered yet\n                const remainingConstraintFields = new Set(constraint.fields);\n                // collect constraint fields from the create data\n                for (const [k, v] of Object.entries(createData)) {\n                    if (v === undefined) {\n                        continue;\n                    }\n                    if (remainingConstraintFields.has(k)) {\n                        uniqueFilter[k] = v;\n                        remainingConstraintFields.delete(k);\n                    }\n                }\n                // collect constraint fields from the upstream query\n                if (upstreamQuery) {\n                    for (const [k, v] of Object.entries(upstreamQuery)) {\n                        if (v === undefined) {\n                            continue;\n                        }\n                        if (remainingConstraintFields.has(k)) {\n                            uniqueFilter[k] = v;\n                            remainingConstraintFields.delete(k);\n                            continue;\n                        }\n                        // check if the upstream query contains a relation field which covers\n                        // a foreign key field constraint\n                        const fieldInfo = (0, cross_1.requireField)(this.modelMeta, model, k);\n                        if (!fieldInfo.isDataModel) {\n                            // only care about relation fields\n                            continue;\n                        }\n                        // merge the upstream query into the unique filter\n                        uniqueFilter[k] = v;\n                        // mark the corresponding foreign key fields as covered\n                        const fkMapping = (_a = fieldInfo.foreignKeyMapping) !== null && _a !== void 0 ? _a : {};\n                        for (const fk of Object.values(fkMapping)) {\n                            remainingConstraintFields.delete(fk);\n                        }\n                    }\n                }\n                if (remainingConstraintFields.size === 0) {\n                    // all constraint fields set, check existence\n                    const existing = yield this.policyUtils.checkExistence(db, model, uniqueFilter);\n                    if (existing) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        });\n    }\n    //#endregion\n    //#region Update & Upsert\n    // \"update\" and \"upsert\" work against unique entity, so we actively rejects the request if the\n    // entity fails policy check\n    //\n    // \"updateMany\" works against a set of entities, entities not passing policy check are silently\n    // ignored\n    update(args) {\n        if (!args) {\n            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.prismaModule, 'query argument is required');\n        }\n        if (!args.where) {\n            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.prismaModule, 'where field is required in query argument');\n        }\n        if (!args.data) {\n            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.prismaModule, 'data field is required in query argument');\n        }\n        return (0, promise_1.createDeferredPromise)(() => __awaiter(this, void 0, void 0, function* () {\n            args = (0, utils_1.clone)(args);\n            const { result, error } = yield this.queryUtils.transaction(this.prisma, (tx) => __awaiter(this, void 0, void 0, function* () {\n                // proceed with nested writes and collect post-write checks\n                const { result, postWriteChecks } = yield this.doUpdate(args, tx);\n                // post-write check\n                yield this.runPostWriteChecks(postWriteChecks, tx);\n                // filter the read-back data\n                return this.policyUtils.readBack(tx, this.model, 'update', args, result);\n            }));\n            if (error) {\n                throw error;\n            }\n            else {\n                return result;\n            }\n        }));\n    }\n    doUpdate(args, db) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // collected post-update checks\n            const postWriteChecks = [];\n            // registers a post-update check task\n            const _registerPostUpdateCheck = (model, preUpdateLookupFilter, postUpdateLookupFilter) => __awaiter(this, void 0, void 0, function* () {\n                // both \"post-update\" rules and Zod schemas require a post-update check\n                if (this.policyUtils.hasAuthGuard(model, 'postUpdate') || this.policyUtils.getZodSchema(model)) {\n                    // select pre-update field values\n                    let preValue;\n                    const preValueSelect = this.policyUtils.getPreValueSelect(model);\n                    if (preValueSelect && Object.keys(preValueSelect).length > 0) {\n                        preValue = yield db[model].findFirst({ where: preUpdateLookupFilter, select: preValueSelect });\n                    }\n                    postWriteChecks.push({\n                        model,\n                        operation: 'postUpdate',\n                        uniqueFilter: postUpdateLookupFilter,\n                        preValue,\n                    });\n                }\n            });\n            // We can't let the native \"update\" to handle nested \"create\" because we can't get back what\n            // was created for doing post-update checks.\n            // Instead, handle nested create inside update as an atomic operation that creates an entire\n            // subtree (containing nested creates/connects)\n            const _create = (model, args, context) => __awaiter(this, void 0, void 0, function* () {\n                var _a;\n                let createData = args;\n                if ((_a = context.field) === null || _a === void 0 ? void 0 : _a.backLink) {\n                    // Check if the create payload contains any \"unsafe\" assignment:\n                    // assign id or foreign key fields.\n                    //\n                    // The reason why we need to do that is Prisma's mutations payload\n                    // structure has two mutually exclusive forms for safe and unsafe\n                    // operations. E.g.:\n                    //     - safe: { data: { user: { connect: { id: 1 }} } }\n                    //     - unsafe: { data: { userId: 1 } }\n                    const unsafe = (0, utils_1.isUnsafeMutate)(model, args, this.modelMeta);\n                    // handles the connection to upstream entity\n                    const reversedQuery = this.policyUtils.buildReversedQuery(context, true, unsafe);\n                    if ((!unsafe || context.field.isRelationOwner) && reversedQuery[context.field.backLink]) {\n                        // if mutation is safe, or current field owns the relation (so the other side has no fk),\n                        // and the reverse query contains the back link, then we can build a \"connect\" with it\n                        createData = Object.assign(Object.assign({}, createData), { [context.field.backLink]: {\n                                connect: reversedQuery[context.field.backLink],\n                            } });\n                    }\n                    else {\n                        // otherwise, the reverse query should be translated to foreign key setting\n                        // and merged to the create data\n                        const backLinkField = this.requireBackLink(context.field);\n                        (0, tiny_invariant_1.default)(backLinkField.foreignKeyMapping);\n                        // try to extract foreign key values from the reverse query\n                        let fkValues = Object.values(backLinkField.foreignKeyMapping).reduce((obj, fk) => {\n                            obj[fk] = reversedQuery[fk];\n                            return obj;\n                        }, {});\n                        if (Object.values(fkValues).every((v) => v !== undefined)) {\n                            // all foreign key values are available, merge them to the create data\n                            createData = Object.assign(Object.assign({}, createData), fkValues);\n                        }\n                        else {\n                            // some foreign key values are missing, need to look up the upstream entity,\n                            // this can happen when the upstream entity doesn't have a unique where clause,\n                            // for example when it's nested inside a one-to-one update\n                            const upstreamQuery = {\n                                where: reversedQuery[backLinkField.name],\n                                select: this.policyUtils.makeIdSelection(backLinkField.type),\n                            };\n                            // fetch the upstream entity\n                            if (this.shouldLogQuery) {\n                                this.logger.info(`[policy] \\`findUniqueOrThrow\\` ${model}: looking up upstream entity of ${backLinkField.type}, ${(0, utils_1.formatObject)(upstreamQuery)}`);\n                            }\n                            const upstreamEntity = yield this.prisma[backLinkField.type].findUniqueOrThrow(upstreamQuery);\n                            // map ids to foreign keys\n                            fkValues = Object.entries(backLinkField.foreignKeyMapping).reduce((obj, [id, fk]) => {\n                                obj[fk] = upstreamEntity[id];\n                                return obj;\n                            }, {});\n                            // merge them to the create data\n                            createData = Object.assign(Object.assign({}, createData), fkValues);\n                        }\n                    }\n                }\n                // proceed with the create and collect post-create checks\n                const { postWriteChecks: checks, result } = yield this.doCreate(model, { data: createData }, db);\n                postWriteChecks.push(...checks);\n                return result;\n            });\n            const _createMany = (model, args, context) => __awaiter(this, void 0, void 0, function* () {\n                for (const item of (0, cross_1.enumerate)(args.data)) {\n                    if (args.skipDuplicates) {\n                        // get a reversed query to include fields inherited from upstream mutation,\n                        // it'll be merged with the create payload for unique constraint checking\n                        const upstreamQuery = this.policyUtils.buildReversedQuery(context);\n                        if (yield this.hasDuplicatedUniqueConstraint(model, item, upstreamQuery, db)) {\n                            if (this.shouldLogQuery) {\n                                this.logger.info(`[policy] \\`createMany\\` skipping duplicate ${(0, utils_1.formatObject)(item)}`);\n                            }\n                            continue;\n                        }\n                    }\n                    yield _create(model, item, context);\n                }\n            });\n            const _connectDisconnect = (model, args, context, operation) => __awaiter(this, void 0, void 0, function* () {\n                var _b;\n                if ((_b = context.field) === null || _b === void 0 ? void 0 : _b.backLink) {\n                    const backLinkField = this.policyUtils.getModelField(model, context.field.backLink);\n                    if (backLinkField === null || backLinkField === void 0 ? void 0 : backLinkField.isRelationOwner) {\n                        let uniqueFilter = args;\n                        if (operation === 'disconnect') {\n                            // disconnect filter is not unique, need to build a reversed query to\n                            // locate the entity and use its id fields as unique filter\n                            const reversedQuery = this.policyUtils.buildReversedQuery(context);\n                            const found = yield db[model].findUnique({\n                                where: reversedQuery,\n                                select: this.policyUtils.makeIdSelection(model),\n                            });\n                            uniqueFilter = found && this.policyUtils.getIdFieldValues(model, found);\n                        }\n                        // update happens on the related model, require updatable,\n                        // translate args to foreign keys so field-level policies can be checked\n                        const checkArgs = {};\n                        if (args && typeof args === 'object' && backLinkField.foreignKeyMapping) {\n                            for (const key of Object.keys(args)) {\n                                const fk = backLinkField.foreignKeyMapping[key];\n                                if (fk) {\n                                    checkArgs[fk] = args[key];\n                                }\n                            }\n                        }\n                        // `uniqueFilter` can be undefined if the entity to be disconnected doesn't exist\n                        if (uniqueFilter) {\n                            // check for update\n                            yield this.policyUtils.checkPolicyForUnique(model, uniqueFilter, 'update', db, checkArgs);\n                            // register post-update check\n                            yield _registerPostUpdateCheck(model, uniqueFilter, uniqueFilter);\n                        }\n                    }\n                }\n            });\n            // visit nested writes\n            const visitor = new cross_1.NestedWriteVisitor(this.modelMeta, {\n                update: (model, args, context) => __awaiter(this, void 0, void 0, function* () {\n                    var _c;\n                    // build a unique query including upstream conditions\n                    const uniqueFilter = this.policyUtils.buildReversedQuery(context);\n                    // handle not-found\n                    const existing = yield this.policyUtils.checkExistence(db, model, uniqueFilter, true);\n                    // check if the update actually writes to this model\n                    let thisModelUpdate = false;\n                    const updatePayload = (_c = args.data) !== null && _c !== void 0 ? _c : args;\n                    const validatedPayload = this.validateUpdateInputSchema(model, updatePayload);\n                    if (validatedPayload !== updatePayload) {\n                        this.policyUtils.replace(updatePayload, validatedPayload);\n                    }\n                    if (updatePayload) {\n                        for (const key of Object.keys(updatePayload)) {\n                            const field = (0, cross_1.resolveField)(this.modelMeta, model, key);\n                            if (field) {\n                                if (!field.isDataModel) {\n                                    // scalar field, require this model to be updatable\n                                    thisModelUpdate = true;\n                                    break;\n                                }\n                                else if (field.isRelationOwner) {\n                                    // relation is being updated and this model owns foreign key, require updatable\n                                    thisModelUpdate = true;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    if (thisModelUpdate) {\n                        this.policyUtils.tryReject(db, this.model, 'update');\n                        // check pre-update guard\n                        yield this.policyUtils.checkPolicyForUnique(model, uniqueFilter, 'update', db, args);\n                        // handle the case where id fields are updated\n                        const _args = args;\n                        const updatePayload = _args.data && typeof _args.data === 'object' ? _args.data : _args;\n                        const postUpdateIds = this.calculatePostUpdateIds(model, existing, updatePayload);\n                        // register post-update check\n                        yield _registerPostUpdateCheck(model, existing, postUpdateIds);\n                    }\n                }),\n                updateMany: (model, args, context) => __awaiter(this, void 0, void 0, function* () {\n                    // prepare for post-update check\n                    if (this.policyUtils.hasAuthGuard(model, 'postUpdate') || this.policyUtils.getZodSchema(model)) {\n                        let select = this.policyUtils.makeIdSelection(model);\n                        const preValueSelect = this.policyUtils.getPreValueSelect(model);\n                        if (preValueSelect) {\n                            select = Object.assign(Object.assign({}, select), preValueSelect);\n                        }\n                        const reversedQuery = this.policyUtils.buildReversedQuery(context);\n                        const currentSetQuery = { select, where: reversedQuery };\n                        this.policyUtils.injectAuthGuardAsWhere(db, currentSetQuery, model, 'read');\n                        if (this.shouldLogQuery) {\n                            this.logger.info(`[policy] \\`findMany\\` for post update check ${model}:\\n${(0, utils_1.formatObject)(currentSetQuery)}`);\n                        }\n                        const currentSet = yield db[model].findMany(currentSetQuery);\n                        postWriteChecks.push(...currentSet.map((preValue) => ({\n                            model,\n                            operation: 'postUpdate',\n                            uniqueFilter: preValue,\n                            preValue: preValueSelect ? preValue : undefined,\n                        })));\n                    }\n                    args.data = this.validateUpdateInputSchema(model, args.data);\n                    const updateGuard = this.policyUtils.getAuthGuard(db, model, 'update');\n                    if (this.policyUtils.isTrue(updateGuard) || this.policyUtils.isFalse(updateGuard)) {\n                        // injects simple auth guard into where clause\n                        this.policyUtils.injectAuthGuardAsWhere(db, args, model, 'update');\n                    }\n                    else {\n                        // we have to process `updateMany` separately because the guard may contain\n                        // filters using relation fields which are not allowed in nested `updateMany`\n                        const reversedQuery = this.policyUtils.buildReversedQuery(context);\n                        const updateWhere = this.policyUtils.and(reversedQuery, updateGuard);\n                        if (this.shouldLogQuery) {\n                            this.logger.info(`[policy] \\`updateMany\\` ${model}:\\n${(0, utils_1.formatObject)({\n                                where: updateWhere,\n                                data: args.data,\n                            })}`);\n                        }\n                        yield db[model].updateMany({ where: updateWhere, data: args.data });\n                        delete context.parent.updateMany;\n                    }\n                }),\n                create: (model, args, context) => __awaiter(this, void 0, void 0, function* () {\n                    // process the entire create subtree separately\n                    yield _create(model, args, context);\n                    // remove it from the update payload\n                    this.removeFromParent(context.parent, 'create', args);\n                    // don't visit payload\n                    return false;\n                }),\n                createMany: (model, args, context) => __awaiter(this, void 0, void 0, function* () {\n                    // process createMany separately\n                    yield _createMany(model, args, context);\n                    // remove it from the update payload\n                    delete context.parent.createMany;\n                    // don't visit payload\n                    return false;\n                }),\n                upsert: (model, args, context) => __awaiter(this, void 0, void 0, function* () {\n                    // build a unique query including upstream conditions\n                    const uniqueFilter = this.policyUtils.buildReversedQuery(context);\n                    // branch based on if the update target exists\n                    const existing = yield this.policyUtils.checkExistence(db, model, uniqueFilter);\n                    if (existing) {\n                        // update case\n                        // check pre-update guard\n                        yield this.policyUtils.checkPolicyForUnique(model, existing, 'update', db, args);\n                        // handle the case where id fields are updated\n                        const postUpdateIds = this.calculatePostUpdateIds(model, existing, args.update);\n                        // register post-update check\n                        yield _registerPostUpdateCheck(model, existing, postUpdateIds);\n                        // convert upsert to update\n                        const convertedUpdate = {\n                            where: args.where,\n                            data: this.validateUpdateInputSchema(model, args.update),\n                        };\n                        this.mergeToParent(context.parent, 'update', convertedUpdate);\n                        this.removeFromParent(context.parent, 'upsert', args);\n                        // continue visiting the new payload\n                        return convertedUpdate;\n                    }\n                    else {\n                        // create case\n                        // process the entire create subtree separately\n                        yield _create(model, args.create, context);\n                        // remove it from the update payload\n                        this.removeFromParent(context.parent, 'upsert', args);\n                        // don't visit payload\n                        return false;\n                    }\n                }),\n                connect: (model, args, context) => __awaiter(this, void 0, void 0, function* () { return _connectDisconnect(model, args, context, 'connect'); }),\n                connectOrCreate: (model, args, context) => __awaiter(this, void 0, void 0, function* () {\n                    // the where condition is already unique, so we can use it to check if the target exists\n                    const existing = yield this.policyUtils.checkExistence(db, model, args.where);\n                    if (existing) {\n                        // connect\n                        yield _connectDisconnect(model, args.where, context, 'connect');\n                        return true;\n                    }\n                    else {\n                        // create\n                        const created = yield _create(model, args.create, context);\n                        const upperContext = context.nestingPath[context.nestingPath.length - 2];\n                        if ((upperContext === null || upperContext === void 0 ? void 0 : upperContext.where) && context.field) {\n                            // check if the where clause of the upper context references the id\n                            // of the connected entity, if so, we need to update it\n                            this.overrideForeignKeyFields(upperContext.model, upperContext.where, context.field, created);\n                        }\n                        // remove the payload from the parent\n                        this.removeFromParent(context.parent, 'connectOrCreate', args);\n                        return false;\n                    }\n                }),\n                disconnect: (model, args, context) => __awaiter(this, void 0, void 0, function* () { return _connectDisconnect(model, args, context, 'disconnect'); }),\n                set: (model, args, context) => __awaiter(this, void 0, void 0, function* () {\n                    // find the set of items to be replaced\n                    const reversedQuery = this.policyUtils.buildReversedQuery(context);\n                    const findCurrSetArgs = {\n                        select: this.policyUtils.makeIdSelection(model),\n                        where: reversedQuery,\n                    };\n                    if (this.shouldLogQuery) {\n                        this.logger.info(`[policy] \\`findMany\\` ${model}:\\n${(0, utils_1.formatObject)(findCurrSetArgs)}`);\n                    }\n                    const currentSet = yield db[model].findMany(findCurrSetArgs);\n                    // register current set for update (foreign key)\n                    yield Promise.all(currentSet.map((item) => _connectDisconnect(model, item, context, 'disconnect')));\n                    // proceed with connecting the new set\n                    yield Promise.all((0, cross_1.enumerate)(args).map((item) => _connectDisconnect(model, item, context, 'connect')));\n                }),\n                delete: (model, args, context) => __awaiter(this, void 0, void 0, function* () {\n                    // build a unique query including upstream conditions\n                    const uniqueFilter = this.policyUtils.buildReversedQuery(context);\n                    // handle not-found\n                    yield this.policyUtils.checkExistence(db, model, uniqueFilter, true);\n                    // check delete guard\n                    yield this.policyUtils.checkPolicyForUnique(model, uniqueFilter, 'delete', db, args);\n                }),\n                deleteMany: (model, args, context) => __awaiter(this, void 0, void 0, function* () {\n                    const guard = yield this.policyUtils.getAuthGuard(db, model, 'delete');\n                    if (this.policyUtils.isTrue(guard) || this.policyUtils.isFalse(guard)) {\n                        // inject simple auth guard\n                        context.parent.deleteMany = this.policyUtils.and(args, guard);\n                    }\n                    else {\n                        // we have to process `deleteMany` separately because the guard may contain\n                        // filters using relation fields which are not allowed in nested `deleteMany`\n                        const reversedQuery = this.policyUtils.buildReversedQuery(context);\n                        const deleteWhere = this.policyUtils.and(reversedQuery, guard);\n                        if (this.shouldLogQuery) {\n                            this.logger.info(`[policy] \\`deleteMany\\` ${model}:\\n${(0, utils_1.formatObject)({ where: deleteWhere })}`);\n                        }\n                        yield db[model].deleteMany({ where: deleteWhere });\n                        delete context.parent.deleteMany;\n                    }\n                }),\n            });\n            yield visitor.visit(this.model, 'update', args);\n            // finally proceed with the update\n            if (this.shouldLogQuery) {\n                this.logger.info(`[policy] \\`update\\` ${this.model}: ${(0, utils_1.formatObject)(args)}`);\n            }\n            const result = yield db[this.model].update({\n                where: args.where,\n                data: args.data,\n                select: this.policyUtils.makeIdSelection(this.model),\n            });\n            return { result, postWriteChecks };\n        });\n    }\n    // calculate id fields used for post-update check given an update payload\n    calculatePostUpdateIds(_model, currentIds, updatePayload) {\n        const result = (0, utils_1.clone)(currentIds);\n        for (const key of Object.keys(currentIds)) {\n            const updateValue = updatePayload[key];\n            if (typeof updateValue === 'string' || typeof updateValue === 'number' || typeof updateValue === 'bigint') {\n                result[key] = updateValue;\n            }\n        }\n        return result;\n    }\n    // updates foreign key fields inside `payload` based on relation id fields in `newIds`\n    overrideForeignKeyFields(model, payload, relation, newIds) {\n        if (!relation.foreignKeyMapping || Object.keys(relation.foreignKeyMapping).length === 0) {\n            return;\n        }\n        // override foreign key values\n        for (const [id, fk] of Object.entries(relation.foreignKeyMapping)) {\n            if (payload[fk] !== undefined && newIds[id] !== undefined) {\n                payload[fk] = newIds[id];\n            }\n        }\n        // deal with compound id fields\n        const uniqueConstraints = this.policyUtils.getUniqueConstraints(model);\n        for (const [name, constraint] of Object.entries(uniqueConstraints)) {\n            if (constraint.fields.length > 1) {\n                const target = payload[name];\n                if (target) {\n                    for (const [id, fk] of Object.entries(relation.foreignKeyMapping)) {\n                        if (target[fk] !== undefined && newIds[id] !== undefined) {\n                            target[fk] = newIds[id];\n                        }\n                    }\n                }\n            }\n        }\n    }\n    // Validates the given update payload against Zod schema if any\n    validateUpdateInputSchema(model, data) {\n        const schema = this.policyUtils.getZodSchema(model, 'update');\n        if (schema && data) {\n            // update payload can contain non-literal fields, like:\n            //   { x: { increment: 1 } }\n            // we should only validate literal fields\n            const literalData = Object.entries(data).reduce((acc, [k, v]) => (Object.assign(Object.assign({}, acc), (typeof v !== 'object' ? { [k]: v } : {}))), {});\n            const parseResult = schema.safeParse(literalData);\n            if (!parseResult.success) {\n                throw this.policyUtils.deniedByPolicy(model, 'update', `input failed validation: ${(0, zod_validation_error_1.fromZodError)(parseResult.error)}`, constants_1.CrudFailureReason.DATA_VALIDATION_VIOLATION, parseResult.error);\n            }\n            // schema may have transformed field values, use it to overwrite the original data\n            return Object.assign(Object.assign({}, data), parseResult.data);\n        }\n        else {\n            return data;\n        }\n    }\n    updateMany(args) {\n        if (!args) {\n            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.prismaModule, 'query argument is required');\n        }\n        if (!args.data) {\n            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.prismaModule, 'data field is required in query argument');\n        }\n        return (0, promise_1.createDeferredPromise)(() => {\n            this.policyUtils.tryReject(this.prisma, this.model, 'update');\n            args = (0, utils_1.clone)(args);\n            this.policyUtils.injectAuthGuardAsWhere(this.prisma, args, this.model, 'update');\n            args.data = this.validateUpdateInputSchema(this.model, args.data);\n            const entityChecker = this.policyUtils.getEntityChecker(this.model, 'update');\n            const canProceedWithoutTransaction = \n            // no post-update rules\n            !this.policyUtils.hasAuthGuard(this.model, 'postUpdate') &&\n                // no Zod schema\n                !this.policyUtils.getZodSchema(this.model) &&\n                // no entity checker\n                !entityChecker;\n            if (canProceedWithoutTransaction) {\n                // proceed without a transaction\n                if (this.shouldLogQuery) {\n                    this.logger.info(`[policy] \\`updateMany\\` ${this.model}: ${(0, utils_1.formatObject)(args)}`);\n                }\n                return this.modelClient.updateMany(args);\n            }\n            // collect post-update checks\n            const postWriteChecks = [];\n            return this.queryUtils.transaction(this.prisma, (tx) => __awaiter(this, void 0, void 0, function* () {\n                // collect pre-update values\n                let select = this.policyUtils.makeIdSelection(this.model);\n                const preValueSelect = this.policyUtils.getPreValueSelect(this.model);\n                if (preValueSelect) {\n                    select = Object.assign(Object.assign({}, select), preValueSelect);\n                }\n                // merge selection required for running additional checker\n                const entityChecker = this.policyUtils.getEntityChecker(this.model, 'update');\n                if (entityChecker === null || entityChecker === void 0 ? void 0 : entityChecker.selector) {\n                    select = (0, deepmerge_1.default)(select, entityChecker.selector);\n                }\n                const currentSetQuery = { select, where: args.where };\n                this.policyUtils.injectAuthGuardAsWhere(tx, currentSetQuery, this.model, 'update');\n                if (this.shouldLogQuery) {\n                    this.logger.info(`[policy] \\`findMany\\` ${this.model}: ${(0, utils_1.formatObject)(currentSetQuery)}`);\n                }\n                let candidates = yield tx[this.model].findMany(currentSetQuery);\n                if (entityChecker) {\n                    // filter candidates with additional checker and build an id filter\n                    const r = this.buildIdFilterWithEntityChecker(candidates, entityChecker.func);\n                    candidates = r.filteredCandidates;\n                    // merge id filter into update's where clause\n                    args.where = args.where ? { AND: [args.where, r.idFilter] } : r.idFilter;\n                }\n                postWriteChecks.push(...candidates.map((preValue) => ({\n                    model: this.model,\n                    operation: 'postUpdate',\n                    uniqueFilter: this.policyUtils.getEntityIds(this.model, preValue),\n                    preValue: preValueSelect ? preValue : undefined,\n                })));\n                // proceed with the update\n                if (this.shouldLogQuery) {\n                    this.logger.info(`[policy] \\`updateMany\\` in tx for ${this.model}: ${(0, utils_1.formatObject)(args)}`);\n                }\n                const result = yield tx[this.model].updateMany(args);\n                // run post-write checks\n                yield this.runPostWriteChecks(postWriteChecks, tx);\n                return result;\n            }));\n        });\n    }\n    upsert(args) {\n        if (!args) {\n            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.prismaModule, 'query argument is required');\n        }\n        if (!args.where) {\n            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.prismaModule, 'where field is required in query argument');\n        }\n        if (!args.create) {\n            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.prismaModule, 'create field is required in query argument');\n        }\n        if (!args.update) {\n            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.prismaModule, 'update field is required in query argument');\n        }\n        return (0, promise_1.createDeferredPromise)(() => __awaiter(this, void 0, void 0, function* () {\n            this.policyUtils.tryReject(this.prisma, this.model, 'create');\n            this.policyUtils.tryReject(this.prisma, this.model, 'update');\n            args = (0, utils_1.clone)(args);\n            // We can call the native \"upsert\" because we can't tell if an entity was created or updated\n            // for doing post-write check accordingly. Instead, decompose it into create or update.\n            const { result, error } = yield this.queryUtils.transaction(this.prisma, (tx) => __awaiter(this, void 0, void 0, function* () {\n                const { where, create, update } = args, rest = __rest(args, [\"where\", \"create\", \"update\"]);\n                const existing = yield this.policyUtils.checkExistence(tx, this.model, where);\n                if (existing) {\n                    // update case\n                    const { result, postWriteChecks } = yield this.doUpdate(Object.assign({ where: this.policyUtils.composeCompoundUniqueField(this.model, existing), data: update }, rest), tx);\n                    yield this.runPostWriteChecks(postWriteChecks, tx);\n                    return this.policyUtils.readBack(tx, this.model, 'update', args, result);\n                }\n                else {\n                    // create case\n                    const { result, postWriteChecks } = yield this.doCreate(this.model, Object.assign({ data: create }, rest), tx);\n                    yield this.runPostWriteChecks(postWriteChecks, tx);\n                    return this.policyUtils.readBack(tx, this.model, 'create', args, result);\n                }\n            }));\n            if (error) {\n                throw error;\n            }\n            else {\n                return result;\n            }\n        }));\n    }\n    //#endregion\n    //#region Delete\n    // \"delete\" works against a single entity, and is rejected if the entity fails policy check.\n    // \"deleteMany\" works against a set of entities, entities that fail policy check are filtered out.\n    delete(args) {\n        if (!args) {\n            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.prismaModule, 'query argument is required');\n        }\n        if (!args.where) {\n            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.prismaModule, 'where field is required in query argument');\n        }\n        return (0, promise_1.createDeferredPromise)(() => __awaiter(this, void 0, void 0, function* () {\n            this.policyUtils.tryReject(this.prisma, this.model, 'delete');\n            const { result, error } = yield this.queryUtils.transaction(this.prisma, (tx) => __awaiter(this, void 0, void 0, function* () {\n                // do a read-back before delete\n                const r = yield this.policyUtils.readBack(tx, this.model, 'delete', args, args.where);\n                const error = r.error;\n                const read = r.result;\n                // check existence\n                yield this.policyUtils.checkExistence(tx, this.model, args.where, true);\n                // inject delete guard\n                yield this.policyUtils.checkPolicyForUnique(this.model, args.where, 'delete', tx, args);\n                // proceed with the deletion\n                if (this.shouldLogQuery) {\n                    this.logger.info(`[policy] \\`delete\\` ${this.model}:\\n${(0, utils_1.formatObject)(args)}`);\n                }\n                yield tx[this.model].delete(args);\n                return { result: read, error };\n            }));\n            if (error) {\n                throw error;\n            }\n            else {\n                return result;\n            }\n        }));\n    }\n    deleteMany(args) {\n        return (0, promise_1.createDeferredPromise)(() => {\n            this.policyUtils.tryReject(this.prisma, this.model, 'delete');\n            // inject policy conditions\n            args = (0, utils_1.clone)(args);\n            this.policyUtils.injectAuthGuardAsWhere(this.prisma, args, this.model, 'delete');\n            const entityChecker = this.policyUtils.getEntityChecker(this.model, 'delete');\n            if (entityChecker) {\n                // additional checker exists, need to run deletion inside a transaction\n                return this.queryUtils.transaction(this.prisma, (tx) => __awaiter(this, void 0, void 0, function* () {\n                    // find the delete candidates, selecting id fields and fields needed for\n                    // running the additional checker\n                    let candidateSelect = this.policyUtils.makeIdSelection(this.model);\n                    if (entityChecker.selector) {\n                        candidateSelect = (0, deepmerge_1.default)(candidateSelect, entityChecker.selector);\n                    }\n                    if (this.shouldLogQuery) {\n                        this.logger.info(`[policy] \\`findMany\\` ${this.model}: ${(0, utils_1.formatObject)({\n                            where: args.where,\n                            select: candidateSelect,\n                        })}`);\n                    }\n                    const candidates = yield tx[this.model].findMany({ where: args.where, select: candidateSelect });\n                    // build a ID filter based on id values filtered by the additional checker\n                    const { idFilter } = this.buildIdFilterWithEntityChecker(candidates, entityChecker.func);\n                    // merge the ID filter into the where clause\n                    args.where = args.where ? { AND: [args.where, idFilter] } : idFilter;\n                    // finally, conduct the deletion with the combined where clause\n                    if (this.shouldLogQuery) {\n                        this.logger.info(`[policy] \\`deleteMany\\` in tx for ${this.model}:\\n${(0, utils_1.formatObject)(args)}`);\n                    }\n                    return tx[this.model].deleteMany(args);\n                }));\n            }\n            else {\n                // conduct the deletion directly\n                if (this.shouldLogQuery) {\n                    this.logger.info(`[policy] \\`deleteMany\\` ${this.model}:\\n${(0, utils_1.formatObject)(args)}`);\n                }\n                return this.modelClient.deleteMany(args);\n            }\n        });\n    }\n    //#endregion\n    //#region Aggregation\n    aggregate(args) {\n        if (!args) {\n            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.prismaModule, 'query argument is required');\n        }\n        return (0, promise_1.createDeferredPromise)(() => {\n            args = (0, utils_1.clone)(args);\n            // inject policy conditions\n            this.policyUtils.injectAuthGuardAsWhere(this.prisma, args, this.model, 'read');\n            if (this.shouldLogQuery) {\n                this.logger.info(`[policy] \\`aggregate\\` ${this.model}:\\n${(0, utils_1.formatObject)(args)}`);\n            }\n            return this.modelClient.aggregate(args);\n        });\n    }\n    groupBy(args) {\n        if (!args) {\n            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.prismaModule, 'query argument is required');\n        }\n        return (0, promise_1.createDeferredPromise)(() => {\n            args = (0, utils_1.clone)(args);\n            // inject policy conditions\n            this.policyUtils.injectAuthGuardAsWhere(this.prisma, args, this.model, 'read');\n            if (this.shouldLogQuery) {\n                this.logger.info(`[policy] \\`groupBy\\` ${this.model}:\\n${(0, utils_1.formatObject)(args)}`);\n            }\n            return this.modelClient.groupBy(args);\n        });\n    }\n    count(args) {\n        return (0, promise_1.createDeferredPromise)(() => {\n            // inject policy conditions\n            args = args ? (0, utils_1.clone)(args) : {};\n            this.policyUtils.injectAuthGuardAsWhere(this.prisma, args, this.model, 'read');\n            if (this.shouldLogQuery) {\n                this.logger.info(`[policy] \\`count\\` ${this.model}:\\n${(0, utils_1.formatObject)(args)}`);\n            }\n            return this.modelClient.count(args);\n        });\n    }\n    //#endregion\n    //#region Subscribe (Prisma Pulse)\n    subscribe(args) {\n        return (0, promise_1.createDeferredPromise)(() => {\n            const readGuard = this.policyUtils.getAuthGuard(this.prisma, this.model, 'read');\n            if (this.policyUtils.isTrue(readGuard)) {\n                // no need to inject\n                if (this.shouldLogQuery) {\n                    this.logger.info(`[policy] \\`subscribe\\` ${this.model}:\\n${(0, utils_1.formatObject)(args)}`);\n                }\n                return this.modelClient.subscribe(args);\n            }\n            if (!args) {\n                // include all\n                args = { create: {}, update: {}, delete: {} };\n            }\n            else {\n                if (typeof args !== 'object') {\n                    throw (0, utils_1.prismaClientValidationError)(this.prisma, this.prismaModule, 'argument must be an object');\n                }\n                if (Object.keys(args).length === 0) {\n                    // include all\n                    args = { create: {}, update: {}, delete: {} };\n                }\n                else {\n                    args = (0, utils_1.clone)(args);\n                }\n            }\n            // inject into subscribe conditions\n            if (args.create) {\n                args.create.after = this.policyUtils.and(args.create.after, readGuard);\n            }\n            if (args.update) {\n                args.update.after = this.policyUtils.and(args.update.after, readGuard);\n            }\n            if (args.delete) {\n                args.delete.before = this.policyUtils.and(args.delete.before, readGuard);\n            }\n            if (this.shouldLogQuery) {\n                this.logger.info(`[policy] \\`subscribe\\` ${this.model}:\\n${(0, utils_1.formatObject)(args)}`);\n            }\n            return this.modelClient.subscribe(args);\n        });\n    }\n    //#endregion\n    //#region Check\n    /**\n     * Checks if the given operation is possibly allowed by the policy, without querying the database.\n     * @param operation The CRUD operation.\n     * @param fieldValues Extra field value filters to be combined with the policy constraints.\n     */\n    check(args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return (0, promise_1.createDeferredPromise)(() => this.doCheck(args));\n        });\n    }\n    doCheck(args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!['create', 'read', 'update', 'delete'].includes(args.operation)) {\n                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.prismaModule, `Invalid \"operation\" ${args.operation}`);\n            }\n            let constraint = this.policyUtils.getCheckerConstraint(this.model, args.operation);\n            if (typeof constraint === 'boolean') {\n                return constraint;\n            }\n            if (args.where) {\n                // combine runtime filters with generated constraints\n                const extraConstraints = [];\n                for (const [field, value] of Object.entries(args.where)) {\n                    if (value === undefined) {\n                        continue;\n                    }\n                    if (value === null) {\n                        throw (0, utils_1.prismaClientValidationError)(this.prisma, this.prismaModule, `Using \"null\" as filter value is not supported yet`);\n                    }\n                    const fieldInfo = (0, cross_1.requireField)(this.modelMeta, this.model, field);\n                    // relation and array fields are not supported\n                    if (fieldInfo.isDataModel || fieldInfo.isArray) {\n                        throw (0, utils_1.prismaClientValidationError)(this.prisma, this.prismaModule, `Providing filter for field \"${field}\" is not supported. Only scalar fields are allowed.`);\n                    }\n                    // map field type to constraint type\n                    const fieldType = (0, ts_pattern_1.match)(fieldInfo.type)\n                        .with(ts_pattern_1.P.union('Int', 'BigInt', 'Float', 'Decimal'), () => 'number')\n                        .with('String', () => 'string')\n                        .with('Boolean', () => 'boolean')\n                        .otherwise(() => {\n                        throw (0, utils_1.prismaClientValidationError)(this.prisma, this.prismaModule, `Providing filter for field \"${field}\" is not supported. Only number, string, and boolean fields are allowed.`);\n                    });\n                    // check value type\n                    const valueType = typeof value;\n                    if (valueType !== 'number' && valueType !== 'string' && valueType !== 'boolean') {\n                        throw (0, utils_1.prismaClientValidationError)(this.prisma, this.prismaModule, `Invalid value type for field \"${field}\". Only number, string or boolean is allowed.`);\n                    }\n                    if (fieldType !== valueType) {\n                        throw (0, utils_1.prismaClientValidationError)(this.prisma, this.prismaModule, `Invalid value type for field \"${field}\". Expected \"${fieldType}\".`);\n                    }\n                    // check number validity\n                    if (typeof value === 'number' && (!Number.isInteger(value) || value < 0)) {\n                        throw (0, utils_1.prismaClientValidationError)(this.prisma, this.prismaModule, `Invalid value for field \"${field}\". Only non-negative integers are allowed.`);\n                    }\n                    // build a constraint\n                    extraConstraints.push({\n                        kind: 'eq',\n                        left: { kind: 'variable', name: field, type: fieldType },\n                        right: { kind: 'value', value, type: fieldType },\n                    });\n                }\n                if (extraConstraints.length > 0) {\n                    // combine the constraints\n                    constraint = { kind: 'and', children: [constraint, ...extraConstraints] };\n                }\n            }\n            // check satisfiability\n            return new constraint_solver_1.ConstraintSolver().checkSat(constraint);\n        });\n    }\n    //#endregion\n    //#region Utils\n    get shouldLogQuery() {\n        var _a;\n        return !!((_a = this.options) === null || _a === void 0 ? void 0 : _a.logPrismaQuery) && this.logger.enabled('info');\n    }\n    runPostWriteChecks(postWriteChecks, db) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield Promise.all(postWriteChecks.map((_a) => __awaiter(this, [_a], void 0, function* ({ model, operation, uniqueFilter, preValue }) { return this.policyUtils.checkPolicyForUnique(model, uniqueFilter, operation, db, undefined, preValue); })));\n        });\n    }\n    requireBackLink(fieldInfo) {\n        (0, tiny_invariant_1.default)(fieldInfo.backLink, `back link not found for field ${fieldInfo.name}`);\n        return (0, cross_1.requireField)(this.modelMeta, fieldInfo.type, fieldInfo.backLink);\n    }\n    mergeToParent(parent, key, value) {\n        if (parent[key]) {\n            if (Array.isArray(parent[key])) {\n                parent[key].push(value);\n            }\n            else {\n                parent[key] = [parent[key], value];\n            }\n        }\n        else {\n            parent[key] = value;\n        }\n    }\n    removeFromParent(parent, key, data) {\n        if (parent[key] === data) {\n            delete parent[key];\n        }\n        else if (Array.isArray(parent[key])) {\n            const idx = parent[key].indexOf(data);\n            if (idx >= 0) {\n                parent[key].splice(idx, 1);\n                if (parent[key].length === 0) {\n                    delete parent[key];\n                }\n            }\n        }\n    }\n    buildIdFilterWithEntityChecker(candidates, entityChecker) {\n        const filteredCandidates = candidates.filter((value) => { var _a; return entityChecker(value, { user: (_a = this.context) === null || _a === void 0 ? void 0 : _a.user }); });\n        const idFields = this.policyUtils.getIdFields(this.model);\n        let idFilter;\n        if (idFields.length === 1) {\n            idFilter = { [idFields[0].name]: { in: filteredCandidates.map((x) => x[idFields[0].name]) } };\n        }\n        else {\n            idFilter = { AND: filteredCandidates.map((x) => this.policyUtils.getIdFieldValues(this.model, x)) };\n        }\n        return { filteredCandidates, idFilter };\n    }\n}\nexports.PolicyProxyHandler = PolicyProxyHandler;\n//# sourceMappingURL=handler.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHplbnN0YWNraHErcnVudGltZUAyLjIuNF9AcHJpc21hK2NsaWVudEA1LjE3LjBfcHJpc21hQDUuMTcuMF8vbm9kZV9tb2R1bGVzL0B6ZW5zdGFja2hxL3J1bnRpbWUvZW5oYW5jZW1lbnRzL3BvbGljeS9oYW5kbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEI7QUFDMUIsb0NBQW9DLG1CQUFPLENBQUMsZ0dBQVc7QUFDdkQsMkJBQTJCLG1CQUFPLENBQUMsOEhBQWtCO0FBQ3JELHlDQUF5QyxtQkFBTyxDQUFDLDhIQUFnQjtBQUNqRSxxQkFBcUIsbUJBQU8sQ0FBQyxzR0FBWTtBQUN6QywyQkFBMkIsbUJBQU8sQ0FBQyw4SEFBa0I7QUFDckQsK0JBQStCLG1CQUFPLENBQUMsa0pBQXNCO0FBQzdELG9CQUFvQixtQkFBTyxDQUFDLGdLQUFpQjtBQUM3QyxnQkFBZ0IsbUJBQU8sQ0FBQyw4SkFBYTtBQUNyQyxpQkFBaUIsbUJBQU8sQ0FBQyxvS0FBVztBQUNwQyxrQkFBa0IsbUJBQU8sQ0FBQyxzS0FBWTtBQUN0QyxzQkFBc0IsbUJBQU8sQ0FBQyw4S0FBZ0I7QUFDOUMsZ0JBQWdCLG1CQUFPLENBQUMsa0tBQVU7QUFDbEMsNEJBQTRCLG1CQUFPLENBQUMsZ01BQXFCO0FBQ3pELHVCQUF1QixtQkFBTyxDQUFDLHNMQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkRBQTZEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFdBQVcsS0FBSyxXQUFXO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsV0FBVyxLQUFLLFdBQVcsS0FBSyxpQ0FBaUM7QUFDaEg7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBLGdFQUFnRSxXQUFXLElBQUksc0NBQXNDO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxvREFBb0QsOENBQThDLEdBQUc7QUFDckc7QUFDQSw4QkFBOEIsUUFBUSxVQUFVLEVBQUUsR0FBRyxpRUFBaUUsSUFBSTtBQUMxSCwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELFdBQVc7QUFDeEUsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSx3REFBd0QsTUFBTSxJQUFJLHNDQUFzQztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELG9EQUFvRDtBQUNwRztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLDREQUE0RDtBQUMvSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUNBQW1DO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRixnQ0FBZ0M7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxNQUFNLElBQUksZ0NBQWdDO0FBQ3pIO0FBQ0EsZ0RBQWdELDZEQUE2RDtBQUM3RyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELHNEQUFzRDtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRLFFBQVEsV0FBVztBQUNoRSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsaUJBQWlCO0FBQ3BGO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLElBQUk7QUFDN0I7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLE1BQU0sa0NBQWtDLG1CQUFtQixJQUFJLHlDQUF5QztBQUMzTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsSUFBSTtBQUNqQztBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQ0FBa0MsK0JBQStCLGtCQUFrQjtBQUMzRztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0YsZ0NBQWdDO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0EsNEZBQTRGLE1BQU0sS0FBSywyQ0FBMkM7QUFDbEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsTUFBTSxLQUFLO0FBQ25GO0FBQ0E7QUFDQSw2QkFBNkIsRUFBRTtBQUMvQjtBQUNBLHFEQUFxRCxxQ0FBcUM7QUFDMUY7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGtHQUFrRyw2REFBNkQ7QUFDL0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLHFHQUFxRyxnRUFBZ0U7QUFDcks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxNQUFNLEtBQUssMkNBQTJDO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsTUFBTSxLQUFLLDRCQUE0QixvQkFBb0IsRUFBRTtBQUNySTtBQUNBLHFEQUFxRCxvQkFBb0I7QUFDekU7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFdBQVcsSUFBSSxnQ0FBZ0M7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEtBQUs7QUFDeEI7QUFDQSw0R0FBNEcsbUNBQW1DLFNBQVMsSUFBSSxPQUFPO0FBQ25LO0FBQ0E7QUFDQSxtR0FBbUcsNERBQTREO0FBQy9KO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsV0FBVyxJQUFJLGdDQUFnQztBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLDhEQUE4RCxXQUFXLElBQUksMkNBQTJDO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdDQUFnQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDBFQUEwRSxXQUFXLElBQUksZ0NBQWdDO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQixzQ0FBc0Msd0ZBQXdGO0FBQ3BMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCLGtEQUFrRCxjQUFjO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsV0FBVyxLQUFLLGdDQUFnQztBQUM1RztBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFdBQVcsSUFBSTtBQUNqRjtBQUNBO0FBQ0EseUJBQXlCLEVBQUU7QUFDM0I7QUFDQSx1RUFBdUUsNENBQTRDO0FBQ25IO0FBQ0EsNEJBQTRCLFdBQVc7QUFDdkM7QUFDQSxnREFBZ0QsOEJBQThCO0FBQzlFO0FBQ0E7QUFDQSw4RUFBOEUsV0FBVyxLQUFLLGdDQUFnQztBQUM5SDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFdBQVcsS0FBSyxnQ0FBZ0M7QUFDaEg7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxXQUFXLEtBQUssZ0NBQWdDO0FBQzNHO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsV0FBVyxLQUFLLGdDQUFnQztBQUN6RztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFdBQVcsS0FBSyxnQ0FBZ0M7QUFDdkc7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsV0FBVyxLQUFLLGdDQUFnQztBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFVBQVUsWUFBWTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixVQUFVLFlBQVk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsV0FBVyxLQUFLLGdDQUFnQztBQUMzRztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzSEFBc0gsZUFBZTtBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzSUFBc0ksTUFBTTtBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNJQUFzSSxNQUFNO0FBQzVJLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSx3SUFBd0ksTUFBTTtBQUM5STtBQUNBO0FBQ0Esd0lBQXdJLE1BQU0sZUFBZSxVQUFVO0FBQ3ZLO0FBQ0E7QUFDQTtBQUNBLG1JQUFtSSxNQUFNO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdEQUFnRDtBQUNoRixpQ0FBaUMsdUNBQXVDO0FBQ3hFLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUdBQXFHLDBDQUEwQyxJQUFJLHdHQUF3RztBQUMzUCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJGQUEyRixlQUFlO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxRQUFRLDhCQUE4Qix3RUFBd0UsSUFBSTtBQUNwTDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0JBQXNCO0FBQy9DO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXJibGlzbS9uZXh0LWpzLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B6ZW5zdGFja2hxK3J1bnRpbWVAMi4yLjRfQHByaXNtYStjbGllbnRANS4xNy4wX3ByaXNtYUA1LjE3LjBfL25vZGVfbW9kdWxlcy9AemVuc3RhY2tocS9ydW50aW1lL2VuaGFuY2VtZW50cy9wb2xpY3kvaGFuZGxlci5qcz8xZTAwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBvbGljeVByb3h5SGFuZGxlciA9IHZvaWQgMDtcbmNvbnN0IGRlZXBtZXJnZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWVwbWVyZ2VcIikpO1xuY29uc3QgbG93ZXJfY2FzZV9maXJzdF8xID0gcmVxdWlyZShcImxvd2VyLWNhc2UtZmlyc3RcIik7XG5jb25zdCB0aW55X2ludmFyaWFudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJ0aW55LWludmFyaWFudFwiKSk7XG5jb25zdCB0c19wYXR0ZXJuXzEgPSByZXF1aXJlKFwidHMtcGF0dGVyblwiKTtcbmNvbnN0IHVwcGVyX2Nhc2VfZmlyc3RfMSA9IHJlcXVpcmUoXCJ1cHBlci1jYXNlLWZpcnN0XCIpO1xuY29uc3Qgem9kX3ZhbGlkYXRpb25fZXJyb3JfMSA9IHJlcXVpcmUoXCJ6b2QtdmFsaWRhdGlvbi1lcnJvclwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uLy4uL2NvbnN0YW50c1wiKTtcbmNvbnN0IGNyb3NzXzEgPSByZXF1aXJlKFwiLi4vLi4vY3Jvc3NcIik7XG5jb25zdCBsb2dnZXJfMSA9IHJlcXVpcmUoXCIuLi9sb2dnZXJcIik7XG5jb25zdCBwcm9taXNlXzEgPSByZXF1aXJlKFwiLi4vcHJvbWlzZVwiKTtcbmNvbnN0IHF1ZXJ5X3V0aWxzXzEgPSByZXF1aXJlKFwiLi4vcXVlcnktdXRpbHNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3QgY29uc3RyYWludF9zb2x2ZXJfMSA9IHJlcXVpcmUoXCIuL2NvbnN0cmFpbnQtc29sdmVyXCIpO1xuY29uc3QgcG9saWN5X3V0aWxzXzEgPSByZXF1aXJlKFwiLi9wb2xpY3ktdXRpbHNcIik7XG4vKipcbiAqIFByaXNtYSBwcm94eSBoYW5kbGVyIGZvciBpbmplY3RpbmcgYWNjZXNzIHBvbGljeSBjaGVjay5cbiAqL1xuY2xhc3MgUG9saWN5UHJveHlIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihwcmlzbWEsIG1vZGVsLCBvcHRpb25zLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMucHJpc21hID0gcHJpc21hO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmxvZ2dlciA9IG5ldyBsb2dnZXJfMS5Mb2dnZXIocHJpc21hKTtcbiAgICAgICAgdGhpcy5tb2RlbCA9ICgwLCBsb3dlcl9jYXNlX2ZpcnN0XzEubG93ZXJDYXNlRmlyc3QpKG1vZGVsKTtcbiAgICAgICAgKHsgbW9kZWxNZXRhOiB0aGlzLm1vZGVsTWV0YSwgcHJpc21hTW9kdWxlOiB0aGlzLnByaXNtYU1vZHVsZSB9ID0gb3B0aW9ucyk7XG4gICAgICAgIHRoaXMucG9saWN5VXRpbHMgPSBuZXcgcG9saWN5X3V0aWxzXzEuUG9saWN5VXRpbChwcmlzbWEsIG9wdGlvbnMsIGNvbnRleHQsIHRoaXMuc2hvdWxkTG9nUXVlcnkpO1xuICAgICAgICB0aGlzLnF1ZXJ5VXRpbHMgPSBuZXcgcXVlcnlfdXRpbHNfMS5RdWVyeVV0aWxzKHByaXNtYSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGdldCBtb2RlbENsaWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpc21hW3RoaXMubW9kZWxdO1xuICAgIH1cbiAgICAvLyNyZWdpb24gRmluZFxuICAgIC8vIGZpbmQgb3BlcmF0aW9ucyBiZWhhdmVzIGFzIGlmIHRoZSBlbnRpdGllcyB0aGF0IGRvbid0IG1hdGNoIGFjY2VzcyBwb2xpY2llcyBkb24ndCBleGlzdFxuICAgIGZpbmRVbmlxdWUoYXJncykge1xuICAgICAgICBpZiAoIWFyZ3MpIHtcbiAgICAgICAgICAgIHRocm93ICgwLCB1dGlsc18xLnByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvcikodGhpcy5wcmlzbWEsIHRoaXMucHJpc21hTW9kdWxlLCAncXVlcnkgYXJndW1lbnQgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFyZ3Mud2hlcmUpIHtcbiAgICAgICAgICAgIHRocm93ICgwLCB1dGlsc18xLnByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvcikodGhpcy5wcmlzbWEsIHRoaXMucHJpc21hTW9kdWxlLCAnd2hlcmUgZmllbGQgaXMgcmVxdWlyZWQgaW4gcXVlcnkgYXJndW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5maW5kV2l0aEZsdWVudCgnZmluZFVuaXF1ZScsIGFyZ3MsICgpID0+IG51bGwpO1xuICAgIH1cbiAgICBmaW5kVW5pcXVlT3JUaHJvdyhhcmdzKSB7XG4gICAgICAgIGlmICghYXJncykge1xuICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxzXzEucHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yKSh0aGlzLnByaXNtYSwgdGhpcy5wcmlzbWFNb2R1bGUsICdxdWVyeSBhcmd1bWVudCBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYXJncy53aGVyZSkge1xuICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxzXzEucHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yKSh0aGlzLnByaXNtYSwgdGhpcy5wcmlzbWFNb2R1bGUsICd3aGVyZSBmaWVsZCBpcyByZXF1aXJlZCBpbiBxdWVyeSBhcmd1bWVudCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRXaXRoRmx1ZW50KCdmaW5kVW5pcXVlT3JUaHJvdycsIGFyZ3MsICgpID0+IHtcbiAgICAgICAgICAgIHRocm93IHRoaXMucG9saWN5VXRpbHMubm90Rm91bmQodGhpcy5tb2RlbCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmaW5kRmlyc3QoYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kV2l0aEZsdWVudCgnZmluZEZpcnN0JywgYXJncywgKCkgPT4gbnVsbCk7XG4gICAgfVxuICAgIGZpbmRGaXJzdE9yVGhyb3coYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kV2l0aEZsdWVudCgnZmluZEZpcnN0T3JUaHJvdycsIGFyZ3MsICgpID0+IHtcbiAgICAgICAgICAgIHRocm93IHRoaXMucG9saWN5VXRpbHMubm90Rm91bmQodGhpcy5tb2RlbCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmaW5kTWFueShhcmdzKSB7XG4gICAgICAgIHJldHVybiAoMCwgcHJvbWlzZV8xLmNyZWF0ZURlZmVycmVkUHJvbWlzZSkoKCkgPT4gdGhpcy5kb0ZpbmQoYXJncywgJ2ZpbmRNYW55JywgKCkgPT4gW10pKTtcbiAgICB9XG4gICAgLy8gbWFrZSBhIGZpbmQgcXVlcnkgcHJvbWlzZSB3aXRoIGZsdWVudCBBUEkgY2FsbCBzdHVicyBpbnN0YWxsZWRcbiAgICBmaW5kV2l0aEZsdWVudChtZXRob2QsIGFyZ3MsIGhhbmRsZVJlamVjdGlvbikge1xuICAgICAgICBhcmdzID0gKDAsIHV0aWxzXzEuY2xvbmUpKGFyZ3MpO1xuICAgICAgICByZXR1cm4gKDAsIHByb21pc2VfMS5jcmVhdGVGbHVlbnRQcm9taXNlKSgoKSA9PiB0aGlzLmRvRmluZChhcmdzLCBtZXRob2QsIGhhbmRsZVJlamVjdGlvbiksIGFyZ3MsIHRoaXMub3B0aW9ucy5tb2RlbE1ldGEsIHRoaXMubW9kZWwpO1xuICAgIH1cbiAgICBkb0ZpbmQoYXJncywgYWN0aW9uTmFtZSwgaGFuZGxlUmVqZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBvcmlnQXJncyA9IGFyZ3M7XG4gICAgICAgICAgICBjb25zdCBfYXJncyA9ICgwLCB1dGlsc18xLmNsb25lKShhcmdzKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5wb2xpY3lVdGlscy5pbmplY3RGb3JSZWFkKHRoaXMucHJpc21hLCB0aGlzLm1vZGVsLCBfYXJncykpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG91bGRMb2dRdWVyeSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKGBbcG9saWN5XSBcXGAke2FjdGlvbk5hbWV9XFxgICR7dGhpcy5tb2RlbH06IHVuY29uZGl0aW9uYWxseSBkZW5pZWRgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVJlamVjdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wb2xpY3lVdGlscy5pbmplY3RSZWFkQ2hlY2tTZWxlY3QodGhpcy5tb2RlbCwgX2FyZ3MpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkTG9nUXVlcnkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKGBbcG9saWN5XSBcXGAke2FjdGlvbk5hbWV9XFxgICR7dGhpcy5tb2RlbH06XFxuJHsoMCwgdXRpbHNfMS5mb3JtYXRPYmplY3QpKF9hcmdzKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMubW9kZWxDbGllbnRbYWN0aW9uTmFtZV0oX2FyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9saWN5VXRpbHMucG9zdFByb2Nlc3NGb3JSZWFkKHJlc3VsdCwgdGhpcy5tb2RlbCwgb3JpZ0FyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8jZW5kcmVnaW9uXG4gICAgLy8jcmVnaW9uIENyZWF0ZVxuICAgIGNyZWF0ZShhcmdzKSB7XG4gICAgICAgIGlmICghYXJncykge1xuICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxzXzEucHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yKSh0aGlzLnByaXNtYSwgdGhpcy5wcmlzbWFNb2R1bGUsICdxdWVyeSBhcmd1bWVudCBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYXJncy5kYXRhKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgdXRpbHNfMS5wcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IpKHRoaXMucHJpc21hLCB0aGlzLnByaXNtYU1vZHVsZSwgJ2RhdGEgZmllbGQgaXMgcmVxdWlyZWQgaW4gcXVlcnkgYXJndW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIHByb21pc2VfMS5jcmVhdGVEZWZlcnJlZFByb21pc2UpKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMucG9saWN5VXRpbHMudHJ5UmVqZWN0KHRoaXMucHJpc21hLCB0aGlzLm1vZGVsLCAnY3JlYXRlJyk7XG4gICAgICAgICAgICBjb25zdCBvcmlnQXJncyA9IGFyZ3M7XG4gICAgICAgICAgICBhcmdzID0gKDAsIHV0aWxzXzEuY2xvbmUpKGFyZ3MpO1xuICAgICAgICAgICAgLy8gc3RhdGljIGlucHV0IHBvbGljeSBjaGVjayBmb3IgdG9wLWxldmVsIGNyZWF0ZSBkYXRhXG4gICAgICAgICAgICBjb25zdCBpbnB1dENoZWNrID0gdGhpcy5wb2xpY3lVdGlscy5jaGVja0lucHV0R3VhcmQodGhpcy5tb2RlbCwgYXJncy5kYXRhLCAnY3JlYXRlJyk7XG4gICAgICAgICAgICBpZiAoaW5wdXRDaGVjayA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLnBvbGljeVV0aWxzLmRlbmllZEJ5UG9saWN5KHRoaXMubW9kZWwsICdjcmVhdGUnLCB1bmRlZmluZWQsIGNvbnN0YW50c18xLkNydWRGYWlsdXJlUmVhc29uLkFDQ0VTU19QT0xJQ1lfVklPTEFUSU9OKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhhc05lc3RlZENyZWF0ZU9yQ29ubmVjdCA9IHlpZWxkIHRoaXMuaGFzTmVzdGVkQ3JlYXRlT3JDb25uZWN0KGFyZ3MpO1xuICAgICAgICAgICAgY29uc3QgeyByZXN1bHQsIGVycm9yIH0gPSB5aWVsZCB0aGlzLnF1ZXJ5VXRpbHMudHJhbnNhY3Rpb24odGhpcy5wcmlzbWEsICh0eCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAvLyBNVVNUIGNoZWNrIHRydWUgaGVyZSBzaW5jZSBpbnB1dENoZWNrIGNhbiBiZSB1bmRlZmluZWQgKG1lYW5pbmcgc3RhdGljIGlucHV0IGNoZWNrIG5vdCBwb3NzaWJsZSlcbiAgICAgICAgICAgICAgICBpbnB1dENoZWNrID09PSB0cnVlICYmXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbXBsZSBjcmVhdGU6IG5vIG5lc3RlZCBjcmVhdGUvY29ubmVjdFxuICAgICAgICAgICAgICAgICAgICAhaGFzTmVzdGVkQ3JlYXRlT3JDb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZXJlJ3Mgbm8gbmVzdGVkIHdyaXRlIGFuZCB3ZSd2ZSBwYXNzZWQgaW5wdXQgY2hlY2ssIHByb2NlZWQgd2l0aCB0aGUgY3JlYXRlIGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhbGlkYXRlIHpvZCBzY2hlbWEgaWYgYW55XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MuZGF0YSA9IHRoaXMudmFsaWRhdGVDcmVhdGVJbnB1dFNjaGVtYSh0aGlzLm1vZGVsLCBhcmdzLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIGEgY3JlYXRlIGFyZ3Mgb25seSBjb250YWluaW5nIGRhdGEgYW5kIElEIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjcmVhdGVBcmdzID0geyBkYXRhOiBhcmdzLmRhdGEsIHNlbGVjdDogdGhpcy5wb2xpY3lVdGlscy5tYWtlSWRTZWxlY3Rpb24odGhpcy5tb2RlbCkgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkTG9nUXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oYFtwb2xpY3ldIFxcYGNyZWF0ZVxcYCAke3RoaXMubW9kZWx9OiAkeygwLCB1dGlsc18xLmZvcm1hdE9iamVjdCkoY3JlYXRlQXJncyl9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdHhbdGhpcy5tb2RlbF0uY3JlYXRlKGNyZWF0ZUFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgdGhlIHJlYWQtYmFjayBkYXRhXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBvbGljeVV0aWxzLnJlYWRCYWNrKHR4LCB0aGlzLm1vZGVsLCAnY3JlYXRlJywgYXJncywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByb2NlZWQgd2l0aCBhIGNvbXBsZXggY3JlYXRlIGFuZCBjb2xsZWN0IHBvc3Qtd3JpdGUgY2hlY2tzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVzdWx0LCBwb3N0V3JpdGVDaGVja3MgfSA9IHlpZWxkIHRoaXMuZG9DcmVhdGUodGhpcy5tb2RlbCwgYXJncywgdHgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBleGVjdXRlIHBvc3Qtd3JpdGUgY2hlY2tzXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucnVuUG9zdFdyaXRlQ2hlY2tzKHBvc3RXcml0ZUNoZWNrcywgdHgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgdGhlIHJlYWQtYmFjayBkYXRhXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBvbGljeVV0aWxzLnJlYWRCYWNrKHR4LCB0aGlzLm1vZGVsLCAnY3JlYXRlJywgb3JpZ0FyZ3MsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8vIGNyZWF0ZSB3aXRoIG5lc3RlZCB3cml0ZVxuICAgIGRvQ3JlYXRlKG1vZGVsLCBhcmdzLCBkYikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gcmVjb3JkIGlkIGZpZWxkcyBpbnZvbHZlZCBpbiB0aGUgbmVzdGluZyBjb250ZXh0XG4gICAgICAgICAgICBjb25zdCBpZFNlbGVjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHB1c2hJZEZpZWxkcyA9IChtb2RlbCwgY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkRmllbGRzID0gKDAsIGNyb3NzXzEuZ2V0SWRGaWVsZHMpKHRoaXMubW9kZWxNZXRhLCBtb2RlbCk7XG4gICAgICAgICAgICAgICAgaWRTZWxlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjb250ZXh0Lm5lc3RpbmdQYXRoLm1hcCgocCkgPT4gcC5maWVsZCkuZmlsdGVyKChmKSA9PiAhIWYpLFxuICAgICAgICAgICAgICAgICAgICBpZHM6IGlkRmllbGRzLm1hcCgoZikgPT4gZi5uYW1lKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBjcmVhdGUgYSBzdHJpbmcga2V5IHRoYXQgdW5pcXVlbHkgaWRlbnRpZmllcyBhbiBlbnRpdHlcbiAgICAgICAgICAgIGNvbnN0IGdldEVudGl0eUtleSA9IChtb2RlbCwgaWRzKSA9PiBgJHsoMCwgdXBwZXJfY2FzZV9maXJzdF8xLnVwcGVyQ2FzZUZpcnN0KShtb2RlbCl9IyR7T2JqZWN0LmtleXMoaWRzKVxuICAgICAgICAgICAgICAgIC5zb3J0KClcbiAgICAgICAgICAgICAgICAubWFwKChmKSA9PiB7IHZhciBfYTsgcmV0dXJuIGAke2Z9OiR7KF9hID0gaWRzW2ZdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9TdHJpbmcoKX1gOyB9KVxuICAgICAgICAgICAgICAgIC5qb2luKCdfJyl9YDtcbiAgICAgICAgICAgIC8vIHJlY29yZCBrZXlzIG9mIGVudGl0aWVzIHRoYXQgYXJlIGNvbm5lY3RlZCBpbnN0ZWFkIG9mIGNyZWF0ZWRcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RlZEVudGl0aWVzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgLy8gdmlzaXQgdGhlIGNyZWF0ZSBwYXlsb2FkXG4gICAgICAgICAgICBjb25zdCB2aXNpdG9yID0gbmV3IGNyb3NzXzEuTmVzdGVkV3JpdGVWaXNpdG9yKHRoaXMubW9kZWxNZXRhLCB7XG4gICAgICAgICAgICAgICAgY3JlYXRlOiAobW9kZWwsIGFyZ3MsIGNvbnRleHQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGVSZXN1bHQgPSB0aGlzLnZhbGlkYXRlQ3JlYXRlSW5wdXRTY2hlbWEobW9kZWwsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGVSZXN1bHQgIT09IGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9saWN5VXRpbHMucmVwbGFjZShhcmdzLCB2YWxpZGF0ZVJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHVzaElkRmllbGRzKG1vZGVsLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBjcmVhdGVNYW55OiAobW9kZWwsIGFyZ3MsIGNvbnRleHQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGNyb3NzXzEuZW51bWVyYXRlKShhcmdzLmRhdGEpLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLnZhbGlkYXRlQ3JlYXRlSW5wdXRTY2hlbWEobW9kZWwsIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIgIT09IGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvbGljeVV0aWxzLnJlcGxhY2UoaXRlbSwgcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBwdXNoSWRGaWVsZHMobW9kZWwsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGNvbm5lY3RPckNyZWF0ZTogKG1vZGVsLCBhcmdzLCBjb250ZXh0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhcmdzLndoZXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLnBvbGljeVV0aWxzLnZhbGlkYXRpb25FcnJvcihgJ3doZXJlJyBmaWVsZCBpcyByZXF1aXJlZCBmb3IgY29ubmVjdE9yQ3JlYXRlYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MuY3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLmNyZWF0ZSA9IHRoaXMudmFsaWRhdGVDcmVhdGVJbnB1dFNjaGVtYShtb2RlbCwgYXJncy5jcmVhdGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0geWllbGQgdGhpcy5wb2xpY3lVdGlscy5jaGVja0V4aXN0ZW5jZShkYiwgbW9kZWwsIGFyZ3Mud2hlcmUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbm5lY3QgY2FzZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfYSA9IGNvbnRleHQuZmllbGQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5iYWNrTGluaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhY2tMaW5rRmllbGQgPSAoMCwgY3Jvc3NfMS5yZXNvbHZlRmllbGQpKHRoaXMubW9kZWxNZXRhLCBtb2RlbCwgY29udGV4dC5maWVsZC5iYWNrTGluayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJhY2tMaW5rRmllbGQgPT09IG51bGwgfHwgYmFja0xpbmtGaWVsZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmFja0xpbmtGaWVsZC5pc1JlbGF0aW9uT3duZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHRhcmdldCBzaWRlIG9mIHJlbGF0aW9uIG93bnMgdGhlIHJlbGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBpdCdzIHVwZGF0YWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnBvbGljeVV0aWxzLmNoZWNrUG9saWN5Rm9yVW5pcXVlKG1vZGVsLCBhcmdzLndoZXJlLCAndXBkYXRlJywgZGIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWVyZ2VUb1BhcmVudChjb250ZXh0LnBhcmVudCwgJ2Nvbm5lY3QnLCBhcmdzLndoZXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlY29yZCB0aGUga2V5IG9mIGNvbm5lY3RlZCBlbnRpdGllcyBzbyB3ZSBjYW4gYXZvaWQgdmFsaWRhdGluZyB0aGVtIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0ZWRFbnRpdGllcy5hZGQoZ2V0RW50aXR5S2V5KG1vZGVsLCBleGlzdGluZykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hJZEZpZWxkcyhtb2RlbCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSBuZXcgXCJjcmVhdGVcIiBjbGF1c2UgYXQgdGhlIHBhcmVudCBsZXZlbFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXJnZVRvUGFyZW50KGNvbnRleHQucGFyZW50LCAnY3JlYXRlJywgYXJncy5jcmVhdGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgY29ubmVjdE9yQ3JlYXRlIGNsYXVzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUZyb21QYXJlbnQoY29udGV4dC5wYXJlbnQsICdjb25uZWN0T3JDcmVhdGUnLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIGZhbHNlIHRvIHByZXZlbnQgdmlzaXRpbmcgdGhlIG5lc3RlZCBwYXlsb2FkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBjb25uZWN0OiAobW9kZWwsIGFyZ3MsIGNvbnRleHQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9iO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFyZ3MgfHwgdHlwZW9mIGFyZ3MgIT09ICdvYmplY3QnIHx8IE9iamVjdC5rZXlzKGFyZ3MpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5wb2xpY3lVdGlscy52YWxpZGF0aW9uRXJyb3IoYCdjb25uZWN0JyBmaWVsZCBtdXN0IGJlIGFuIG5vbi1lbXB0eSBvYmplY3RgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKF9iID0gY29udGV4dC5maWVsZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmJhY2tMaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYWNrTGlua0ZpZWxkID0gKDAsIGNyb3NzXzEucmVzb2x2ZUZpZWxkKSh0aGlzLm1vZGVsTWV0YSwgbW9kZWwsIGNvbnRleHQuZmllbGQuYmFja0xpbmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJhY2tMaW5rRmllbGQgPT09IG51bGwgfHwgYmFja0xpbmtGaWVsZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmFja0xpbmtGaWVsZC5pc1JlbGF0aW9uT3duZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBleGlzdGVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnBvbGljeVV0aWxzLmNoZWNrRXhpc3RlbmNlKGRiLCBtb2RlbCwgYXJncywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHRhcmdldCBzaWRlIG9mIHJlbGF0aW9uIG93bnMgdGhlIHJlbGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGl0J3MgdXBkYXRhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5wb2xpY3lVdGlscy5jaGVja1BvbGljeUZvclVuaXF1ZShtb2RlbCwgYXJncywgJ3VwZGF0ZScsIGRiLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB5aWVsZCB2aXNpdG9yLnZpc2l0KG1vZGVsLCAnY3JlYXRlJywgYXJncyk7XG4gICAgICAgICAgICAvLyBidWlsZCB0aGUgZmluYWwgXCJzZWxlY3RcIiBjbGF1c2UgaW5jbHVkaW5nIGFsbCBuZXN0ZWQgSUQgZmllbGRzXG4gICAgICAgICAgICBsZXQgc2VsZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGlkU2VsZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ID0ge307XG4gICAgICAgICAgICAgICAgaWRTZWxlY3Rpb25zLmZvckVhY2goKHsgcGF0aCwgaWRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnIgPSBzZWxlY3Q7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcCBvZiBwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJbcC5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJbcC5uYW1lXSA9IHsgc2VsZWN0OiB7fSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyciA9IGN1cnJbcC5uYW1lXS5zZWxlY3Q7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihjdXJyLCAuLi5pZHMubWFwKChmKSA9PiAoeyBbZl06IHRydWUgfSkpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHByb2NlZWQgd2l0aCB0aGUgY3JlYXRlXG4gICAgICAgICAgICBjb25zdCBjcmVhdGVBcmdzID0geyBkYXRhOiBhcmdzLmRhdGEsIHNlbGVjdCB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkTG9nUXVlcnkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKGBbcG9saWN5XSBcXGBjcmVhdGVcXGAgJHttb2RlbH06ICR7KDAsIHV0aWxzXzEuZm9ybWF0T2JqZWN0KShjcmVhdGVBcmdzKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIGRiW21vZGVsXS5jcmVhdGUoY3JlYXRlQXJncyk7XG4gICAgICAgICAgICAvLyBwb3N0IGNyZWF0ZSBwb2xpY3kgY2hlY2sgZm9yIHRoZSB0b3AtbGV2ZWwgYW5kIG5lc3RlZCBjcmVhdGVzXG4gICAgICAgICAgICBjb25zdCBwb3N0Q3JlYXRlQ2hlY2tzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgLy8gdmlzaXQgdGhlIGNyZWF0ZSByZXN1bHQgYW5kIGNvbGxlY3QgZW50aXRpZXMgdGhhdCBuZWVkIHRvIGJlIHBvc3QtY2hlY2tlZFxuICAgICAgICAgICAgY29uc3QgbW9kZWxEYXRhVmlzaXRvciA9IG5ldyBjcm9zc18xLk1vZGVsRGF0YVZpc2l0b3IodGhpcy5tb2RlbE1ldGEpO1xuICAgICAgICAgICAgbW9kZWxEYXRhVmlzaXRvci52aXNpdChtb2RlbCwgcmVzdWx0LCAobW9kZWwsIF9kYXRhLCBzY2FsYXJEYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gZ2V0RW50aXR5S2V5KG1vZGVsLCBzY2FsYXJEYXRhKTtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGNoZWNrIGlmIGVudGl0eSBpcyBjcmVhdGVkLCBub3QgY29ubmVjdGVkXG4gICAgICAgICAgICAgICAgaWYgKCFjb25uZWN0ZWRFbnRpdGllcy5oYXMoa2V5KSAmJiAhcG9zdENyZWF0ZUNoZWNrcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZEZpZWxkcyA9IHRoaXMucG9saWN5VXRpbHMuZ2V0SWRGaWVsZFZhbHVlcyhtb2RlbCwgc2NhbGFyRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHBvc3RDcmVhdGVDaGVja3Muc2V0KGtleSwgeyBtb2RlbCwgb3BlcmF0aW9uOiAnY3JlYXRlJywgdW5pcXVlRmlsdGVyOiBpZEZpZWxkcyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHJldHVybiBvbmx5IHRoZSBpZHMgb2YgdGhlIHRvcC1sZXZlbCBlbnRpdHlcbiAgICAgICAgICAgIGNvbnN0IGlkcyA9IHRoaXMucG9saWN5VXRpbHMuZ2V0RW50aXR5SWRzKG1vZGVsLCByZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiBpZHMsIHBvc3RXcml0ZUNoZWNrczogWy4uLnBvc3RDcmVhdGVDaGVja3MudmFsdWVzKCldIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBDaGVja3MgaWYgdGhlIGdpdmVuIGNyZWF0ZSBwYXlsb2FkIGhhcyBuZXN0ZWQgY3JlYXRlIG9yIGNvbm5lY3RcbiAgICBoYXNOZXN0ZWRDcmVhdGVPckNvbm5lY3QoYXJncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IGhhc05lc3RlZENyZWF0ZU9yQ29ubmVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgdmlzaXRvciA9IG5ldyBjcm9zc18xLk5lc3RlZFdyaXRlVmlzaXRvcih0aGlzLm1vZGVsTWV0YSwge1xuICAgICAgICAgICAgICAgIGNyZWF0ZShfbW9kZWwsIF9hcmdzLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5maWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc05lc3RlZENyZWF0ZU9yQ29ubmVjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29ubmVjdCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc05lc3RlZENyZWF0ZU9yQ29ubmVjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29ubmVjdE9yQ3JlYXRlKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzTmVzdGVkQ3JlYXRlT3JDb25uZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjcmVhdGVNYW55KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzTmVzdGVkQ3JlYXRlT3JDb25uZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgeWllbGQgdmlzaXRvci52aXNpdCh0aGlzLm1vZGVsLCAnY3JlYXRlJywgYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gaGFzTmVzdGVkQ3JlYXRlT3JDb25uZWN0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGVzIHRoZSBnaXZlbiBjcmVhdGUgcGF5bG9hZCBhZ2FpbnN0IFpvZCBzY2hlbWEgaWYgYW55XG4gICAgdmFsaWRhdGVDcmVhdGVJbnB1dFNjaGVtYShtb2RlbCwgZGF0YSkge1xuICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLnBvbGljeVV0aWxzLmdldFpvZFNjaGVtYShtb2RlbCwgJ2NyZWF0ZScpO1xuICAgICAgICBpZiAoc2NoZW1hICYmIGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gc2NoZW1hLnNhZmVQYXJzZShkYXRhKTtcbiAgICAgICAgICAgIGlmICghcGFyc2VSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMucG9saWN5VXRpbHMuZGVuaWVkQnlQb2xpY3kobW9kZWwsICdjcmVhdGUnLCBgaW5wdXQgZmFpbGVkIHZhbGlkYXRpb246ICR7KDAsIHpvZF92YWxpZGF0aW9uX2Vycm9yXzEuZnJvbVpvZEVycm9yKShwYXJzZVJlc3VsdC5lcnJvcil9YCwgY29uc3RhbnRzXzEuQ3J1ZEZhaWx1cmVSZWFzb24uREFUQV9WQUxJREFUSU9OX1ZJT0xBVElPTiwgcGFyc2VSZXN1bHQuZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlUmVzdWx0LmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVNYW55KGFyZ3MpIHtcbiAgICAgICAgaWYgKCFhcmdzKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgdXRpbHNfMS5wcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IpKHRoaXMucHJpc21hLCB0aGlzLnByaXNtYU1vZHVsZSwgJ3F1ZXJ5IGFyZ3VtZW50IGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhcmdzLmRhdGEpIHtcbiAgICAgICAgICAgIHRocm93ICgwLCB1dGlsc18xLnByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvcikodGhpcy5wcmlzbWEsIHRoaXMucHJpc21hTW9kdWxlLCAnZGF0YSBmaWVsZCBpcyByZXF1aXJlZCBpbiBxdWVyeSBhcmd1bWVudCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgcHJvbWlzZV8xLmNyZWF0ZURlZmVycmVkUHJvbWlzZSkoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5wb2xpY3lVdGlscy50cnlSZWplY3QodGhpcy5wcmlzbWEsIHRoaXMubW9kZWwsICdjcmVhdGUnKTtcbiAgICAgICAgICAgIGFyZ3MgPSAoMCwgdXRpbHNfMS5jbG9uZSkoYXJncyk7XG4gICAgICAgICAgICAvLyBnbyB0aHJvdWdoIGNyZWF0ZSBpdGVtcywgc3RhdGljYWxseSBjaGVjayBpbnB1dCB0byBkZXRlcm1pbmUgaWYgcG9zdC1jcmVhdGVcbiAgICAgICAgICAgIC8vIGNoZWNrIGlzIG5lZWRlZCwgYW5kIGFsc28gdmFsaWRhdGUgem9kIHNjaGVtYVxuICAgICAgICAgICAgY29uc3QgbmVlZFBvc3RDcmVhdGVDaGVjayA9IHRoaXMudmFsaWRhdGVDcmVhdGVJbnB1dChhcmdzKTtcbiAgICAgICAgICAgIGlmICghbmVlZFBvc3RDcmVhdGVDaGVjaykge1xuICAgICAgICAgICAgICAgIC8vIGRpcmVjdCBjcmVhdGVcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlbENsaWVudC5jcmVhdGVNYW55KGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGVudGl0aWVzIGluIGEgdHJhbnNhY3Rpb24gd2l0aCBwb3N0LWNyZWF0ZSBjaGVja3NcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5xdWVyeVV0aWxzLnRyYW5zYWN0aW9uKHRoaXMucHJpc21hLCAodHgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyByZXN1bHQsIHBvc3RXcml0ZUNoZWNrcyB9ID0geWllbGQgdGhpcy5kb0NyZWF0ZU1hbnkodGhpcy5tb2RlbCwgYXJncywgdHgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBwb3N0LWNyZWF0ZSBjaGVja1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnJ1blBvc3RXcml0ZUNoZWNrcyhwb3N0V3JpdGVDaGVja3MsIHR4KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgY291bnQ6IHJlc3VsdC5sZW5ndGggfTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgY3JlYXRlTWFueUFuZFJldHVybihhcmdzKSB7XG4gICAgICAgIGlmICghYXJncykge1xuICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxzXzEucHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yKSh0aGlzLnByaXNtYSwgdGhpcy5wcmlzbWFNb2R1bGUsICdxdWVyeSBhcmd1bWVudCBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYXJncy5kYXRhKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgdXRpbHNfMS5wcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IpKHRoaXMucHJpc21hLCB0aGlzLnByaXNtYU1vZHVsZSwgJ2RhdGEgZmllbGQgaXMgcmVxdWlyZWQgaW4gcXVlcnkgYXJndW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIHByb21pc2VfMS5jcmVhdGVEZWZlcnJlZFByb21pc2UpKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHRoaXMucG9saWN5VXRpbHMudHJ5UmVqZWN0KHRoaXMucHJpc21hLCB0aGlzLm1vZGVsLCAnY3JlYXRlJyk7XG4gICAgICAgICAgICBjb25zdCBvcmlnQXJncyA9IGFyZ3M7XG4gICAgICAgICAgICBhcmdzID0gKDAsIHV0aWxzXzEuY2xvbmUpKGFyZ3MpO1xuICAgICAgICAgICAgLy8gZ28gdGhyb3VnaCBjcmVhdGUgaXRlbXMsIHN0YXRpY2FsbHkgY2hlY2sgaW5wdXQgdG8gZGV0ZXJtaW5lIGlmIHBvc3QtY3JlYXRlXG4gICAgICAgICAgICAvLyBjaGVjayBpcyBuZWVkZWQsIGFuZCBhbHNvIHZhbGlkYXRlIHpvZCBzY2hlbWFcbiAgICAgICAgICAgIGNvbnN0IG5lZWRQb3N0Q3JlYXRlQ2hlY2sgPSB0aGlzLnZhbGlkYXRlQ3JlYXRlSW5wdXQoYXJncyk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKCFuZWVkUG9zdENyZWF0ZUNoZWNrKSB7XG4gICAgICAgICAgICAgICAgLy8gZGlyZWN0IGNyZWF0ZVxuICAgICAgICAgICAgICAgIGNvbnN0IGNyZWF0ZWQgPSB5aWVsZCB0aGlzLm1vZGVsQ2xpZW50LmNyZWF0ZU1hbnlBbmRSZXR1cm4oYXJncyk7XG4gICAgICAgICAgICAgICAgLy8gcHJvY2VzcyByZWFkLWJhY2tcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCBQcm9taXNlLmFsbChjcmVhdGVkLm1hcCgoaXRlbSkgPT4gdGhpcy5wb2xpY3lVdGlscy5yZWFkQmFjayh0aGlzLnByaXNtYSwgdGhpcy5tb2RlbCwgJ2NyZWF0ZScsIG9yaWdBcmdzLCBpdGVtKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGVudGl0aWVzIGluIGEgdHJhbnNhY3Rpb24gd2l0aCBwb3N0LWNyZWF0ZSBjaGVja3NcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCB0aGlzLnF1ZXJ5VXRpbHMudHJhbnNhY3Rpb24odGhpcy5wcmlzbWEsICh0eCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHJlc3VsdDogY3JlYXRlZCwgcG9zdFdyaXRlQ2hlY2tzIH0gPSB5aWVsZCB0aGlzLmRvQ3JlYXRlTWFueSh0aGlzLm1vZGVsLCBhcmdzLCB0eCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHBvc3QtY3JlYXRlIGNoZWNrXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucnVuUG9zdFdyaXRlQ2hlY2tzKHBvc3RXcml0ZUNoZWNrcywgdHgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBwcm9jZXNzIHJlYWQtYmFja1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoY3JlYXRlZC5tYXAoKGl0ZW0pID0+IHRoaXMucG9saWN5VXRpbHMucmVhZEJhY2sodHgsIHRoaXMubW9kZWwsICdjcmVhdGUnLCBvcmlnQXJncywgaXRlbSkpKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aHJvdyByZWFkLWJhY2sgZXJyb3IgaWYgYW55IG9mIGNyZWF0ZSByZXN1bHQgcmVhZC1iYWNrIGZhaWxzXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IChfYSA9IHJlc3VsdC5maW5kKChyKSA9PiAhIXIuZXJyb3IpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXJyb3I7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQubWFwKChyKSA9PiByLnJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgdmFsaWRhdGVDcmVhdGVJbnB1dChhcmdzKSB7XG4gICAgICAgIGxldCBuZWVkUG9zdENyZWF0ZUNoZWNrID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiAoMCwgY3Jvc3NfMS5lbnVtZXJhdGUpKGFyZ3MuZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSB0aGlzLnZhbGlkYXRlQ3JlYXRlSW5wdXRTY2hlbWEodGhpcy5tb2RlbCwgaXRlbSk7XG4gICAgICAgICAgICBpZiAodmFsaWRhdGlvblJlc3VsdCAhPT0gaXRlbSkge1xuICAgICAgICAgICAgICAgIHRoaXMucG9saWN5VXRpbHMucmVwbGFjZShpdGVtLCB2YWxpZGF0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlucHV0Q2hlY2sgPSB0aGlzLnBvbGljeVV0aWxzLmNoZWNrSW5wdXRHdWFyZCh0aGlzLm1vZGVsLCBpdGVtLCAnY3JlYXRlJyk7XG4gICAgICAgICAgICBpZiAoaW5wdXRDaGVjayA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAvLyB1bmNvbmRpdGlvbmFsbHkgZGVueVxuICAgICAgICAgICAgICAgIHRocm93IHRoaXMucG9saWN5VXRpbHMuZGVuaWVkQnlQb2xpY3kodGhpcy5tb2RlbCwgJ2NyZWF0ZScsIHVuZGVmaW5lZCwgY29uc3RhbnRzXzEuQ3J1ZEZhaWx1cmVSZWFzb24uQUNDRVNTX1BPTElDWV9WSU9MQVRJT04pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5wdXRDaGVjayA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIC8vIHVuY29uZGl0aW9uYWxseSBhbGxvd1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5wdXRDaGVjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RhdGljIHBvbGljeSBjaGVjayBpcyBub3QgcG9zc2libGUsIG5lZWQgdG8gZG8gcG9zdC1jcmVhdGUgY2hlY2tcbiAgICAgICAgICAgICAgICBuZWVkUG9zdENyZWF0ZUNoZWNrID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmVlZFBvc3RDcmVhdGVDaGVjaztcbiAgICB9XG4gICAgZG9DcmVhdGVNYW55KG1vZGVsLCBhcmdzLCBkYikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gV2UgY2FuJ3QgY2FsbCB0aGUgbmF0aXZlIFwiY3JlYXRlTWFueVwiIGJlY2F1c2Ugd2UgY2FuJ3QgZ2V0IGJhY2sgd2hhdCB3YXMgY3JlYXRlZFxuICAgICAgICAgICAgLy8gZm9yIHBvc3QtY3JlYXRlIGNoZWNrcy4gSW5zdGVhZCwgZG8gYSBcImNyZWF0ZVwiIGZvciBlYWNoIGl0ZW0gYW5kIGNvbGxlY3QgdGhlIHJlc3VsdHMuXG4gICAgICAgICAgICBsZXQgY3JlYXRlUmVzdWx0ID0geWllbGQgUHJvbWlzZS5hbGwoKDAsIGNyb3NzXzEuZW51bWVyYXRlKShhcmdzLmRhdGEpLm1hcCgoaXRlbSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGlmIChhcmdzLnNraXBEdXBsaWNhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh5aWVsZCB0aGlzLmhhc0R1cGxpY2F0ZWRVbmlxdWVDb25zdHJhaW50KG1vZGVsLCBpdGVtLCB1bmRlZmluZWQsIGRiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkTG9nUXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKGBbcG9saWN5XSBcXGBjcmVhdGVNYW55XFxgIHNraXBwaW5nIGR1cGxpY2F0ZSAkeygwLCB1dGlsc18xLmZvcm1hdE9iamVjdCkoaXRlbSl9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZExvZ1F1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oYFtwb2xpY3ldIFxcYGNyZWF0ZVxcYCBmb3IgXFxgY3JlYXRlTWFueVxcYCAke21vZGVsfTogJHsoMCwgdXRpbHNfMS5mb3JtYXRPYmplY3QpKGl0ZW0pfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgZGJbbW9kZWxdLmNyZWF0ZSh7IHNlbGVjdDogdGhpcy5wb2xpY3lVdGlscy5tYWtlSWRTZWxlY3Rpb24obW9kZWwpLCBkYXRhOiBpdGVtIH0pO1xuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgIC8vIGZpbHRlciB1bmRlZmluZWQgdmFsdWVzIGR1ZSB0byBza2lwRHVwbGljYXRlc1xuICAgICAgICAgICAgY3JlYXRlUmVzdWx0ID0gY3JlYXRlUmVzdWx0LmZpbHRlcigocCkgPT4gISFwKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OiBjcmVhdGVSZXN1bHQsXG4gICAgICAgICAgICAgICAgcG9zdFdyaXRlQ2hlY2tzOiBjcmVhdGVSZXN1bHQubWFwKChpdGVtKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBtb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiAnY3JlYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlRmlsdGVyOiBpdGVtLFxuICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYXNEdXBsaWNhdGVkVW5pcXVlQ29uc3RyYWludChtb2RlbCwgY3JlYXRlRGF0YSwgdXBzdHJlYW1RdWVyeSwgZGIpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIHVuaXF1ZSBjb25zdHJhaW50IGNvbmZsaWN0c1xuICAgICAgICAgICAgLy8gd2UgY2FuJ3QgcmVseSBvbiB0cnkvY2F0Y2gvaWdub3JlIGNvbnN0cmFpbnQgdmlvbGF0aW9uIGVycm9yOiBodHRwczovL2dpdGh1Yi5jb20vcHJpc21hL3ByaXNtYS9pc3N1ZXMvMjA0OTZcbiAgICAgICAgICAgIC8vIFRPRE86IGZvciBzaW1wbGUgY2FzZXMgd2Ugc2hvdWxkIGJlIGFibGUgdG8gdHJhbnNsYXRlIGl0IHRvIGFuIGB1cHNlcnRgIHdpdGggZW1wdHkgYHVwZGF0ZWAgcGF5bG9hZFxuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgLy8gZm9yIGVhY2ggdW5pcXVlIGNvbnN0cmFpbnQsIGNoZWNrIGlmIHRoZSBpbnB1dCBpdGVtIGhhcyBhbGwgZmllbGRzIHNldCwgYW5kIGlmIHNvLCBjaGVjayBpZlxuICAgICAgICAgICAgLy8gYW4gZW50aXR5IGFscmVhZHkgZXhpc3RzLCBhbmQgaWdub3JlIGFjY29yZGluZ2x5XG4gICAgICAgICAgICBjb25zdCB1bmlxdWVDb25zdHJhaW50cyA9IHRoaXMucG9saWN5VXRpbHMuZ2V0VW5pcXVlQ29uc3RyYWludHMobW9kZWwpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjb25zdHJhaW50IG9mIE9iamVjdC52YWx1ZXModW5pcXVlQ29uc3RyYWludHMpKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIHVuaXF1ZSBmaWx0ZXIgdXNlZCB0byBjaGVjayBleGlzdGVuY2VcbiAgICAgICAgICAgICAgICBjb25zdCB1bmlxdWVGaWx0ZXIgPSB7fTtcbiAgICAgICAgICAgICAgICAvLyB1bmlxdWUgY29uc3RyYWludCBmaWVsZHMgbm90IGNvdmVyZWQgeWV0XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nQ29uc3RyYWludEZpZWxkcyA9IG5ldyBTZXQoY29uc3RyYWludC5maWVsZHMpO1xuICAgICAgICAgICAgICAgIC8vIGNvbGxlY3QgY29uc3RyYWludCBmaWVsZHMgZnJvbSB0aGUgY3JlYXRlIGRhdGFcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhjcmVhdGVEYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVtYWluaW5nQ29uc3RyYWludEZpZWxkcy5oYXMoaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUZpbHRlcltrXSA9IHY7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1haW5pbmdDb25zdHJhaW50RmllbGRzLmRlbGV0ZShrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjb2xsZWN0IGNvbnN0cmFpbnQgZmllbGRzIGZyb20gdGhlIHVwc3RyZWFtIHF1ZXJ5XG4gICAgICAgICAgICAgICAgaWYgKHVwc3RyZWFtUXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXModXBzdHJlYW1RdWVyeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZW1haW5pbmdDb25zdHJhaW50RmllbGRzLmhhcyhrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUZpbHRlcltrXSA9IHY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nQ29uc3RyYWludEZpZWxkcy5kZWxldGUoayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgdXBzdHJlYW0gcXVlcnkgY29udGFpbnMgYSByZWxhdGlvbiBmaWVsZCB3aGljaCBjb3ZlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgZm9yZWlnbiBrZXkgZmllbGQgY29uc3RyYWludFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGRJbmZvID0gKDAsIGNyb3NzXzEucmVxdWlyZUZpZWxkKSh0aGlzLm1vZGVsTWV0YSwgbW9kZWwsIGspO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZEluZm8uaXNEYXRhTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGNhcmUgYWJvdXQgcmVsYXRpb24gZmllbGRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtZXJnZSB0aGUgdXBzdHJlYW0gcXVlcnkgaW50byB0aGUgdW5pcXVlIGZpbHRlclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlRmlsdGVyW2tdID0gdjtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hcmsgdGhlIGNvcnJlc3BvbmRpbmcgZm9yZWlnbiBrZXkgZmllbGRzIGFzIGNvdmVyZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZrTWFwcGluZyA9IChfYSA9IGZpZWxkSW5mby5mb3JlaWduS2V5TWFwcGluZykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge307XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZrIG9mIE9iamVjdC52YWx1ZXMoZmtNYXBwaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZ0NvbnN0cmFpbnRGaWVsZHMuZGVsZXRlKGZrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVtYWluaW5nQ29uc3RyYWludEZpZWxkcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbCBjb25zdHJhaW50IGZpZWxkcyBzZXQsIGNoZWNrIGV4aXN0ZW5jZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IHlpZWxkIHRoaXMucG9saWN5VXRpbHMuY2hlY2tFeGlzdGVuY2UoZGIsIG1vZGVsLCB1bmlxdWVGaWx0ZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8jZW5kcmVnaW9uXG4gICAgLy8jcmVnaW9uIFVwZGF0ZSAmIFVwc2VydFxuICAgIC8vIFwidXBkYXRlXCIgYW5kIFwidXBzZXJ0XCIgd29yayBhZ2FpbnN0IHVuaXF1ZSBlbnRpdHksIHNvIHdlIGFjdGl2ZWx5IHJlamVjdHMgdGhlIHJlcXVlc3QgaWYgdGhlXG4gICAgLy8gZW50aXR5IGZhaWxzIHBvbGljeSBjaGVja1xuICAgIC8vXG4gICAgLy8gXCJ1cGRhdGVNYW55XCIgd29ya3MgYWdhaW5zdCBhIHNldCBvZiBlbnRpdGllcywgZW50aXRpZXMgbm90IHBhc3NpbmcgcG9saWN5IGNoZWNrIGFyZSBzaWxlbnRseVxuICAgIC8vIGlnbm9yZWRcbiAgICB1cGRhdGUoYXJncykge1xuICAgICAgICBpZiAoIWFyZ3MpIHtcbiAgICAgICAgICAgIHRocm93ICgwLCB1dGlsc18xLnByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvcikodGhpcy5wcmlzbWEsIHRoaXMucHJpc21hTW9kdWxlLCAncXVlcnkgYXJndW1lbnQgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFyZ3Mud2hlcmUpIHtcbiAgICAgICAgICAgIHRocm93ICgwLCB1dGlsc18xLnByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvcikodGhpcy5wcmlzbWEsIHRoaXMucHJpc21hTW9kdWxlLCAnd2hlcmUgZmllbGQgaXMgcmVxdWlyZWQgaW4gcXVlcnkgYXJndW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFyZ3MuZGF0YSkge1xuICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxzXzEucHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yKSh0aGlzLnByaXNtYSwgdGhpcy5wcmlzbWFNb2R1bGUsICdkYXRhIGZpZWxkIGlzIHJlcXVpcmVkIGluIHF1ZXJ5IGFyZ3VtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBwcm9taXNlXzEuY3JlYXRlRGVmZXJyZWRQcm9taXNlKSgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBhcmdzID0gKDAsIHV0aWxzXzEuY2xvbmUpKGFyZ3MpO1xuICAgICAgICAgICAgY29uc3QgeyByZXN1bHQsIGVycm9yIH0gPSB5aWVsZCB0aGlzLnF1ZXJ5VXRpbHMudHJhbnNhY3Rpb24odGhpcy5wcmlzbWEsICh0eCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIC8vIHByb2NlZWQgd2l0aCBuZXN0ZWQgd3JpdGVzIGFuZCBjb2xsZWN0IHBvc3Qtd3JpdGUgY2hlY2tzXG4gICAgICAgICAgICAgICAgY29uc3QgeyByZXN1bHQsIHBvc3RXcml0ZUNoZWNrcyB9ID0geWllbGQgdGhpcy5kb1VwZGF0ZShhcmdzLCB0eCk7XG4gICAgICAgICAgICAgICAgLy8gcG9zdC13cml0ZSBjaGVja1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucnVuUG9zdFdyaXRlQ2hlY2tzKHBvc3RXcml0ZUNoZWNrcywgdHgpO1xuICAgICAgICAgICAgICAgIC8vIGZpbHRlciB0aGUgcmVhZC1iYWNrIGRhdGFcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wb2xpY3lVdGlscy5yZWFkQmFjayh0eCwgdGhpcy5tb2RlbCwgJ3VwZGF0ZScsIGFyZ3MsIHJlc3VsdCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgZG9VcGRhdGUoYXJncywgZGIpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIGNvbGxlY3RlZCBwb3N0LXVwZGF0ZSBjaGVja3NcbiAgICAgICAgICAgIGNvbnN0IHBvc3RXcml0ZUNoZWNrcyA9IFtdO1xuICAgICAgICAgICAgLy8gcmVnaXN0ZXJzIGEgcG9zdC11cGRhdGUgY2hlY2sgdGFza1xuICAgICAgICAgICAgY29uc3QgX3JlZ2lzdGVyUG9zdFVwZGF0ZUNoZWNrID0gKG1vZGVsLCBwcmVVcGRhdGVMb29rdXBGaWx0ZXIsIHBvc3RVcGRhdGVMb29rdXBGaWx0ZXIpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAvLyBib3RoIFwicG9zdC11cGRhdGVcIiBydWxlcyBhbmQgWm9kIHNjaGVtYXMgcmVxdWlyZSBhIHBvc3QtdXBkYXRlIGNoZWNrXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucG9saWN5VXRpbHMuaGFzQXV0aEd1YXJkKG1vZGVsLCAncG9zdFVwZGF0ZScpIHx8IHRoaXMucG9saWN5VXRpbHMuZ2V0Wm9kU2NoZW1hKG1vZGVsKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzZWxlY3QgcHJlLXVwZGF0ZSBmaWVsZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByZVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVWYWx1ZVNlbGVjdCA9IHRoaXMucG9saWN5VXRpbHMuZ2V0UHJlVmFsdWVTZWxlY3QobW9kZWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJlVmFsdWVTZWxlY3QgJiYgT2JqZWN0LmtleXMocHJlVmFsdWVTZWxlY3QpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZVZhbHVlID0geWllbGQgZGJbbW9kZWxdLmZpbmRGaXJzdCh7IHdoZXJlOiBwcmVVcGRhdGVMb29rdXBGaWx0ZXIsIHNlbGVjdDogcHJlVmFsdWVTZWxlY3QgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcG9zdFdyaXRlQ2hlY2tzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246ICdwb3N0VXBkYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUZpbHRlcjogcG9zdFVwZGF0ZUxvb2t1cEZpbHRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZVZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFdlIGNhbid0IGxldCB0aGUgbmF0aXZlIFwidXBkYXRlXCIgdG8gaGFuZGxlIG5lc3RlZCBcImNyZWF0ZVwiIGJlY2F1c2Ugd2UgY2FuJ3QgZ2V0IGJhY2sgd2hhdFxuICAgICAgICAgICAgLy8gd2FzIGNyZWF0ZWQgZm9yIGRvaW5nIHBvc3QtdXBkYXRlIGNoZWNrcy5cbiAgICAgICAgICAgIC8vIEluc3RlYWQsIGhhbmRsZSBuZXN0ZWQgY3JlYXRlIGluc2lkZSB1cGRhdGUgYXMgYW4gYXRvbWljIG9wZXJhdGlvbiB0aGF0IGNyZWF0ZXMgYW4gZW50aXJlXG4gICAgICAgICAgICAvLyBzdWJ0cmVlIChjb250YWluaW5nIG5lc3RlZCBjcmVhdGVzL2Nvbm5lY3RzKVxuICAgICAgICAgICAgY29uc3QgX2NyZWF0ZSA9IChtb2RlbCwgYXJncywgY29udGV4dCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBsZXQgY3JlYXRlRGF0YSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgaWYgKChfYSA9IGNvbnRleHQuZmllbGQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5iYWNrTGluaykge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgY3JlYXRlIHBheWxvYWQgY29udGFpbnMgYW55IFwidW5zYWZlXCIgYXNzaWdubWVudDpcbiAgICAgICAgICAgICAgICAgICAgLy8gYXNzaWduIGlkIG9yIGZvcmVpZ24ga2V5IGZpZWxkcy5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlYXNvbiB3aHkgd2UgbmVlZCB0byBkbyB0aGF0IGlzIFByaXNtYSdzIG11dGF0aW9ucyBwYXlsb2FkXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0cnVjdHVyZSBoYXMgdHdvIG11dHVhbGx5IGV4Y2x1c2l2ZSBmb3JtcyBmb3Igc2FmZSBhbmQgdW5zYWZlXG4gICAgICAgICAgICAgICAgICAgIC8vIG9wZXJhdGlvbnMuIEUuZy46XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAtIHNhZmU6IHsgZGF0YTogeyB1c2VyOiB7IGNvbm5lY3Q6IHsgaWQ6IDEgfX0gfSB9XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAtIHVuc2FmZTogeyBkYXRhOiB7IHVzZXJJZDogMSB9IH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdW5zYWZlID0gKDAsIHV0aWxzXzEuaXNVbnNhZmVNdXRhdGUpKG1vZGVsLCBhcmdzLCB0aGlzLm1vZGVsTWV0YSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZXMgdGhlIGNvbm5lY3Rpb24gdG8gdXBzdHJlYW0gZW50aXR5XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldmVyc2VkUXVlcnkgPSB0aGlzLnBvbGljeVV0aWxzLmJ1aWxkUmV2ZXJzZWRRdWVyeShjb250ZXh0LCB0cnVlLCB1bnNhZmUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKCF1bnNhZmUgfHwgY29udGV4dC5maWVsZC5pc1JlbGF0aW9uT3duZXIpICYmIHJldmVyc2VkUXVlcnlbY29udGV4dC5maWVsZC5iYWNrTGlua10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG11dGF0aW9uIGlzIHNhZmUsIG9yIGN1cnJlbnQgZmllbGQgb3ducyB0aGUgcmVsYXRpb24gKHNvIHRoZSBvdGhlciBzaWRlIGhhcyBubyBmayksXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdGhlIHJldmVyc2UgcXVlcnkgY29udGFpbnMgdGhlIGJhY2sgbGluaywgdGhlbiB3ZSBjYW4gYnVpbGQgYSBcImNvbm5lY3RcIiB3aXRoIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVEYXRhID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjcmVhdGVEYXRhKSwgeyBbY29udGV4dC5maWVsZC5iYWNrTGlua106IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdDogcmV2ZXJzZWRRdWVyeVtjb250ZXh0LmZpZWxkLmJhY2tMaW5rXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCB0aGUgcmV2ZXJzZSBxdWVyeSBzaG91bGQgYmUgdHJhbnNsYXRlZCB0byBmb3JlaWduIGtleSBzZXR0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgbWVyZ2VkIHRvIHRoZSBjcmVhdGUgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFja0xpbmtGaWVsZCA9IHRoaXMucmVxdWlyZUJhY2tMaW5rKGNvbnRleHQuZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIHRpbnlfaW52YXJpYW50XzEuZGVmYXVsdCkoYmFja0xpbmtGaWVsZC5mb3JlaWduS2V5TWFwcGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnkgdG8gZXh0cmFjdCBmb3JlaWduIGtleSB2YWx1ZXMgZnJvbSB0aGUgcmV2ZXJzZSBxdWVyeVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZrVmFsdWVzID0gT2JqZWN0LnZhbHVlcyhiYWNrTGlua0ZpZWxkLmZvcmVpZ25LZXlNYXBwaW5nKS5yZWR1Y2UoKG9iaiwgZmspID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpbZmtdID0gcmV2ZXJzZWRRdWVyeVtma107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QudmFsdWVzKGZrVmFsdWVzKS5ldmVyeSgodikgPT4gdiAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbCBmb3JlaWduIGtleSB2YWx1ZXMgYXJlIGF2YWlsYWJsZSwgbWVyZ2UgdGhlbSB0byB0aGUgY3JlYXRlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVEYXRhID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjcmVhdGVEYXRhKSwgZmtWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc29tZSBmb3JlaWduIGtleSB2YWx1ZXMgYXJlIG1pc3NpbmcsIG5lZWQgdG8gbG9vayB1cCB0aGUgdXBzdHJlYW0gZW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY2FuIGhhcHBlbiB3aGVuIHRoZSB1cHN0cmVhbSBlbnRpdHkgZG9lc24ndCBoYXZlIGEgdW5pcXVlIHdoZXJlIGNsYXVzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgZXhhbXBsZSB3aGVuIGl0J3MgbmVzdGVkIGluc2lkZSBhIG9uZS10by1vbmUgdXBkYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBzdHJlYW1RdWVyeSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmU6IHJldmVyc2VkUXVlcnlbYmFja0xpbmtGaWVsZC5uYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0OiB0aGlzLnBvbGljeVV0aWxzLm1ha2VJZFNlbGVjdGlvbihiYWNrTGlua0ZpZWxkLnR5cGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmV0Y2ggdGhlIHVwc3RyZWFtIGVudGl0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZExvZ1F1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oYFtwb2xpY3ldIFxcYGZpbmRVbmlxdWVPclRocm93XFxgICR7bW9kZWx9OiBsb29raW5nIHVwIHVwc3RyZWFtIGVudGl0eSBvZiAke2JhY2tMaW5rRmllbGQudHlwZX0sICR7KDAsIHV0aWxzXzEuZm9ybWF0T2JqZWN0KSh1cHN0cmVhbVF1ZXJ5KX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBzdHJlYW1FbnRpdHkgPSB5aWVsZCB0aGlzLnByaXNtYVtiYWNrTGlua0ZpZWxkLnR5cGVdLmZpbmRVbmlxdWVPclRocm93KHVwc3RyZWFtUXVlcnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hcCBpZHMgdG8gZm9yZWlnbiBrZXlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmtWYWx1ZXMgPSBPYmplY3QuZW50cmllcyhiYWNrTGlua0ZpZWxkLmZvcmVpZ25LZXlNYXBwaW5nKS5yZWR1Y2UoKG9iaiwgW2lkLCBma10pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqW2ZrXSA9IHVwc3RyZWFtRW50aXR5W2lkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWVyZ2UgdGhlbSB0byB0aGUgY3JlYXRlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVEYXRhID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjcmVhdGVEYXRhKSwgZmtWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHByb2NlZWQgd2l0aCB0aGUgY3JlYXRlIGFuZCBjb2xsZWN0IHBvc3QtY3JlYXRlIGNoZWNrc1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcG9zdFdyaXRlQ2hlY2tzOiBjaGVja3MsIHJlc3VsdCB9ID0geWllbGQgdGhpcy5kb0NyZWF0ZShtb2RlbCwgeyBkYXRhOiBjcmVhdGVEYXRhIH0sIGRiKTtcbiAgICAgICAgICAgICAgICBwb3N0V3JpdGVDaGVja3MucHVzaCguLi5jaGVja3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IF9jcmVhdGVNYW55ID0gKG1vZGVsLCBhcmdzLCBjb250ZXh0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mICgwLCBjcm9zc18xLmVudW1lcmF0ZSkoYXJncy5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5za2lwRHVwbGljYXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IGEgcmV2ZXJzZWQgcXVlcnkgdG8gaW5jbHVkZSBmaWVsZHMgaW5oZXJpdGVkIGZyb20gdXBzdHJlYW0gbXV0YXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCdsbCBiZSBtZXJnZWQgd2l0aCB0aGUgY3JlYXRlIHBheWxvYWQgZm9yIHVuaXF1ZSBjb25zdHJhaW50IGNoZWNraW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1cHN0cmVhbVF1ZXJ5ID0gdGhpcy5wb2xpY3lVdGlscy5idWlsZFJldmVyc2VkUXVlcnkoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeWllbGQgdGhpcy5oYXNEdXBsaWNhdGVkVW5pcXVlQ29uc3RyYWludChtb2RlbCwgaXRlbSwgdXBzdHJlYW1RdWVyeSwgZGIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkTG9nUXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgW3BvbGljeV0gXFxgY3JlYXRlTWFueVxcYCBza2lwcGluZyBkdXBsaWNhdGUgJHsoMCwgdXRpbHNfMS5mb3JtYXRPYmplY3QpKGl0ZW0pfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB5aWVsZCBfY3JlYXRlKG1vZGVsLCBpdGVtLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IF9jb25uZWN0RGlzY29ubmVjdCA9IChtb2RlbCwgYXJncywgY29udGV4dCwgb3BlcmF0aW9uKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iO1xuICAgICAgICAgICAgICAgIGlmICgoX2IgPSBjb250ZXh0LmZpZWxkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYmFja0xpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFja0xpbmtGaWVsZCA9IHRoaXMucG9saWN5VXRpbHMuZ2V0TW9kZWxGaWVsZChtb2RlbCwgY29udGV4dC5maWVsZC5iYWNrTGluayk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiYWNrTGlua0ZpZWxkID09PSBudWxsIHx8IGJhY2tMaW5rRmllbGQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJhY2tMaW5rRmllbGQuaXNSZWxhdGlvbk93bmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdW5pcXVlRmlsdGVyID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb24gPT09ICdkaXNjb25uZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpc2Nvbm5lY3QgZmlsdGVyIGlzIG5vdCB1bmlxdWUsIG5lZWQgdG8gYnVpbGQgYSByZXZlcnNlZCBxdWVyeSB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvY2F0ZSB0aGUgZW50aXR5IGFuZCB1c2UgaXRzIGlkIGZpZWxkcyBhcyB1bmlxdWUgZmlsdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV2ZXJzZWRRdWVyeSA9IHRoaXMucG9saWN5VXRpbHMuYnVpbGRSZXZlcnNlZFF1ZXJ5KGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvdW5kID0geWllbGQgZGJbbW9kZWxdLmZpbmRVbmlxdWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVyZTogcmV2ZXJzZWRRdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0OiB0aGlzLnBvbGljeVV0aWxzLm1ha2VJZFNlbGVjdGlvbihtb2RlbCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlRmlsdGVyID0gZm91bmQgJiYgdGhpcy5wb2xpY3lVdGlscy5nZXRJZEZpZWxkVmFsdWVzKG1vZGVsLCBmb3VuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgaGFwcGVucyBvbiB0aGUgcmVsYXRlZCBtb2RlbCwgcmVxdWlyZSB1cGRhdGFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmFuc2xhdGUgYXJncyB0byBmb3JlaWduIGtleXMgc28gZmllbGQtbGV2ZWwgcG9saWNpZXMgY2FuIGJlIGNoZWNrZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoZWNrQXJncyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MgJiYgdHlwZW9mIGFyZ3MgPT09ICdvYmplY3QnICYmIGJhY2tMaW5rRmllbGQuZm9yZWlnbktleU1hcHBpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhhcmdzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmayA9IGJhY2tMaW5rRmllbGQuZm9yZWlnbktleU1hcHBpbmdba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja0FyZ3NbZmtdID0gYXJnc1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYHVuaXF1ZUZpbHRlcmAgY2FuIGJlIHVuZGVmaW5lZCBpZiB0aGUgZW50aXR5IHRvIGJlIGRpc2Nvbm5lY3RlZCBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5pcXVlRmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHVwZGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucG9saWN5VXRpbHMuY2hlY2tQb2xpY3lGb3JVbmlxdWUobW9kZWwsIHVuaXF1ZUZpbHRlciwgJ3VwZGF0ZScsIGRiLCBjaGVja0FyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlZ2lzdGVyIHBvc3QtdXBkYXRlIGNoZWNrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgX3JlZ2lzdGVyUG9zdFVwZGF0ZUNoZWNrKG1vZGVsLCB1bmlxdWVGaWx0ZXIsIHVuaXF1ZUZpbHRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHZpc2l0IG5lc3RlZCB3cml0ZXNcbiAgICAgICAgICAgIGNvbnN0IHZpc2l0b3IgPSBuZXcgY3Jvc3NfMS5OZXN0ZWRXcml0ZVZpc2l0b3IodGhpcy5tb2RlbE1ldGEsIHtcbiAgICAgICAgICAgICAgICB1cGRhdGU6IChtb2RlbCwgYXJncywgY29udGV4dCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2M7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1aWxkIGEgdW5pcXVlIHF1ZXJ5IGluY2x1ZGluZyB1cHN0cmVhbSBjb25kaXRpb25zXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVuaXF1ZUZpbHRlciA9IHRoaXMucG9saWN5VXRpbHMuYnVpbGRSZXZlcnNlZFF1ZXJ5KGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgbm90LWZvdW5kXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0geWllbGQgdGhpcy5wb2xpY3lVdGlscy5jaGVja0V4aXN0ZW5jZShkYiwgbW9kZWwsIHVuaXF1ZUZpbHRlciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSB1cGRhdGUgYWN0dWFsbHkgd3JpdGVzIHRvIHRoaXMgbW9kZWxcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRoaXNNb2RlbFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVQYXlsb2FkID0gKF9jID0gYXJncy5kYXRhKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWxpZGF0ZWRQYXlsb2FkID0gdGhpcy52YWxpZGF0ZVVwZGF0ZUlucHV0U2NoZW1hKG1vZGVsLCB1cGRhdGVQYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlZFBheWxvYWQgIT09IHVwZGF0ZVBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9saWN5VXRpbHMucmVwbGFjZSh1cGRhdGVQYXlsb2FkLCB2YWxpZGF0ZWRQYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlUGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModXBkYXRlUGF5bG9hZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9ICgwLCBjcm9zc18xLnJlc29sdmVGaWVsZCkodGhpcy5tb2RlbE1ldGEsIG1vZGVsLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpZWxkLmlzRGF0YU1vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzY2FsYXIgZmllbGQsIHJlcXVpcmUgdGhpcyBtb2RlbCB0byBiZSB1cGRhdGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNNb2RlbFVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWVsZC5pc1JlbGF0aW9uT3duZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbGF0aW9uIGlzIGJlaW5nIHVwZGF0ZWQgYW5kIHRoaXMgbW9kZWwgb3ducyBmb3JlaWduIGtleSwgcmVxdWlyZSB1cGRhdGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNNb2RlbFVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpc01vZGVsVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvbGljeVV0aWxzLnRyeVJlamVjdChkYiwgdGhpcy5tb2RlbCwgJ3VwZGF0ZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgcHJlLXVwZGF0ZSBndWFyZFxuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5wb2xpY3lVdGlscy5jaGVja1BvbGljeUZvclVuaXF1ZShtb2RlbCwgdW5pcXVlRmlsdGVyLCAndXBkYXRlJywgZGIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIGlkIGZpZWxkcyBhcmUgdXBkYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgX2FyZ3MgPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlUGF5bG9hZCA9IF9hcmdzLmRhdGEgJiYgdHlwZW9mIF9hcmdzLmRhdGEgPT09ICdvYmplY3QnID8gX2FyZ3MuZGF0YSA6IF9hcmdzO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zdFVwZGF0ZUlkcyA9IHRoaXMuY2FsY3VsYXRlUG9zdFVwZGF0ZUlkcyhtb2RlbCwgZXhpc3RpbmcsIHVwZGF0ZVBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVnaXN0ZXIgcG9zdC11cGRhdGUgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIF9yZWdpc3RlclBvc3RVcGRhdGVDaGVjayhtb2RlbCwgZXhpc3RpbmcsIHBvc3RVcGRhdGVJZHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgdXBkYXRlTWFueTogKG1vZGVsLCBhcmdzLCBjb250ZXh0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByZXBhcmUgZm9yIHBvc3QtdXBkYXRlIGNoZWNrXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBvbGljeVV0aWxzLmhhc0F1dGhHdWFyZChtb2RlbCwgJ3Bvc3RVcGRhdGUnKSB8fCB0aGlzLnBvbGljeVV0aWxzLmdldFpvZFNjaGVtYShtb2RlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzZWxlY3QgPSB0aGlzLnBvbGljeVV0aWxzLm1ha2VJZFNlbGVjdGlvbihtb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVWYWx1ZVNlbGVjdCA9IHRoaXMucG9saWN5VXRpbHMuZ2V0UHJlVmFsdWVTZWxlY3QobW9kZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZVZhbHVlU2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzZWxlY3QpLCBwcmVWYWx1ZVNlbGVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXZlcnNlZFF1ZXJ5ID0gdGhpcy5wb2xpY3lVdGlscy5idWlsZFJldmVyc2VkUXVlcnkoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50U2V0UXVlcnkgPSB7IHNlbGVjdCwgd2hlcmU6IHJldmVyc2VkUXVlcnkgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9saWN5VXRpbHMuaW5qZWN0QXV0aEd1YXJkQXNXaGVyZShkYiwgY3VycmVudFNldFF1ZXJ5LCBtb2RlbCwgJ3JlYWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZExvZ1F1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgW3BvbGljeV0gXFxgZmluZE1hbnlcXGAgZm9yIHBvc3QgdXBkYXRlIGNoZWNrICR7bW9kZWx9OlxcbiR7KDAsIHV0aWxzXzEuZm9ybWF0T2JqZWN0KShjdXJyZW50U2V0UXVlcnkpfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFNldCA9IHlpZWxkIGRiW21vZGVsXS5maW5kTWFueShjdXJyZW50U2V0UXVlcnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zdFdyaXRlQ2hlY2tzLnB1c2goLi4uY3VycmVudFNldC5tYXAoKHByZVZhbHVlKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogJ3Bvc3RVcGRhdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUZpbHRlcjogcHJlVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlVmFsdWU6IHByZVZhbHVlU2VsZWN0ID8gcHJlVmFsdWUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MuZGF0YSA9IHRoaXMudmFsaWRhdGVVcGRhdGVJbnB1dFNjaGVtYShtb2RlbCwgYXJncy5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlR3VhcmQgPSB0aGlzLnBvbGljeVV0aWxzLmdldEF1dGhHdWFyZChkYiwgbW9kZWwsICd1cGRhdGUnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucG9saWN5VXRpbHMuaXNUcnVlKHVwZGF0ZUd1YXJkKSB8fCB0aGlzLnBvbGljeVV0aWxzLmlzRmFsc2UodXBkYXRlR3VhcmQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbmplY3RzIHNpbXBsZSBhdXRoIGd1YXJkIGludG8gd2hlcmUgY2xhdXNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvbGljeVV0aWxzLmluamVjdEF1dGhHdWFyZEFzV2hlcmUoZGIsIGFyZ3MsIG1vZGVsLCAndXBkYXRlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIHRvIHByb2Nlc3MgYHVwZGF0ZU1hbnlgIHNlcGFyYXRlbHkgYmVjYXVzZSB0aGUgZ3VhcmQgbWF5IGNvbnRhaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpbHRlcnMgdXNpbmcgcmVsYXRpb24gZmllbGRzIHdoaWNoIGFyZSBub3QgYWxsb3dlZCBpbiBuZXN0ZWQgYHVwZGF0ZU1hbnlgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXZlcnNlZFF1ZXJ5ID0gdGhpcy5wb2xpY3lVdGlscy5idWlsZFJldmVyc2VkUXVlcnkoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVXaGVyZSA9IHRoaXMucG9saWN5VXRpbHMuYW5kKHJldmVyc2VkUXVlcnksIHVwZGF0ZUd1YXJkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZExvZ1F1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgW3BvbGljeV0gXFxgdXBkYXRlTWFueVxcYCAke21vZGVsfTpcXG4keygwLCB1dGlsc18xLmZvcm1hdE9iamVjdCkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVyZTogdXBkYXRlV2hlcmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGFyZ3MuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIGRiW21vZGVsXS51cGRhdGVNYW55KHsgd2hlcmU6IHVwZGF0ZVdoZXJlLCBkYXRhOiBhcmdzLmRhdGEgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgY29udGV4dC5wYXJlbnQudXBkYXRlTWFueTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGNyZWF0ZTogKG1vZGVsLCBhcmdzLCBjb250ZXh0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByb2Nlc3MgdGhlIGVudGlyZSBjcmVhdGUgc3VidHJlZSBzZXBhcmF0ZWx5XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIF9jcmVhdGUobW9kZWwsIGFyZ3MsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgaXQgZnJvbSB0aGUgdXBkYXRlIHBheWxvYWRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVGcm9tUGFyZW50KGNvbnRleHQucGFyZW50LCAnY3JlYXRlJywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IHZpc2l0IHBheWxvYWRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGNyZWF0ZU1hbnk6IChtb2RlbCwgYXJncywgY29udGV4dCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcm9jZXNzIGNyZWF0ZU1hbnkgc2VwYXJhdGVseVxuICAgICAgICAgICAgICAgICAgICB5aWVsZCBfY3JlYXRlTWFueShtb2RlbCwgYXJncywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBpdCBmcm9tIHRoZSB1cGRhdGUgcGF5bG9hZFxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY29udGV4dC5wYXJlbnQuY3JlYXRlTWFueTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgdmlzaXQgcGF5bG9hZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgdXBzZXJ0OiAobW9kZWwsIGFyZ3MsIGNvbnRleHQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYnVpbGQgYSB1bmlxdWUgcXVlcnkgaW5jbHVkaW5nIHVwc3RyZWFtIGNvbmRpdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdW5pcXVlRmlsdGVyID0gdGhpcy5wb2xpY3lVdGlscy5idWlsZFJldmVyc2VkUXVlcnkoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJyYW5jaCBiYXNlZCBvbiBpZiB0aGUgdXBkYXRlIHRhcmdldCBleGlzdHNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSB5aWVsZCB0aGlzLnBvbGljeVV0aWxzLmNoZWNrRXhpc3RlbmNlKGRiLCBtb2RlbCwgdW5pcXVlRmlsdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgY2FzZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgcHJlLXVwZGF0ZSBndWFyZFxuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5wb2xpY3lVdGlscy5jaGVja1BvbGljeUZvclVuaXF1ZShtb2RlbCwgZXhpc3RpbmcsICd1cGRhdGUnLCBkYiwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgaWQgZmllbGRzIGFyZSB1cGRhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3N0VXBkYXRlSWRzID0gdGhpcy5jYWxjdWxhdGVQb3N0VXBkYXRlSWRzKG1vZGVsLCBleGlzdGluZywgYXJncy51cGRhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVnaXN0ZXIgcG9zdC11cGRhdGUgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIF9yZWdpc3RlclBvc3RVcGRhdGVDaGVjayhtb2RlbCwgZXhpc3RpbmcsIHBvc3RVcGRhdGVJZHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udmVydCB1cHNlcnQgdG8gdXBkYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb252ZXJ0ZWRVcGRhdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmU6IGFyZ3Mud2hlcmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdGhpcy52YWxpZGF0ZVVwZGF0ZUlucHV0U2NoZW1hKG1vZGVsLCBhcmdzLnVwZGF0ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXJnZVRvUGFyZW50KGNvbnRleHQucGFyZW50LCAndXBkYXRlJywgY29udmVydGVkVXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRnJvbVBhcmVudChjb250ZXh0LnBhcmVudCwgJ3Vwc2VydCcsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udGludWUgdmlzaXRpbmcgdGhlIG5ldyBwYXlsb2FkXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udmVydGVkVXBkYXRlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb2Nlc3MgdGhlIGVudGlyZSBjcmVhdGUgc3VidHJlZSBzZXBhcmF0ZWx5XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBfY3JlYXRlKG1vZGVsLCBhcmdzLmNyZWF0ZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgaXQgZnJvbSB0aGUgdXBkYXRlIHBheWxvYWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRnJvbVBhcmVudChjb250ZXh0LnBhcmVudCwgJ3Vwc2VydCcsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgdmlzaXQgcGF5bG9hZFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgY29ubmVjdDogKG1vZGVsLCBhcmdzLCBjb250ZXh0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7IHJldHVybiBfY29ubmVjdERpc2Nvbm5lY3QobW9kZWwsIGFyZ3MsIGNvbnRleHQsICdjb25uZWN0Jyk7IH0pLFxuICAgICAgICAgICAgICAgIGNvbm5lY3RPckNyZWF0ZTogKG1vZGVsLCBhcmdzLCBjb250ZXh0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSB3aGVyZSBjb25kaXRpb24gaXMgYWxyZWFkeSB1bmlxdWUsIHNvIHdlIGNhbiB1c2UgaXQgdG8gY2hlY2sgaWYgdGhlIHRhcmdldCBleGlzdHNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSB5aWVsZCB0aGlzLnBvbGljeVV0aWxzLmNoZWNrRXhpc3RlbmNlKGRiLCBtb2RlbCwgYXJncy53aGVyZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29ubmVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgX2Nvbm5lY3REaXNjb25uZWN0KG1vZGVsLCBhcmdzLndoZXJlLCBjb250ZXh0LCAnY29ubmVjdCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNyZWF0ZWQgPSB5aWVsZCBfY3JlYXRlKG1vZGVsLCBhcmdzLmNyZWF0ZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1cHBlckNvbnRleHQgPSBjb250ZXh0Lm5lc3RpbmdQYXRoW2NvbnRleHQubmVzdGluZ1BhdGgubGVuZ3RoIC0gMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHVwcGVyQ29udGV4dCA9PT0gbnVsbCB8fCB1cHBlckNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVwcGVyQ29udGV4dC53aGVyZSkgJiYgY29udGV4dC5maWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSB3aGVyZSBjbGF1c2Ugb2YgdGhlIHVwcGVyIGNvbnRleHQgcmVmZXJlbmNlcyB0aGUgaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiB0aGUgY29ubmVjdGVkIGVudGl0eSwgaWYgc28sIHdlIG5lZWQgdG8gdXBkYXRlIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdmVycmlkZUZvcmVpZ25LZXlGaWVsZHModXBwZXJDb250ZXh0Lm1vZGVsLCB1cHBlckNvbnRleHQud2hlcmUsIGNvbnRleHQuZmllbGQsIGNyZWF0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBwYXlsb2FkIGZyb20gdGhlIHBhcmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVGcm9tUGFyZW50KGNvbnRleHQucGFyZW50LCAnY29ubmVjdE9yQ3JlYXRlJywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBkaXNjb25uZWN0OiAobW9kZWwsIGFyZ3MsIGNvbnRleHQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHsgcmV0dXJuIF9jb25uZWN0RGlzY29ubmVjdChtb2RlbCwgYXJncywgY29udGV4dCwgJ2Rpc2Nvbm5lY3QnKTsgfSksXG4gICAgICAgICAgICAgICAgc2V0OiAobW9kZWwsIGFyZ3MsIGNvbnRleHQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmluZCB0aGUgc2V0IG9mIGl0ZW1zIHRvIGJlIHJlcGxhY2VkXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldmVyc2VkUXVlcnkgPSB0aGlzLnBvbGljeVV0aWxzLmJ1aWxkUmV2ZXJzZWRRdWVyeShjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmluZEN1cnJTZXRBcmdzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0OiB0aGlzLnBvbGljeVV0aWxzLm1ha2VJZFNlbGVjdGlvbihtb2RlbCksXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGVyZTogcmV2ZXJzZWRRdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkTG9nUXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oYFtwb2xpY3ldIFxcYGZpbmRNYW55XFxgICR7bW9kZWx9OlxcbiR7KDAsIHV0aWxzXzEuZm9ybWF0T2JqZWN0KShmaW5kQ3VyclNldEFyZ3MpfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTZXQgPSB5aWVsZCBkYlttb2RlbF0uZmluZE1hbnkoZmluZEN1cnJTZXRBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVnaXN0ZXIgY3VycmVudCBzZXQgZm9yIHVwZGF0ZSAoZm9yZWlnbiBrZXkpXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKGN1cnJlbnRTZXQubWFwKChpdGVtKSA9PiBfY29ubmVjdERpc2Nvbm5lY3QobW9kZWwsIGl0ZW0sIGNvbnRleHQsICdkaXNjb25uZWN0JykpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvY2VlZCB3aXRoIGNvbm5lY3RpbmcgdGhlIG5ldyBzZXRcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwoKDAsIGNyb3NzXzEuZW51bWVyYXRlKShhcmdzKS5tYXAoKGl0ZW0pID0+IF9jb25uZWN0RGlzY29ubmVjdChtb2RlbCwgaXRlbSwgY29udGV4dCwgJ2Nvbm5lY3QnKSkpO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGRlbGV0ZTogKG1vZGVsLCBhcmdzLCBjb250ZXh0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1aWxkIGEgdW5pcXVlIHF1ZXJ5IGluY2x1ZGluZyB1cHN0cmVhbSBjb25kaXRpb25zXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVuaXF1ZUZpbHRlciA9IHRoaXMucG9saWN5VXRpbHMuYnVpbGRSZXZlcnNlZFF1ZXJ5KGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgbm90LWZvdW5kXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucG9saWN5VXRpbHMuY2hlY2tFeGlzdGVuY2UoZGIsIG1vZGVsLCB1bmlxdWVGaWx0ZXIsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBkZWxldGUgZ3VhcmRcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5wb2xpY3lVdGlscy5jaGVja1BvbGljeUZvclVuaXF1ZShtb2RlbCwgdW5pcXVlRmlsdGVyLCAnZGVsZXRlJywgZGIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGRlbGV0ZU1hbnk6IChtb2RlbCwgYXJncywgY29udGV4dCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBndWFyZCA9IHlpZWxkIHRoaXMucG9saWN5VXRpbHMuZ2V0QXV0aEd1YXJkKGRiLCBtb2RlbCwgJ2RlbGV0ZScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wb2xpY3lVdGlscy5pc1RydWUoZ3VhcmQpIHx8IHRoaXMucG9saWN5VXRpbHMuaXNGYWxzZShndWFyZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluamVjdCBzaW1wbGUgYXV0aCBndWFyZFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5wYXJlbnQuZGVsZXRlTWFueSA9IHRoaXMucG9saWN5VXRpbHMuYW5kKGFyZ3MsIGd1YXJkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgdG8gcHJvY2VzcyBgZGVsZXRlTWFueWAgc2VwYXJhdGVseSBiZWNhdXNlIHRoZSBndWFyZCBtYXkgY29udGFpblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmlsdGVycyB1c2luZyByZWxhdGlvbiBmaWVsZHMgd2hpY2ggYXJlIG5vdCBhbGxvd2VkIGluIG5lc3RlZCBgZGVsZXRlTWFueWBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldmVyc2VkUXVlcnkgPSB0aGlzLnBvbGljeVV0aWxzLmJ1aWxkUmV2ZXJzZWRRdWVyeShjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlbGV0ZVdoZXJlID0gdGhpcy5wb2xpY3lVdGlscy5hbmQocmV2ZXJzZWRRdWVyeSwgZ3VhcmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkTG9nUXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKGBbcG9saWN5XSBcXGBkZWxldGVNYW55XFxgICR7bW9kZWx9OlxcbiR7KDAsIHV0aWxzXzEuZm9ybWF0T2JqZWN0KSh7IHdoZXJlOiBkZWxldGVXaGVyZSB9KX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIGRiW21vZGVsXS5kZWxldGVNYW55KHsgd2hlcmU6IGRlbGV0ZVdoZXJlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNvbnRleHQucGFyZW50LmRlbGV0ZU1hbnk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgeWllbGQgdmlzaXRvci52aXNpdCh0aGlzLm1vZGVsLCAndXBkYXRlJywgYXJncyk7XG4gICAgICAgICAgICAvLyBmaW5hbGx5IHByb2NlZWQgd2l0aCB0aGUgdXBkYXRlXG4gICAgICAgICAgICBpZiAodGhpcy5zaG91bGRMb2dRdWVyeSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oYFtwb2xpY3ldIFxcYHVwZGF0ZVxcYCAke3RoaXMubW9kZWx9OiAkeygwLCB1dGlsc18xLmZvcm1hdE9iamVjdCkoYXJncyl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBkYlt0aGlzLm1vZGVsXS51cGRhdGUoe1xuICAgICAgICAgICAgICAgIHdoZXJlOiBhcmdzLndoZXJlLFxuICAgICAgICAgICAgICAgIGRhdGE6IGFyZ3MuZGF0YSxcbiAgICAgICAgICAgICAgICBzZWxlY3Q6IHRoaXMucG9saWN5VXRpbHMubWFrZUlkU2VsZWN0aW9uKHRoaXMubW9kZWwpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQsIHBvc3RXcml0ZUNoZWNrcyB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gY2FsY3VsYXRlIGlkIGZpZWxkcyB1c2VkIGZvciBwb3N0LXVwZGF0ZSBjaGVjayBnaXZlbiBhbiB1cGRhdGUgcGF5bG9hZFxuICAgIGNhbGN1bGF0ZVBvc3RVcGRhdGVJZHMoX21vZGVsLCBjdXJyZW50SWRzLCB1cGRhdGVQYXlsb2FkKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9ICgwLCB1dGlsc18xLmNsb25lKShjdXJyZW50SWRzKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoY3VycmVudElkcykpIHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZVZhbHVlID0gdXBkYXRlUGF5bG9hZFtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB1cGRhdGVWYWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHVwZGF0ZVZhbHVlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdXBkYXRlVmFsdWUgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB1cGRhdGVWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyB1cGRhdGVzIGZvcmVpZ24ga2V5IGZpZWxkcyBpbnNpZGUgYHBheWxvYWRgIGJhc2VkIG9uIHJlbGF0aW9uIGlkIGZpZWxkcyBpbiBgbmV3SWRzYFxuICAgIG92ZXJyaWRlRm9yZWlnbktleUZpZWxkcyhtb2RlbCwgcGF5bG9hZCwgcmVsYXRpb24sIG5ld0lkcykge1xuICAgICAgICBpZiAoIXJlbGF0aW9uLmZvcmVpZ25LZXlNYXBwaW5nIHx8IE9iamVjdC5rZXlzKHJlbGF0aW9uLmZvcmVpZ25LZXlNYXBwaW5nKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBvdmVycmlkZSBmb3JlaWduIGtleSB2YWx1ZXNcbiAgICAgICAgZm9yIChjb25zdCBbaWQsIGZrXSBvZiBPYmplY3QuZW50cmllcyhyZWxhdGlvbi5mb3JlaWduS2V5TWFwcGluZykpIHtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkW2ZrXSAhPT0gdW5kZWZpbmVkICYmIG5ld0lkc1tpZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBheWxvYWRbZmtdID0gbmV3SWRzW2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBkZWFsIHdpdGggY29tcG91bmQgaWQgZmllbGRzXG4gICAgICAgIGNvbnN0IHVuaXF1ZUNvbnN0cmFpbnRzID0gdGhpcy5wb2xpY3lVdGlscy5nZXRVbmlxdWVDb25zdHJhaW50cyhtb2RlbCk7XG4gICAgICAgIGZvciAoY29uc3QgW25hbWUsIGNvbnN0cmFpbnRdIG9mIE9iamVjdC5lbnRyaWVzKHVuaXF1ZUNvbnN0cmFpbnRzKSkge1xuICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnQuZmllbGRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBwYXlsb2FkW25hbWVdO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaWQsIGZrXSBvZiBPYmplY3QuZW50cmllcyhyZWxhdGlvbi5mb3JlaWduS2V5TWFwcGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRbZmtdICE9PSB1bmRlZmluZWQgJiYgbmV3SWRzW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2ZrXSA9IG5ld0lkc1tpZF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVmFsaWRhdGVzIHRoZSBnaXZlbiB1cGRhdGUgcGF5bG9hZCBhZ2FpbnN0IFpvZCBzY2hlbWEgaWYgYW55XG4gICAgdmFsaWRhdGVVcGRhdGVJbnB1dFNjaGVtYShtb2RlbCwgZGF0YSkge1xuICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLnBvbGljeVV0aWxzLmdldFpvZFNjaGVtYShtb2RlbCwgJ3VwZGF0ZScpO1xuICAgICAgICBpZiAoc2NoZW1hICYmIGRhdGEpIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBwYXlsb2FkIGNhbiBjb250YWluIG5vbi1saXRlcmFsIGZpZWxkcywgbGlrZTpcbiAgICAgICAgICAgIC8vICAgeyB4OiB7IGluY3JlbWVudDogMSB9IH1cbiAgICAgICAgICAgIC8vIHdlIHNob3VsZCBvbmx5IHZhbGlkYXRlIGxpdGVyYWwgZmllbGRzXG4gICAgICAgICAgICBjb25zdCBsaXRlcmFsRGF0YSA9IE9iamVjdC5lbnRyaWVzKGRhdGEpLnJlZHVjZSgoYWNjLCBbaywgdl0pID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjYyksICh0eXBlb2YgdiAhPT0gJ29iamVjdCcgPyB7IFtrXTogdiB9IDoge30pKSksIHt9KTtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gc2NoZW1hLnNhZmVQYXJzZShsaXRlcmFsRGF0YSk7XG4gICAgICAgICAgICBpZiAoIXBhcnNlUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLnBvbGljeVV0aWxzLmRlbmllZEJ5UG9saWN5KG1vZGVsLCAndXBkYXRlJywgYGlucHV0IGZhaWxlZCB2YWxpZGF0aW9uOiAkeygwLCB6b2RfdmFsaWRhdGlvbl9lcnJvcl8xLmZyb21ab2RFcnJvcikocGFyc2VSZXN1bHQuZXJyb3IpfWAsIGNvbnN0YW50c18xLkNydWRGYWlsdXJlUmVhc29uLkRBVEFfVkFMSURBVElPTl9WSU9MQVRJT04sIHBhcnNlUmVzdWx0LmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNjaGVtYSBtYXkgaGF2ZSB0cmFuc2Zvcm1lZCBmaWVsZCB2YWx1ZXMsIHVzZSBpdCB0byBvdmVyd3JpdGUgdGhlIG9yaWdpbmFsIGRhdGFcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGEpLCBwYXJzZVJlc3VsdC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZU1hbnkoYXJncykge1xuICAgICAgICBpZiAoIWFyZ3MpIHtcbiAgICAgICAgICAgIHRocm93ICgwLCB1dGlsc18xLnByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvcikodGhpcy5wcmlzbWEsIHRoaXMucHJpc21hTW9kdWxlLCAncXVlcnkgYXJndW1lbnQgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFyZ3MuZGF0YSkge1xuICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxzXzEucHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yKSh0aGlzLnByaXNtYSwgdGhpcy5wcmlzbWFNb2R1bGUsICdkYXRhIGZpZWxkIGlzIHJlcXVpcmVkIGluIHF1ZXJ5IGFyZ3VtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBwcm9taXNlXzEuY3JlYXRlRGVmZXJyZWRQcm9taXNlKSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBvbGljeVV0aWxzLnRyeVJlamVjdCh0aGlzLnByaXNtYSwgdGhpcy5tb2RlbCwgJ3VwZGF0ZScpO1xuICAgICAgICAgICAgYXJncyA9ICgwLCB1dGlsc18xLmNsb25lKShhcmdzKTtcbiAgICAgICAgICAgIHRoaXMucG9saWN5VXRpbHMuaW5qZWN0QXV0aEd1YXJkQXNXaGVyZSh0aGlzLnByaXNtYSwgYXJncywgdGhpcy5tb2RlbCwgJ3VwZGF0ZScpO1xuICAgICAgICAgICAgYXJncy5kYXRhID0gdGhpcy52YWxpZGF0ZVVwZGF0ZUlucHV0U2NoZW1hKHRoaXMubW9kZWwsIGFyZ3MuZGF0YSk7XG4gICAgICAgICAgICBjb25zdCBlbnRpdHlDaGVja2VyID0gdGhpcy5wb2xpY3lVdGlscy5nZXRFbnRpdHlDaGVja2VyKHRoaXMubW9kZWwsICd1cGRhdGUnKTtcbiAgICAgICAgICAgIGNvbnN0IGNhblByb2NlZWRXaXRob3V0VHJhbnNhY3Rpb24gPSBcbiAgICAgICAgICAgIC8vIG5vIHBvc3QtdXBkYXRlIHJ1bGVzXG4gICAgICAgICAgICAhdGhpcy5wb2xpY3lVdGlscy5oYXNBdXRoR3VhcmQodGhpcy5tb2RlbCwgJ3Bvc3RVcGRhdGUnKSAmJlxuICAgICAgICAgICAgICAgIC8vIG5vIFpvZCBzY2hlbWFcbiAgICAgICAgICAgICAgICAhdGhpcy5wb2xpY3lVdGlscy5nZXRab2RTY2hlbWEodGhpcy5tb2RlbCkgJiZcbiAgICAgICAgICAgICAgICAvLyBubyBlbnRpdHkgY2hlY2tlclxuICAgICAgICAgICAgICAgICFlbnRpdHlDaGVja2VyO1xuICAgICAgICAgICAgaWYgKGNhblByb2NlZWRXaXRob3V0VHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBwcm9jZWVkIHdpdGhvdXQgYSB0cmFuc2FjdGlvblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZExvZ1F1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oYFtwb2xpY3ldIFxcYHVwZGF0ZU1hbnlcXGAgJHt0aGlzLm1vZGVsfTogJHsoMCwgdXRpbHNfMS5mb3JtYXRPYmplY3QpKGFyZ3MpfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlbENsaWVudC51cGRhdGVNYW55KGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29sbGVjdCBwb3N0LXVwZGF0ZSBjaGVja3NcbiAgICAgICAgICAgIGNvbnN0IHBvc3RXcml0ZUNoZWNrcyA9IFtdO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlVdGlscy50cmFuc2FjdGlvbih0aGlzLnByaXNtYSwgKHR4KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gY29sbGVjdCBwcmUtdXBkYXRlIHZhbHVlc1xuICAgICAgICAgICAgICAgIGxldCBzZWxlY3QgPSB0aGlzLnBvbGljeVV0aWxzLm1ha2VJZFNlbGVjdGlvbih0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVWYWx1ZVNlbGVjdCA9IHRoaXMucG9saWN5VXRpbHMuZ2V0UHJlVmFsdWVTZWxlY3QodGhpcy5tb2RlbCk7XG4gICAgICAgICAgICAgICAgaWYgKHByZVZhbHVlU2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2VsZWN0KSwgcHJlVmFsdWVTZWxlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBtZXJnZSBzZWxlY3Rpb24gcmVxdWlyZWQgZm9yIHJ1bm5pbmcgYWRkaXRpb25hbCBjaGVja2VyXG4gICAgICAgICAgICAgICAgY29uc3QgZW50aXR5Q2hlY2tlciA9IHRoaXMucG9saWN5VXRpbHMuZ2V0RW50aXR5Q2hlY2tlcih0aGlzLm1vZGVsLCAndXBkYXRlJyk7XG4gICAgICAgICAgICAgICAgaWYgKGVudGl0eUNoZWNrZXIgPT09IG51bGwgfHwgZW50aXR5Q2hlY2tlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZW50aXR5Q2hlY2tlci5zZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3QgPSAoMCwgZGVlcG1lcmdlXzEuZGVmYXVsdCkoc2VsZWN0LCBlbnRpdHlDaGVja2VyLnNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFNldFF1ZXJ5ID0geyBzZWxlY3QsIHdoZXJlOiBhcmdzLndoZXJlIH07XG4gICAgICAgICAgICAgICAgdGhpcy5wb2xpY3lVdGlscy5pbmplY3RBdXRoR3VhcmRBc1doZXJlKHR4LCBjdXJyZW50U2V0UXVlcnksIHRoaXMubW9kZWwsICd1cGRhdGUnKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG91bGRMb2dRdWVyeSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKGBbcG9saWN5XSBcXGBmaW5kTWFueVxcYCAke3RoaXMubW9kZWx9OiAkeygwLCB1dGlsc18xLmZvcm1hdE9iamVjdCkoY3VycmVudFNldFF1ZXJ5KX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGNhbmRpZGF0ZXMgPSB5aWVsZCB0eFt0aGlzLm1vZGVsXS5maW5kTWFueShjdXJyZW50U2V0UXVlcnkpO1xuICAgICAgICAgICAgICAgIGlmIChlbnRpdHlDaGVja2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbHRlciBjYW5kaWRhdGVzIHdpdGggYWRkaXRpb25hbCBjaGVja2VyIGFuZCBidWlsZCBhbiBpZCBmaWx0ZXJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgciA9IHRoaXMuYnVpbGRJZEZpbHRlcldpdGhFbnRpdHlDaGVja2VyKGNhbmRpZGF0ZXMsIGVudGl0eUNoZWNrZXIuZnVuYyk7XG4gICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMgPSByLmZpbHRlcmVkQ2FuZGlkYXRlcztcbiAgICAgICAgICAgICAgICAgICAgLy8gbWVyZ2UgaWQgZmlsdGVyIGludG8gdXBkYXRlJ3Mgd2hlcmUgY2xhdXNlXG4gICAgICAgICAgICAgICAgICAgIGFyZ3Mud2hlcmUgPSBhcmdzLndoZXJlID8geyBBTkQ6IFthcmdzLndoZXJlLCByLmlkRmlsdGVyXSB9IDogci5pZEZpbHRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zdFdyaXRlQ2hlY2tzLnB1c2goLi4uY2FuZGlkYXRlcy5tYXAoKHByZVZhbHVlKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBtb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiAncG9zdFVwZGF0ZScsXG4gICAgICAgICAgICAgICAgICAgIHVuaXF1ZUZpbHRlcjogdGhpcy5wb2xpY3lVdGlscy5nZXRFbnRpdHlJZHModGhpcy5tb2RlbCwgcHJlVmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICBwcmVWYWx1ZTogcHJlVmFsdWVTZWxlY3QgPyBwcmVWYWx1ZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgICAgIC8vIHByb2NlZWQgd2l0aCB0aGUgdXBkYXRlXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkTG9nUXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgW3BvbGljeV0gXFxgdXBkYXRlTWFueVxcYCBpbiB0eCBmb3IgJHt0aGlzLm1vZGVsfTogJHsoMCwgdXRpbHNfMS5mb3JtYXRPYmplY3QpKGFyZ3MpfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0eFt0aGlzLm1vZGVsXS51cGRhdGVNYW55KGFyZ3MpO1xuICAgICAgICAgICAgICAgIC8vIHJ1biBwb3N0LXdyaXRlIGNoZWNrc1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucnVuUG9zdFdyaXRlQ2hlY2tzKHBvc3RXcml0ZUNoZWNrcywgdHgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cHNlcnQoYXJncykge1xuICAgICAgICBpZiAoIWFyZ3MpIHtcbiAgICAgICAgICAgIHRocm93ICgwLCB1dGlsc18xLnByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvcikodGhpcy5wcmlzbWEsIHRoaXMucHJpc21hTW9kdWxlLCAncXVlcnkgYXJndW1lbnQgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFyZ3Mud2hlcmUpIHtcbiAgICAgICAgICAgIHRocm93ICgwLCB1dGlsc18xLnByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvcikodGhpcy5wcmlzbWEsIHRoaXMucHJpc21hTW9kdWxlLCAnd2hlcmUgZmllbGQgaXMgcmVxdWlyZWQgaW4gcXVlcnkgYXJndW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFyZ3MuY3JlYXRlKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgdXRpbHNfMS5wcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IpKHRoaXMucHJpc21hLCB0aGlzLnByaXNtYU1vZHVsZSwgJ2NyZWF0ZSBmaWVsZCBpcyByZXF1aXJlZCBpbiBxdWVyeSBhcmd1bWVudCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYXJncy51cGRhdGUpIHtcbiAgICAgICAgICAgIHRocm93ICgwLCB1dGlsc18xLnByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvcikodGhpcy5wcmlzbWEsIHRoaXMucHJpc21hTW9kdWxlLCAndXBkYXRlIGZpZWxkIGlzIHJlcXVpcmVkIGluIHF1ZXJ5IGFyZ3VtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBwcm9taXNlXzEuY3JlYXRlRGVmZXJyZWRQcm9taXNlKSgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLnBvbGljeVV0aWxzLnRyeVJlamVjdCh0aGlzLnByaXNtYSwgdGhpcy5tb2RlbCwgJ2NyZWF0ZScpO1xuICAgICAgICAgICAgdGhpcy5wb2xpY3lVdGlscy50cnlSZWplY3QodGhpcy5wcmlzbWEsIHRoaXMubW9kZWwsICd1cGRhdGUnKTtcbiAgICAgICAgICAgIGFyZ3MgPSAoMCwgdXRpbHNfMS5jbG9uZSkoYXJncyk7XG4gICAgICAgICAgICAvLyBXZSBjYW4gY2FsbCB0aGUgbmF0aXZlIFwidXBzZXJ0XCIgYmVjYXVzZSB3ZSBjYW4ndCB0ZWxsIGlmIGFuIGVudGl0eSB3YXMgY3JlYXRlZCBvciB1cGRhdGVkXG4gICAgICAgICAgICAvLyBmb3IgZG9pbmcgcG9zdC13cml0ZSBjaGVjayBhY2NvcmRpbmdseS4gSW5zdGVhZCwgZGVjb21wb3NlIGl0IGludG8gY3JlYXRlIG9yIHVwZGF0ZS5cbiAgICAgICAgICAgIGNvbnN0IHsgcmVzdWx0LCBlcnJvciB9ID0geWllbGQgdGhpcy5xdWVyeVV0aWxzLnRyYW5zYWN0aW9uKHRoaXMucHJpc21hLCAodHgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHdoZXJlLCBjcmVhdGUsIHVwZGF0ZSB9ID0gYXJncywgcmVzdCA9IF9fcmVzdChhcmdzLCBbXCJ3aGVyZVwiLCBcImNyZWF0ZVwiLCBcInVwZGF0ZVwiXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSB5aWVsZCB0aGlzLnBvbGljeVV0aWxzLmNoZWNrRXhpc3RlbmNlKHR4LCB0aGlzLm1vZGVsLCB3aGVyZSk7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBjYXNlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVzdWx0LCBwb3N0V3JpdGVDaGVja3MgfSA9IHlpZWxkIHRoaXMuZG9VcGRhdGUoT2JqZWN0LmFzc2lnbih7IHdoZXJlOiB0aGlzLnBvbGljeVV0aWxzLmNvbXBvc2VDb21wb3VuZFVuaXF1ZUZpZWxkKHRoaXMubW9kZWwsIGV4aXN0aW5nKSwgZGF0YTogdXBkYXRlIH0sIHJlc3QpLCB0eCk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucnVuUG9zdFdyaXRlQ2hlY2tzKHBvc3RXcml0ZUNoZWNrcywgdHgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wb2xpY3lVdGlscy5yZWFkQmFjayh0eCwgdGhpcy5tb2RlbCwgJ3VwZGF0ZScsIGFyZ3MsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgY2FzZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHJlc3VsdCwgcG9zdFdyaXRlQ2hlY2tzIH0gPSB5aWVsZCB0aGlzLmRvQ3JlYXRlKHRoaXMubW9kZWwsIE9iamVjdC5hc3NpZ24oeyBkYXRhOiBjcmVhdGUgfSwgcmVzdCksIHR4KTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5ydW5Qb3N0V3JpdGVDaGVja3MocG9zdFdyaXRlQ2hlY2tzLCB0eCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBvbGljeVV0aWxzLnJlYWRCYWNrKHR4LCB0aGlzLm1vZGVsLCAnY3JlYXRlJywgYXJncywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLy8jZW5kcmVnaW9uXG4gICAgLy8jcmVnaW9uIERlbGV0ZVxuICAgIC8vIFwiZGVsZXRlXCIgd29ya3MgYWdhaW5zdCBhIHNpbmdsZSBlbnRpdHksIGFuZCBpcyByZWplY3RlZCBpZiB0aGUgZW50aXR5IGZhaWxzIHBvbGljeSBjaGVjay5cbiAgICAvLyBcImRlbGV0ZU1hbnlcIiB3b3JrcyBhZ2FpbnN0IGEgc2V0IG9mIGVudGl0aWVzLCBlbnRpdGllcyB0aGF0IGZhaWwgcG9saWN5IGNoZWNrIGFyZSBmaWx0ZXJlZCBvdXQuXG4gICAgZGVsZXRlKGFyZ3MpIHtcbiAgICAgICAgaWYgKCFhcmdzKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgdXRpbHNfMS5wcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IpKHRoaXMucHJpc21hLCB0aGlzLnByaXNtYU1vZHVsZSwgJ3F1ZXJ5IGFyZ3VtZW50IGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhcmdzLndoZXJlKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgdXRpbHNfMS5wcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IpKHRoaXMucHJpc21hLCB0aGlzLnByaXNtYU1vZHVsZSwgJ3doZXJlIGZpZWxkIGlzIHJlcXVpcmVkIGluIHF1ZXJ5IGFyZ3VtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBwcm9taXNlXzEuY3JlYXRlRGVmZXJyZWRQcm9taXNlKSgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLnBvbGljeVV0aWxzLnRyeVJlamVjdCh0aGlzLnByaXNtYSwgdGhpcy5tb2RlbCwgJ2RlbGV0ZScpO1xuICAgICAgICAgICAgY29uc3QgeyByZXN1bHQsIGVycm9yIH0gPSB5aWVsZCB0aGlzLnF1ZXJ5VXRpbHMudHJhbnNhY3Rpb24odGhpcy5wcmlzbWEsICh0eCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIC8vIGRvIGEgcmVhZC1iYWNrIGJlZm9yZSBkZWxldGVcbiAgICAgICAgICAgICAgICBjb25zdCByID0geWllbGQgdGhpcy5wb2xpY3lVdGlscy5yZWFkQmFjayh0eCwgdGhpcy5tb2RlbCwgJ2RlbGV0ZScsIGFyZ3MsIGFyZ3Mud2hlcmUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gci5lcnJvcjtcbiAgICAgICAgICAgICAgICBjb25zdCByZWFkID0gci5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZXhpc3RlbmNlXG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5wb2xpY3lVdGlscy5jaGVja0V4aXN0ZW5jZSh0eCwgdGhpcy5tb2RlbCwgYXJncy53aGVyZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy8gaW5qZWN0IGRlbGV0ZSBndWFyZFxuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucG9saWN5VXRpbHMuY2hlY2tQb2xpY3lGb3JVbmlxdWUodGhpcy5tb2RlbCwgYXJncy53aGVyZSwgJ2RlbGV0ZScsIHR4LCBhcmdzKTtcbiAgICAgICAgICAgICAgICAvLyBwcm9jZWVkIHdpdGggdGhlIGRlbGV0aW9uXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkTG9nUXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgW3BvbGljeV0gXFxgZGVsZXRlXFxgICR7dGhpcy5tb2RlbH06XFxuJHsoMCwgdXRpbHNfMS5mb3JtYXRPYmplY3QpKGFyZ3MpfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB5aWVsZCB0eFt0aGlzLm1vZGVsXS5kZWxldGUoYXJncyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiByZWFkLCBlcnJvciB9O1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGRlbGV0ZU1hbnkoYXJncykge1xuICAgICAgICByZXR1cm4gKDAsIHByb21pc2VfMS5jcmVhdGVEZWZlcnJlZFByb21pc2UpKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucG9saWN5VXRpbHMudHJ5UmVqZWN0KHRoaXMucHJpc21hLCB0aGlzLm1vZGVsLCAnZGVsZXRlJyk7XG4gICAgICAgICAgICAvLyBpbmplY3QgcG9saWN5IGNvbmRpdGlvbnNcbiAgICAgICAgICAgIGFyZ3MgPSAoMCwgdXRpbHNfMS5jbG9uZSkoYXJncyk7XG4gICAgICAgICAgICB0aGlzLnBvbGljeVV0aWxzLmluamVjdEF1dGhHdWFyZEFzV2hlcmUodGhpcy5wcmlzbWEsIGFyZ3MsIHRoaXMubW9kZWwsICdkZWxldGUnKTtcbiAgICAgICAgICAgIGNvbnN0IGVudGl0eUNoZWNrZXIgPSB0aGlzLnBvbGljeVV0aWxzLmdldEVudGl0eUNoZWNrZXIodGhpcy5tb2RlbCwgJ2RlbGV0ZScpO1xuICAgICAgICAgICAgaWYgKGVudGl0eUNoZWNrZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBhZGRpdGlvbmFsIGNoZWNrZXIgZXhpc3RzLCBuZWVkIHRvIHJ1biBkZWxldGlvbiBpbnNpZGUgYSB0cmFuc2FjdGlvblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5VXRpbHMudHJhbnNhY3Rpb24odGhpcy5wcmlzbWEsICh0eCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIHRoZSBkZWxldGUgY2FuZGlkYXRlcywgc2VsZWN0aW5nIGlkIGZpZWxkcyBhbmQgZmllbGRzIG5lZWRlZCBmb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gcnVubmluZyB0aGUgYWRkaXRpb25hbCBjaGVja2VyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjYW5kaWRhdGVTZWxlY3QgPSB0aGlzLnBvbGljeVV0aWxzLm1ha2VJZFNlbGVjdGlvbih0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudGl0eUNoZWNrZXIuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZVNlbGVjdCA9ICgwLCBkZWVwbWVyZ2VfMS5kZWZhdWx0KShjYW5kaWRhdGVTZWxlY3QsIGVudGl0eUNoZWNrZXIuc2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZExvZ1F1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKGBbcG9saWN5XSBcXGBmaW5kTWFueVxcYCAke3RoaXMubW9kZWx9OiAkeygwLCB1dGlsc18xLmZvcm1hdE9iamVjdCkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZXJlOiBhcmdzLndoZXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdDogY2FuZGlkYXRlU2VsZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSl9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FuZGlkYXRlcyA9IHlpZWxkIHR4W3RoaXMubW9kZWxdLmZpbmRNYW55KHsgd2hlcmU6IGFyZ3Mud2hlcmUsIHNlbGVjdDogY2FuZGlkYXRlU2VsZWN0IH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBidWlsZCBhIElEIGZpbHRlciBiYXNlZCBvbiBpZCB2YWx1ZXMgZmlsdGVyZWQgYnkgdGhlIGFkZGl0aW9uYWwgY2hlY2tlclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGlkRmlsdGVyIH0gPSB0aGlzLmJ1aWxkSWRGaWx0ZXJXaXRoRW50aXR5Q2hlY2tlcihjYW5kaWRhdGVzLCBlbnRpdHlDaGVja2VyLmZ1bmMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBtZXJnZSB0aGUgSUQgZmlsdGVyIGludG8gdGhlIHdoZXJlIGNsYXVzZVxuICAgICAgICAgICAgICAgICAgICBhcmdzLndoZXJlID0gYXJncy53aGVyZSA/IHsgQU5EOiBbYXJncy53aGVyZSwgaWRGaWx0ZXJdIH0gOiBpZEZpbHRlcjtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmluYWxseSwgY29uZHVjdCB0aGUgZGVsZXRpb24gd2l0aCB0aGUgY29tYmluZWQgd2hlcmUgY2xhdXNlXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZExvZ1F1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKGBbcG9saWN5XSBcXGBkZWxldGVNYW55XFxgIGluIHR4IGZvciAke3RoaXMubW9kZWx9OlxcbiR7KDAsIHV0aWxzXzEuZm9ybWF0T2JqZWN0KShhcmdzKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHhbdGhpcy5tb2RlbF0uZGVsZXRlTWFueShhcmdzKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjb25kdWN0IHRoZSBkZWxldGlvbiBkaXJlY3RseVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZExvZ1F1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oYFtwb2xpY3ldIFxcYGRlbGV0ZU1hbnlcXGAgJHt0aGlzLm1vZGVsfTpcXG4keygwLCB1dGlsc18xLmZvcm1hdE9iamVjdCkoYXJncyl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGVsQ2xpZW50LmRlbGV0ZU1hbnkoYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyNlbmRyZWdpb25cbiAgICAvLyNyZWdpb24gQWdncmVnYXRpb25cbiAgICBhZ2dyZWdhdGUoYXJncykge1xuICAgICAgICBpZiAoIWFyZ3MpIHtcbiAgICAgICAgICAgIHRocm93ICgwLCB1dGlsc18xLnByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvcikodGhpcy5wcmlzbWEsIHRoaXMucHJpc21hTW9kdWxlLCAncXVlcnkgYXJndW1lbnQgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIHByb21pc2VfMS5jcmVhdGVEZWZlcnJlZFByb21pc2UpKCgpID0+IHtcbiAgICAgICAgICAgIGFyZ3MgPSAoMCwgdXRpbHNfMS5jbG9uZSkoYXJncyk7XG4gICAgICAgICAgICAvLyBpbmplY3QgcG9saWN5IGNvbmRpdGlvbnNcbiAgICAgICAgICAgIHRoaXMucG9saWN5VXRpbHMuaW5qZWN0QXV0aEd1YXJkQXNXaGVyZSh0aGlzLnByaXNtYSwgYXJncywgdGhpcy5tb2RlbCwgJ3JlYWQnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZExvZ1F1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgW3BvbGljeV0gXFxgYWdncmVnYXRlXFxgICR7dGhpcy5tb2RlbH06XFxuJHsoMCwgdXRpbHNfMS5mb3JtYXRPYmplY3QpKGFyZ3MpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZWxDbGllbnQuYWdncmVnYXRlKGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ3JvdXBCeShhcmdzKSB7XG4gICAgICAgIGlmICghYXJncykge1xuICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxzXzEucHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yKSh0aGlzLnByaXNtYSwgdGhpcy5wcmlzbWFNb2R1bGUsICdxdWVyeSBhcmd1bWVudCBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgcHJvbWlzZV8xLmNyZWF0ZURlZmVycmVkUHJvbWlzZSkoKCkgPT4ge1xuICAgICAgICAgICAgYXJncyA9ICgwLCB1dGlsc18xLmNsb25lKShhcmdzKTtcbiAgICAgICAgICAgIC8vIGluamVjdCBwb2xpY3kgY29uZGl0aW9uc1xuICAgICAgICAgICAgdGhpcy5wb2xpY3lVdGlscy5pbmplY3RBdXRoR3VhcmRBc1doZXJlKHRoaXMucHJpc21hLCBhcmdzLCB0aGlzLm1vZGVsLCAncmVhZCcpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkTG9nUXVlcnkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKGBbcG9saWN5XSBcXGBncm91cEJ5XFxgICR7dGhpcy5tb2RlbH06XFxuJHsoMCwgdXRpbHNfMS5mb3JtYXRPYmplY3QpKGFyZ3MpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZWxDbGllbnQuZ3JvdXBCeShhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvdW50KGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuICgwLCBwcm9taXNlXzEuY3JlYXRlRGVmZXJyZWRQcm9taXNlKSgoKSA9PiB7XG4gICAgICAgICAgICAvLyBpbmplY3QgcG9saWN5IGNvbmRpdGlvbnNcbiAgICAgICAgICAgIGFyZ3MgPSBhcmdzID8gKDAsIHV0aWxzXzEuY2xvbmUpKGFyZ3MpIDoge307XG4gICAgICAgICAgICB0aGlzLnBvbGljeVV0aWxzLmluamVjdEF1dGhHdWFyZEFzV2hlcmUodGhpcy5wcmlzbWEsIGFyZ3MsIHRoaXMubW9kZWwsICdyZWFkJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5zaG91bGRMb2dRdWVyeSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oYFtwb2xpY3ldIFxcYGNvdW50XFxgICR7dGhpcy5tb2RlbH06XFxuJHsoMCwgdXRpbHNfMS5mb3JtYXRPYmplY3QpKGFyZ3MpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZWxDbGllbnQuY291bnQoYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyNlbmRyZWdpb25cbiAgICAvLyNyZWdpb24gU3Vic2NyaWJlIChQcmlzbWEgUHVsc2UpXG4gICAgc3Vic2NyaWJlKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuICgwLCBwcm9taXNlXzEuY3JlYXRlRGVmZXJyZWRQcm9taXNlKSgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZWFkR3VhcmQgPSB0aGlzLnBvbGljeVV0aWxzLmdldEF1dGhHdWFyZCh0aGlzLnByaXNtYSwgdGhpcy5tb2RlbCwgJ3JlYWQnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvbGljeVV0aWxzLmlzVHJ1ZShyZWFkR3VhcmQpKSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gbmVlZCB0byBpbmplY3RcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG91bGRMb2dRdWVyeSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKGBbcG9saWN5XSBcXGBzdWJzY3JpYmVcXGAgJHt0aGlzLm1vZGVsfTpcXG4keygwLCB1dGlsc18xLmZvcm1hdE9iamVjdCkoYXJncyl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGVsQ2xpZW50LnN1YnNjcmliZShhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYXJncykge1xuICAgICAgICAgICAgICAgIC8vIGluY2x1ZGUgYWxsXG4gICAgICAgICAgICAgICAgYXJncyA9IHsgY3JlYXRlOiB7fSwgdXBkYXRlOiB7fSwgZGVsZXRlOiB7fSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmdzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyAoMCwgdXRpbHNfMS5wcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IpKHRoaXMucHJpc21hLCB0aGlzLnByaXNtYU1vZHVsZSwgJ2FyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhhcmdzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5jbHVkZSBhbGxcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IHsgY3JlYXRlOiB7fSwgdXBkYXRlOiB7fSwgZGVsZXRlOiB7fSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9ICgwLCB1dGlsc18xLmNsb25lKShhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpbmplY3QgaW50byBzdWJzY3JpYmUgY29uZGl0aW9uc1xuICAgICAgICAgICAgaWYgKGFyZ3MuY3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgYXJncy5jcmVhdGUuYWZ0ZXIgPSB0aGlzLnBvbGljeVV0aWxzLmFuZChhcmdzLmNyZWF0ZS5hZnRlciwgcmVhZEd1YXJkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhcmdzLnVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIGFyZ3MudXBkYXRlLmFmdGVyID0gdGhpcy5wb2xpY3lVdGlscy5hbmQoYXJncy51cGRhdGUuYWZ0ZXIsIHJlYWRHdWFyZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXJncy5kZWxldGUpIHtcbiAgICAgICAgICAgICAgICBhcmdzLmRlbGV0ZS5iZWZvcmUgPSB0aGlzLnBvbGljeVV0aWxzLmFuZChhcmdzLmRlbGV0ZS5iZWZvcmUsIHJlYWRHdWFyZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zaG91bGRMb2dRdWVyeSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oYFtwb2xpY3ldIFxcYHN1YnNjcmliZVxcYCAke3RoaXMubW9kZWx9OlxcbiR7KDAsIHV0aWxzXzEuZm9ybWF0T2JqZWN0KShhcmdzKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGVsQ2xpZW50LnN1YnNjcmliZShhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuICAgIC8vI3JlZ2lvbiBDaGVja1xuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gb3BlcmF0aW9uIGlzIHBvc3NpYmx5IGFsbG93ZWQgYnkgdGhlIHBvbGljeSwgd2l0aG91dCBxdWVyeWluZyB0aGUgZGF0YWJhc2UuXG4gICAgICogQHBhcmFtIG9wZXJhdGlvbiBUaGUgQ1JVRCBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIGZpZWxkVmFsdWVzIEV4dHJhIGZpZWxkIHZhbHVlIGZpbHRlcnMgdG8gYmUgY29tYmluZWQgd2l0aCB0aGUgcG9saWN5IGNvbnN0cmFpbnRzLlxuICAgICAqL1xuICAgIGNoZWNrKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgcHJvbWlzZV8xLmNyZWF0ZURlZmVycmVkUHJvbWlzZSkoKCkgPT4gdGhpcy5kb0NoZWNrKGFyZ3MpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRvQ2hlY2soYXJncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCFbJ2NyZWF0ZScsICdyZWFkJywgJ3VwZGF0ZScsICdkZWxldGUnXS5pbmNsdWRlcyhhcmdzLm9wZXJhdGlvbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAoMCwgdXRpbHNfMS5wcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IpKHRoaXMucHJpc21hLCB0aGlzLnByaXNtYU1vZHVsZSwgYEludmFsaWQgXCJvcGVyYXRpb25cIiAke2FyZ3Mub3BlcmF0aW9ufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNvbnN0cmFpbnQgPSB0aGlzLnBvbGljeVV0aWxzLmdldENoZWNrZXJDb25zdHJhaW50KHRoaXMubW9kZWwsIGFyZ3Mub3BlcmF0aW9uKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc3RyYWludCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0cmFpbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXJncy53aGVyZSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbWJpbmUgcnVudGltZSBmaWx0ZXJzIHdpdGggZ2VuZXJhdGVkIGNvbnN0cmFpbnRzXG4gICAgICAgICAgICAgICAgY29uc3QgZXh0cmFDb25zdHJhaW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2ZpZWxkLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYXJncy53aGVyZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxzXzEucHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yKSh0aGlzLnByaXNtYSwgdGhpcy5wcmlzbWFNb2R1bGUsIGBVc2luZyBcIm51bGxcIiBhcyBmaWx0ZXIgdmFsdWUgaXMgbm90IHN1cHBvcnRlZCB5ZXRgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZEluZm8gPSAoMCwgY3Jvc3NfMS5yZXF1aXJlRmllbGQpKHRoaXMubW9kZWxNZXRhLCB0aGlzLm1vZGVsLCBmaWVsZCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbGF0aW9uIGFuZCBhcnJheSBmaWVsZHMgYXJlIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkSW5mby5pc0RhdGFNb2RlbCB8fCBmaWVsZEluZm8uaXNBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxzXzEucHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yKSh0aGlzLnByaXNtYSwgdGhpcy5wcmlzbWFNb2R1bGUsIGBQcm92aWRpbmcgZmlsdGVyIGZvciBmaWVsZCBcIiR7ZmllbGR9XCIgaXMgbm90IHN1cHBvcnRlZC4gT25seSBzY2FsYXIgZmllbGRzIGFyZSBhbGxvd2VkLmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIG1hcCBmaWVsZCB0eXBlIHRvIGNvbnN0cmFpbnQgdHlwZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZFR5cGUgPSAoMCwgdHNfcGF0dGVybl8xLm1hdGNoKShmaWVsZEluZm8udHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC53aXRoKHRzX3BhdHRlcm5fMS5QLnVuaW9uKCdJbnQnLCAnQmlnSW50JywgJ0Zsb2F0JywgJ0RlY2ltYWwnKSwgKCkgPT4gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgICAgICAgICAud2l0aCgnU3RyaW5nJywgKCkgPT4gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgICAgICAud2l0aCgnQm9vbGVhbicsICgpID0+ICdib29sZWFuJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vdGhlcndpc2UoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxzXzEucHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yKSh0aGlzLnByaXNtYSwgdGhpcy5wcmlzbWFNb2R1bGUsIGBQcm92aWRpbmcgZmlsdGVyIGZvciBmaWVsZCBcIiR7ZmllbGR9XCIgaXMgbm90IHN1cHBvcnRlZC4gT25seSBudW1iZXIsIHN0cmluZywgYW5kIGJvb2xlYW4gZmllbGRzIGFyZSBhbGxvd2VkLmApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgdmFsdWUgdHlwZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZVR5cGUgIT09ICdudW1iZXInICYmIHZhbHVlVHlwZSAhPT0gJ3N0cmluZycgJiYgdmFsdWVUeXBlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICgwLCB1dGlsc18xLnByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvcikodGhpcy5wcmlzbWEsIHRoaXMucHJpc21hTW9kdWxlLCBgSW52YWxpZCB2YWx1ZSB0eXBlIGZvciBmaWVsZCBcIiR7ZmllbGR9XCIuIE9ubHkgbnVtYmVyLCBzdHJpbmcgb3IgYm9vbGVhbiBpcyBhbGxvd2VkLmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZFR5cGUgIT09IHZhbHVlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxzXzEucHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yKSh0aGlzLnByaXNtYSwgdGhpcy5wcmlzbWFNb2R1bGUsIGBJbnZhbGlkIHZhbHVlIHR5cGUgZm9yIGZpZWxkIFwiJHtmaWVsZH1cIi4gRXhwZWN0ZWQgXCIke2ZpZWxkVHlwZX1cIi5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBudW1iZXIgdmFsaWRpdHlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSB8fCB2YWx1ZSA8IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAoMCwgdXRpbHNfMS5wcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IpKHRoaXMucHJpc21hLCB0aGlzLnByaXNtYU1vZHVsZSwgYEludmFsaWQgdmFsdWUgZm9yIGZpZWxkIFwiJHtmaWVsZH1cIi4gT25seSBub24tbmVnYXRpdmUgaW50ZWdlcnMgYXJlIGFsbG93ZWQuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gYnVpbGQgYSBjb25zdHJhaW50XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhQ29uc3RyYWludHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBraW5kOiAnZXEnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogeyBraW5kOiAndmFyaWFibGUnLCBuYW1lOiBmaWVsZCwgdHlwZTogZmllbGRUeXBlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogeyBraW5kOiAndmFsdWUnLCB2YWx1ZSwgdHlwZTogZmllbGRUeXBlIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXh0cmFDb25zdHJhaW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbWJpbmUgdGhlIGNvbnN0cmFpbnRzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQgPSB7IGtpbmQ6ICdhbmQnLCBjaGlsZHJlbjogW2NvbnN0cmFpbnQsIC4uLmV4dHJhQ29uc3RyYWludHNdIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2hlY2sgc2F0aXNmaWFiaWxpdHlcbiAgICAgICAgICAgIHJldHVybiBuZXcgY29uc3RyYWludF9zb2x2ZXJfMS5Db25zdHJhaW50U29sdmVyKCkuY2hlY2tTYXQoY29uc3RyYWludCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyNlbmRyZWdpb25cbiAgICAvLyNyZWdpb24gVXRpbHNcbiAgICBnZXQgc2hvdWxkTG9nUXVlcnkoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICEhKChfYSA9IHRoaXMub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvZ1ByaXNtYVF1ZXJ5KSAmJiB0aGlzLmxvZ2dlci5lbmFibGVkKCdpbmZvJyk7XG4gICAgfVxuICAgIHJ1blBvc3RXcml0ZUNoZWNrcyhwb3N0V3JpdGVDaGVja3MsIGRiKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChwb3N0V3JpdGVDaGVja3MubWFwKChfYSkgPT4gX19hd2FpdGVyKHRoaXMsIFtfYV0sIHZvaWQgMCwgZnVuY3Rpb24qICh7IG1vZGVsLCBvcGVyYXRpb24sIHVuaXF1ZUZpbHRlciwgcHJlVmFsdWUgfSkgeyByZXR1cm4gdGhpcy5wb2xpY3lVdGlscy5jaGVja1BvbGljeUZvclVuaXF1ZShtb2RlbCwgdW5pcXVlRmlsdGVyLCBvcGVyYXRpb24sIGRiLCB1bmRlZmluZWQsIHByZVZhbHVlKTsgfSkpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlcXVpcmVCYWNrTGluayhmaWVsZEluZm8pIHtcbiAgICAgICAgKDAsIHRpbnlfaW52YXJpYW50XzEuZGVmYXVsdCkoZmllbGRJbmZvLmJhY2tMaW5rLCBgYmFjayBsaW5rIG5vdCBmb3VuZCBmb3IgZmllbGQgJHtmaWVsZEluZm8ubmFtZX1gKTtcbiAgICAgICAgcmV0dXJuICgwLCBjcm9zc18xLnJlcXVpcmVGaWVsZCkodGhpcy5tb2RlbE1ldGEsIGZpZWxkSW5mby50eXBlLCBmaWVsZEluZm8uYmFja0xpbmspO1xuICAgIH1cbiAgICBtZXJnZVRvUGFyZW50KHBhcmVudCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAocGFyZW50W2tleV0pIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmVudFtrZXldKSkge1xuICAgICAgICAgICAgICAgIHBhcmVudFtrZXldLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50W2tleV0gPSBbcGFyZW50W2tleV0sIHZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudFtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlRnJvbVBhcmVudChwYXJlbnQsIGtleSwgZGF0YSkge1xuICAgICAgICBpZiAocGFyZW50W2tleV0gPT09IGRhdGEpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBwYXJlbnRba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhcmVudFtrZXldKSkge1xuICAgICAgICAgICAgY29uc3QgaWR4ID0gcGFyZW50W2tleV0uaW5kZXhPZihkYXRhKTtcbiAgICAgICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgICAgICAgIHBhcmVudFtrZXldLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRba2V5XS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcmVudFtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBidWlsZElkRmlsdGVyV2l0aEVudGl0eUNoZWNrZXIoY2FuZGlkYXRlcywgZW50aXR5Q2hlY2tlcikge1xuICAgICAgICBjb25zdCBmaWx0ZXJlZENhbmRpZGF0ZXMgPSBjYW5kaWRhdGVzLmZpbHRlcigodmFsdWUpID0+IHsgdmFyIF9hOyByZXR1cm4gZW50aXR5Q2hlY2tlcih2YWx1ZSwgeyB1c2VyOiAoX2EgPSB0aGlzLmNvbnRleHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51c2VyIH0pOyB9KTtcbiAgICAgICAgY29uc3QgaWRGaWVsZHMgPSB0aGlzLnBvbGljeVV0aWxzLmdldElkRmllbGRzKHRoaXMubW9kZWwpO1xuICAgICAgICBsZXQgaWRGaWx0ZXI7XG4gICAgICAgIGlmIChpZEZpZWxkcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlkRmlsdGVyID0geyBbaWRGaWVsZHNbMF0ubmFtZV06IHsgaW46IGZpbHRlcmVkQ2FuZGlkYXRlcy5tYXAoKHgpID0+IHhbaWRGaWVsZHNbMF0ubmFtZV0pIH0gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlkRmlsdGVyID0geyBBTkQ6IGZpbHRlcmVkQ2FuZGlkYXRlcy5tYXAoKHgpID0+IHRoaXMucG9saWN5VXRpbHMuZ2V0SWRGaWVsZFZhbHVlcyh0aGlzLm1vZGVsLCB4KSkgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmaWx0ZXJlZENhbmRpZGF0ZXMsIGlkRmlsdGVyIH07XG4gICAgfVxufVxuZXhwb3J0cy5Qb2xpY3lQcm94eUhhbmRsZXIgPSBQb2xpY3lQcm94eUhhbmRsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYW5kbGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/policy/handler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/policy/index.js":
/*!*********************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/policy/index.js ***!
  \*********************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* eslint-disable @typescript-eslint/no-explicit-any */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.withPolicy = void 0;\nconst cross_1 = __webpack_require__(/*! ../../cross */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/cross/index.js\");\nconst validation_1 = __webpack_require__(/*! ../../validation */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/validation.js\");\nconst logger_1 = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/logger.js\");\nconst proxy_1 = __webpack_require__(/*! ../proxy */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/proxy.js\");\nconst handler_1 = __webpack_require__(/*! ./handler */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/policy/handler.js\");\n/**\n * Gets an enhanced Prisma client with access policy check.\n *\n * @param prisma The original Prisma client\n * @param context The policy evaluation context\n * @param policy The policy definition, will be loaded from default location if not provided\n * @param modelMeta The model metadata, will be loaded from default location if not provided\n *\n * @private\n */\nfunction withPolicy(prisma, options, context) {\n    const { modelMeta, policy } = options;\n    // validate user context\n    const userContext = context === null || context === void 0 ? void 0 : context.user;\n    if (userContext && modelMeta.authModel) {\n        const idFields = (0, cross_1.getIdFields)(modelMeta, modelMeta.authModel);\n        if (!(0, validation_1.hasAllFields)(context.user, idFields.map((f) => f.name))) {\n            throw new Error(`Invalid user context: must have valid ID field ${idFields.map((f) => `\"${f.name}\"`).join(', ')}`);\n        }\n        // validate user context for fields used in policy expressions\n        const authSelector = policy.authSelector;\n        if (authSelector) {\n            Object.keys(authSelector).forEach((f) => {\n                if (!(f in userContext)) {\n                    const logger = new logger_1.Logger(prisma);\n                    logger.warn(`User context does not have field \"${f}\" used in policy rules`);\n                }\n            });\n        }\n    }\n    return (0, proxy_1.makeProxy)(prisma, modelMeta, (_prisma, model) => new handler_1.PolicyProxyHandler(_prisma, model, options, context), 'policy', options === null || options === void 0 ? void 0 : options.errorTransformer);\n}\nexports.withPolicy = withPolicy;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHplbnN0YWNraHErcnVudGltZUAyLjIuNF9AcHJpc21hK2NsaWVudEA1LjE3LjBfcHJpc21hQDUuMTcuMF8vbm9kZV9tb2R1bGVzL0B6ZW5zdGFja2hxL3J1bnRpbWUvZW5oYW5jZW1lbnRzL3BvbGljeS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixnQkFBZ0IsbUJBQU8sQ0FBQyw4SkFBYTtBQUNyQyxxQkFBcUIsbUJBQU8sQ0FBQyxrS0FBa0I7QUFDL0MsaUJBQWlCLG1CQUFPLENBQUMsb0tBQVc7QUFDcEMsZ0JBQWdCLG1CQUFPLENBQUMsa0tBQVU7QUFDbEMsa0JBQWtCLG1CQUFPLENBQUMsNEtBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsd0JBQXdCLE9BQU8sZUFBZTtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxFQUFFO0FBQ3ZFO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hcmJsaXNtL25leHQtanMvLi9ub2RlX21vZHVsZXMvLnBucG0vQHplbnN0YWNraHErcnVudGltZUAyLjIuNF9AcHJpc21hK2NsaWVudEA1LjE3LjBfcHJpc21hQDUuMTcuMF8vbm9kZV9tb2R1bGVzL0B6ZW5zdGFja2hxL3J1bnRpbWUvZW5oYW5jZW1lbnRzL3BvbGljeS9pbmRleC5qcz8zODg5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy53aXRoUG9saWN5ID0gdm9pZCAwO1xuY29uc3QgY3Jvc3NfMSA9IHJlcXVpcmUoXCIuLi8uLi9jcm9zc1wiKTtcbmNvbnN0IHZhbGlkYXRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi92YWxpZGF0aW9uXCIpO1xuY29uc3QgbG9nZ2VyXzEgPSByZXF1aXJlKFwiLi4vbG9nZ2VyXCIpO1xuY29uc3QgcHJveHlfMSA9IHJlcXVpcmUoXCIuLi9wcm94eVwiKTtcbmNvbnN0IGhhbmRsZXJfMSA9IHJlcXVpcmUoXCIuL2hhbmRsZXJcIik7XG4vKipcbiAqIEdldHMgYW4gZW5oYW5jZWQgUHJpc21hIGNsaWVudCB3aXRoIGFjY2VzcyBwb2xpY3kgY2hlY2suXG4gKlxuICogQHBhcmFtIHByaXNtYSBUaGUgb3JpZ2luYWwgUHJpc21hIGNsaWVudFxuICogQHBhcmFtIGNvbnRleHQgVGhlIHBvbGljeSBldmFsdWF0aW9uIGNvbnRleHRcbiAqIEBwYXJhbSBwb2xpY3kgVGhlIHBvbGljeSBkZWZpbml0aW9uLCB3aWxsIGJlIGxvYWRlZCBmcm9tIGRlZmF1bHQgbG9jYXRpb24gaWYgbm90IHByb3ZpZGVkXG4gKiBAcGFyYW0gbW9kZWxNZXRhIFRoZSBtb2RlbCBtZXRhZGF0YSwgd2lsbCBiZSBsb2FkZWQgZnJvbSBkZWZhdWx0IGxvY2F0aW9uIGlmIG5vdCBwcm92aWRlZFxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHdpdGhQb2xpY3kocHJpc21hLCBvcHRpb25zLCBjb250ZXh0KSB7XG4gICAgY29uc3QgeyBtb2RlbE1ldGEsIHBvbGljeSB9ID0gb3B0aW9ucztcbiAgICAvLyB2YWxpZGF0ZSB1c2VyIGNvbnRleHRcbiAgICBjb25zdCB1c2VyQ29udGV4dCA9IGNvbnRleHQgPT09IG51bGwgfHwgY29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGV4dC51c2VyO1xuICAgIGlmICh1c2VyQ29udGV4dCAmJiBtb2RlbE1ldGEuYXV0aE1vZGVsKSB7XG4gICAgICAgIGNvbnN0IGlkRmllbGRzID0gKDAsIGNyb3NzXzEuZ2V0SWRGaWVsZHMpKG1vZGVsTWV0YSwgbW9kZWxNZXRhLmF1dGhNb2RlbCk7XG4gICAgICAgIGlmICghKDAsIHZhbGlkYXRpb25fMS5oYXNBbGxGaWVsZHMpKGNvbnRleHQudXNlciwgaWRGaWVsZHMubWFwKChmKSA9PiBmLm5hbWUpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHVzZXIgY29udGV4dDogbXVzdCBoYXZlIHZhbGlkIElEIGZpZWxkICR7aWRGaWVsZHMubWFwKChmKSA9PiBgXCIke2YubmFtZX1cImApLmpvaW4oJywgJyl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdmFsaWRhdGUgdXNlciBjb250ZXh0IGZvciBmaWVsZHMgdXNlZCBpbiBwb2xpY3kgZXhwcmVzc2lvbnNcbiAgICAgICAgY29uc3QgYXV0aFNlbGVjdG9yID0gcG9saWN5LmF1dGhTZWxlY3RvcjtcbiAgICAgICAgaWYgKGF1dGhTZWxlY3Rvcikge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXV0aFNlbGVjdG9yKS5mb3JFYWNoKChmKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCEoZiBpbiB1c2VyQ29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nZ2VyID0gbmV3IGxvZ2dlcl8xLkxvZ2dlcihwcmlzbWEpO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgVXNlciBjb250ZXh0IGRvZXMgbm90IGhhdmUgZmllbGQgXCIke2Z9XCIgdXNlZCBpbiBwb2xpY3kgcnVsZXNgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKDAsIHByb3h5XzEubWFrZVByb3h5KShwcmlzbWEsIG1vZGVsTWV0YSwgKF9wcmlzbWEsIG1vZGVsKSA9PiBuZXcgaGFuZGxlcl8xLlBvbGljeVByb3h5SGFuZGxlcihfcHJpc21hLCBtb2RlbCwgb3B0aW9ucywgY29udGV4dCksICdwb2xpY3knLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZXJyb3JUcmFuc2Zvcm1lcik7XG59XG5leHBvcnRzLndpdGhQb2xpY3kgPSB3aXRoUG9saWN5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/policy/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/policy/policy-utils.js":
/*!****************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/policy/policy-utils.js ***!
  \****************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/* eslint-disable @typescript-eslint/no-explicit-any */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PolicyUtil = void 0;\nconst deepcopy_1 = __importDefault(__webpack_require__(/*! deepcopy */ \"(rsc)/./node_modules/.pnpm/deepcopy@2.1.0/node_modules/deepcopy/index.mjs\"));\nconst deepmerge_1 = __importDefault(__webpack_require__(/*! deepmerge */ \"(rsc)/./node_modules/.pnpm/deepmerge@4.3.1/node_modules/deepmerge/dist/cjs.js\"));\nconst lower_case_first_1 = __webpack_require__(/*! lower-case-first */ \"(rsc)/./node_modules/.pnpm/lower-case-first@2.0.2/node_modules/lower-case-first/dist.es2015/index.js\");\nconst upper_case_first_1 = __webpack_require__(/*! upper-case-first */ \"(rsc)/./node_modules/.pnpm/upper-case-first@2.0.2/node_modules/upper-case-first/dist.es2015/index.js\");\nconst zod_validation_error_1 = __webpack_require__(/*! zod-validation-error */ \"(rsc)/./node_modules/.pnpm/zod-validation-error@1.5.0_zod@3.23.8/node_modules/zod-validation-error/dist/esm/index.js\");\nconst constants_1 = __webpack_require__(/*! ../../constants */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/constants.js\");\nconst cross_1 = __webpack_require__(/*! ../../cross */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/cross/index.js\");\nconst version_1 = __webpack_require__(/*! ../../version */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/version.js\");\nconst logger_1 = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/logger.js\");\nconst query_utils_1 = __webpack_require__(/*! ../query-utils */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/query-utils.js\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/utils.js\");\n/**\n * Access policy enforcement utilities\n */\nclass PolicyUtil extends query_utils_1.QueryUtils {\n    constructor(db, options, context, shouldLogQuery = false) {\n        super(db, options);\n        this.db = db;\n        this.shouldLogQuery = shouldLogQuery;\n        //#endregion\n        //#region Auth guard\n        this.FULL_OPEN_MODEL_POLICY = {\n            modelLevel: {\n                read: { guard: true },\n                create: { guard: true, inputChecker: true },\n                update: { guard: true },\n                delete: { guard: true },\n                postUpdate: { guard: true },\n            },\n        };\n        this.logger = new logger_1.Logger(db);\n        this.user = context === null || context === void 0 ? void 0 : context.user;\n        ({\n            modelMeta: this.modelMeta,\n            policy: this.policy,\n            zodSchemas: this.zodSchemas,\n            prismaModule: this.prismaModule,\n        } = options);\n    }\n    //#region Logical operators\n    /**\n     * Creates a conjunction of a list of query conditions.\n     */\n    and(...conditions) {\n        const filtered = conditions.filter((c) => c !== undefined);\n        if (filtered.length === 0) {\n            return this.makeTrue();\n        }\n        else if (filtered.length === 1) {\n            return this.reduce(filtered[0]);\n        }\n        else {\n            return this.reduce({ AND: filtered });\n        }\n    }\n    /**\n     * Creates a disjunction of a list of query conditions.\n     */\n    or(...conditions) {\n        const filtered = conditions.filter((c) => c !== undefined);\n        if (filtered.length === 0) {\n            return this.makeFalse();\n        }\n        else if (filtered.length === 1) {\n            return this.reduce(filtered[0]);\n        }\n        else {\n            return this.reduce({ OR: filtered });\n        }\n    }\n    /**\n     * Creates a negation of a query condition.\n     */\n    not(condition) {\n        if (condition === undefined) {\n            return this.makeTrue();\n        }\n        else if (typeof condition === 'boolean') {\n            return this.reduce(!condition);\n        }\n        else {\n            return this.reduce({ NOT: condition });\n        }\n    }\n    // Static True/False conditions\n    // https://www.prisma.io/docs/concepts/components/prisma-client/null-and-undefined#the-effect-of-null-and-undefined-on-conditionals\n    isTrue(condition) {\n        if (condition === null || condition === undefined) {\n            return false;\n        }\n        else {\n            return ((typeof condition === 'object' && Object.keys(condition).length === 0) ||\n                ('AND' in condition && Array.isArray(condition.AND) && condition.AND.length === 0));\n        }\n    }\n    isFalse(condition) {\n        if (condition === null || condition === undefined) {\n            return false;\n        }\n        else {\n            return 'OR' in condition && Array.isArray(condition.OR) && condition.OR.length === 0;\n        }\n    }\n    makeTrue() {\n        return { AND: [] };\n    }\n    makeFalse() {\n        return { OR: [] };\n    }\n    reduce(condition) {\n        if (condition === true || condition === undefined) {\n            return this.makeTrue();\n        }\n        if (condition === false) {\n            return this.makeFalse();\n        }\n        if (condition === null) {\n            return condition;\n        }\n        const result = {};\n        for (const [key, value] of Object.entries(condition)) {\n            if (this.isFalse(result)) {\n                // already false, no need to continue\n                break;\n            }\n            if (value === null || value === undefined) {\n                result[key] = value;\n                continue;\n            }\n            switch (key) {\n                case 'AND': {\n                    const children = (0, cross_1.enumerate)(value)\n                        .map((c) => this.reduce(c))\n                        .filter((c) => c !== undefined && !this.isTrue(c));\n                    if (children.length === 0) {\n                        result[key] = []; // true\n                    }\n                    else if (children.some((c) => this.isFalse(c))) {\n                        result['OR'] = []; // false\n                    }\n                    else {\n                        if (!this.isTrue({ AND: result[key] })) {\n                            // use AND only if it's not already true\n                            result[key] = !Array.isArray(value) && children.length === 1 ? children[0] : children;\n                        }\n                    }\n                    break;\n                }\n                case 'OR': {\n                    const children = (0, cross_1.enumerate)(value)\n                        .map((c) => this.reduce(c))\n                        .filter((c) => c !== undefined && !this.isFalse(c));\n                    if (children.length === 0) {\n                        result[key] = []; // false\n                    }\n                    else if (children.some((c) => this.isTrue(c))) {\n                        result['AND'] = []; // true\n                    }\n                    else {\n                        if (!this.isFalse({ OR: result[key] })) {\n                            // use OR only if it's not already false\n                            result[key] = !Array.isArray(value) && children.length === 1 ? children[0] : children;\n                        }\n                    }\n                    break;\n                }\n                case 'NOT': {\n                    const children = (0, cross_1.enumerate)(value)\n                        .map((c) => this.reduce(c))\n                        .filter((c) => c !== undefined && !this.isFalse(c));\n                    if (children.length === 0) {\n                        // all clauses are false, result is a constant true,\n                        // thus eliminated (not adding into result)\n                    }\n                    else if (children.some((c) => this.isTrue(c))) {\n                        // some clauses are true, result is a constant false,\n                        // eliminate all other keys and set entire condition to false\n                        Object.keys(result).forEach((k) => delete result[k]);\n                        result['OR'] = []; // this will cause the outer loop to exit too\n                    }\n                    else {\n                        result[key] = !Array.isArray(value) && children.length === 1 ? children[0] : children;\n                    }\n                    break;\n                }\n                default: {\n                    const booleanKeys = ['AND', 'OR', 'NOT', 'is', 'isNot', 'none', 'every', 'some'];\n                    if (typeof value === 'object' &&\n                        value &&\n                        // recurse only if the value has at least one boolean key\n                        Object.keys(value).some((k) => booleanKeys.includes(k))) {\n                        result[key] = this.reduce(value);\n                    }\n                    else {\n                        result[key] = value;\n                    }\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n    getModelPolicyDef(model) {\n        if (this.options.kinds && !this.options.kinds.includes('policy')) {\n            // policy enhancement not enabled, return an fully open guard\n            return this.FULL_OPEN_MODEL_POLICY;\n        }\n        const def = this.policy.policy[(0, lower_case_first_1.lowerCaseFirst)(model)];\n        if (!def) {\n            throw this.unknownError(`unable to load policy guard for ${model}`);\n        }\n        return def;\n    }\n    getModelGuardForOperation(model, operation) {\n        var _a;\n        const def = this.getModelPolicyDef(model);\n        return (_a = def.modelLevel[operation].guard) !== null && _a !== void 0 ? _a : true;\n    }\n    /**\n     * Gets pregenerated authorization guard object for a given model and operation.\n     *\n     * @returns true if operation is unconditionally allowed, false if unconditionally denied,\n     * otherwise returns a guard object\n     */\n    getAuthGuard(db, model, operation, preValue) {\n        const guard = this.getModelGuardForOperation(model, operation);\n        // constant guard\n        if (typeof guard === 'boolean') {\n            return this.reduce(guard);\n        }\n        // invoke guard function\n        const r = guard({ user: this.user, preValue }, db);\n        return this.reduce(r);\n    }\n    /**\n     * Get field-level read auth guard\n     */\n    getFieldReadAuthGuard(db, model, field) {\n        var _a, _b, _c;\n        const def = this.getModelPolicyDef(model);\n        const guard = (_c = (_b = (_a = def.fieldLevel) === null || _a === void 0 ? void 0 : _a.read) === null || _b === void 0 ? void 0 : _b[field]) === null || _c === void 0 ? void 0 : _c.guard;\n        if (guard === undefined) {\n            // field access is allowed by default\n            return this.makeTrue();\n        }\n        if (typeof guard === 'boolean') {\n            return this.reduce(guard);\n        }\n        const r = guard({ user: this.user }, db);\n        return this.reduce(r);\n    }\n    /**\n     * Get field-level read auth guard that overrides the model-level\n     */\n    getFieldOverrideReadAuthGuard(db, model, field) {\n        var _a, _b, _c;\n        const def = this.getModelPolicyDef(model);\n        const guard = (_c = (_b = (_a = def.fieldLevel) === null || _a === void 0 ? void 0 : _a.read) === null || _b === void 0 ? void 0 : _b[field]) === null || _c === void 0 ? void 0 : _c.overrideGuard;\n        if (guard === undefined) {\n            // field access is denied by default in override mode\n            return this.makeFalse();\n        }\n        if (typeof guard === 'boolean') {\n            return this.reduce(guard);\n        }\n        const r = guard({ user: this.user }, db);\n        return this.reduce(r);\n    }\n    /**\n     * Get field-level update auth guard\n     */\n    getFieldUpdateAuthGuard(db, model, field) {\n        var _a, _b, _c;\n        const def = this.getModelPolicyDef(model);\n        const guard = (_c = (_b = (_a = def.fieldLevel) === null || _a === void 0 ? void 0 : _a.update) === null || _b === void 0 ? void 0 : _b[field]) === null || _c === void 0 ? void 0 : _c.guard;\n        if (guard === undefined) {\n            // field access is allowed by default\n            return this.makeTrue();\n        }\n        if (typeof guard === 'boolean') {\n            return this.reduce(guard);\n        }\n        const r = guard({ user: this.user }, db);\n        return this.reduce(r);\n    }\n    /**\n     * Get field-level update auth guard that overrides the model-level\n     */\n    getFieldOverrideUpdateAuthGuard(db, model, field) {\n        var _a, _b, _c;\n        const def = this.getModelPolicyDef(model);\n        const guard = (_c = (_b = (_a = def.fieldLevel) === null || _a === void 0 ? void 0 : _a.update) === null || _b === void 0 ? void 0 : _b[field]) === null || _c === void 0 ? void 0 : _c.overrideGuard;\n        if (guard === undefined) {\n            // field access is denied by default in override mode\n            return this.makeFalse();\n        }\n        if (typeof guard === 'boolean') {\n            return this.reduce(guard);\n        }\n        const r = guard({ user: this.user }, db);\n        return this.reduce(r);\n    }\n    /**\n     * Checks if the given model has a policy guard for the given operation.\n     */\n    hasAuthGuard(model, operation) {\n        const guard = this.getModelGuardForOperation(model, operation);\n        return typeof guard !== 'boolean' || guard !== true;\n    }\n    /**\n     * Checks if the given model has any field-level override policy guard for the given operation.\n     */\n    hasOverrideAuthGuard(model, operation) {\n        var _a;\n        if (operation !== 'read' && operation !== 'update') {\n            return false;\n        }\n        const def = this.getModelPolicyDef(model);\n        if ((_a = def.fieldLevel) === null || _a === void 0 ? void 0 : _a[operation]) {\n            return Object.values(def.fieldLevel[operation]).some((f) => f.overrideGuard !== undefined || f.overrideEntityChecker !== undefined);\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * Checks model creation policy based on static analysis to the input args.\n     *\n     * @returns boolean if static analysis is enough to determine the result, undefined if not\n     */\n    checkInputGuard(model, args, operation) {\n        const def = this.getModelPolicyDef(model);\n        const guard = def.modelLevel[operation].inputChecker;\n        if (guard === undefined) {\n            return undefined;\n        }\n        if (typeof guard === 'boolean') {\n            return guard;\n        }\n        return guard(args, { user: this.user });\n    }\n    /**\n     * Injects model auth guard as where clause.\n     */\n    injectAuthGuardAsWhere(db, args, model, operation) {\n        let guard = this.getAuthGuard(db, model, operation);\n        if (operation === 'update' && args) {\n            // merge field-level policy guards\n            const fieldUpdateGuard = this.getFieldUpdateGuards(db, model, args);\n            if (fieldUpdateGuard.rejectedByField) {\n                // rejected\n                args.where = this.makeFalse();\n                return false;\n            }\n            else {\n                if (fieldUpdateGuard.guard) {\n                    // merge field-level guard\n                    guard = this.and(guard, fieldUpdateGuard.guard);\n                }\n                if (fieldUpdateGuard.overrideGuard) {\n                    // merge field-level override guard on the top level\n                    guard = this.or(guard, fieldUpdateGuard.overrideGuard);\n                }\n            }\n        }\n        if (operation === 'read') {\n            // merge field-level read override guards\n            const fieldReadOverrideGuard = this.getFieldReadGuards(db, model, args);\n            if (fieldReadOverrideGuard) {\n                guard = this.or(guard, fieldReadOverrideGuard);\n            }\n        }\n        if (this.isFalse(guard)) {\n            args.where = this.makeFalse();\n            return false;\n        }\n        let mergedGuard = guard;\n        if (args.where) {\n            // inject into relation fields:\n            //   to-many: some/none/every\n            //   to-one: direct-conditions/is/isNot\n            mergedGuard = this.injectReadGuardForRelationFields(db, model, args.where, guard);\n        }\n        args.where = this.and(args.where, mergedGuard);\n        return true;\n    }\n    // Injects guard for relation fields nested in `payload`. The `modelGuard` parameter represents the model-level guard for `model`.\n    // The function returns a modified copy of `modelGuard` with field-level policies combined.\n    injectReadGuardForRelationFields(db, model, payload, modelGuard) {\n        if (!payload || typeof payload !== 'object' || Object.keys(payload).length === 0) {\n            return modelGuard;\n        }\n        const allFieldGuards = [];\n        const allFieldOverrideGuards = [];\n        for (const [field, subPayload] of Object.entries(payload)) {\n            if (!subPayload) {\n                continue;\n            }\n            allFieldGuards.push(this.getFieldReadAuthGuard(db, model, field));\n            allFieldOverrideGuards.push(this.getFieldOverrideReadAuthGuard(db, model, field));\n            const fieldInfo = (0, cross_1.resolveField)(this.modelMeta, model, field);\n            if (fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.isDataModel) {\n                if (fieldInfo.isArray) {\n                    this.injectReadGuardForToManyField(db, fieldInfo, subPayload);\n                }\n                else {\n                    this.injectReadGuardForToOneField(db, fieldInfo, subPayload);\n                }\n            }\n        }\n        // all existing field-level guards must be true\n        const mergedGuard = this.and(...allFieldGuards);\n        // all existing field-level override guards must be true for override to take effect; override is disabled by default\n        const mergedOverrideGuard = allFieldOverrideGuards.length === 0 ? this.makeFalse() : this.and(...allFieldOverrideGuards);\n        // (original-guard && field-level-guard) || field-level-override-guard\n        const updatedGuard = this.or(this.and(modelGuard, mergedGuard), mergedOverrideGuard);\n        return updatedGuard;\n    }\n    injectReadGuardForToManyField(db, fieldInfo, payload) {\n        const guard = this.getAuthGuard(db, fieldInfo.type, 'read');\n        if (payload.some) {\n            const mergedGuard = this.injectReadGuardForRelationFields(db, fieldInfo.type, payload.some, guard);\n            // turn \"some\" into: { some: { AND: [guard, payload.some] } }\n            payload.some = this.and(payload.some, mergedGuard);\n        }\n        if (payload.none) {\n            const mergedGuard = this.injectReadGuardForRelationFields(db, fieldInfo.type, payload.none, guard);\n            // turn none into: { none: { AND: [guard, payload.none] } }\n            payload.none = this.and(payload.none, mergedGuard);\n        }\n        if (payload.every &&\n            typeof payload.every === 'object' &&\n            // ignore empty every clause\n            Object.keys(payload.every).length > 0) {\n            const mergedGuard = this.injectReadGuardForRelationFields(db, fieldInfo.type, payload.every, guard);\n            // turn \"every\" into: { none: { AND: [guard, { NOT: payload.every }] } }\n            if (!payload.none) {\n                payload.none = {};\n            }\n            payload.none = this.and(payload.none, mergedGuard, this.not(payload.every));\n            delete payload.every;\n        }\n    }\n    injectReadGuardForToOneField(db, fieldInfo, payload) {\n        const guard = this.getAuthGuard(db, fieldInfo.type, 'read');\n        // is|isNot and flat fields conditions are mutually exclusive\n        // is and isNot can be null value\n        if (payload.is !== undefined || payload.isNot !== undefined) {\n            if (payload.is) {\n                const mergedGuard = this.injectReadGuardForRelationFields(db, fieldInfo.type, payload.is, guard);\n                // merge guard with existing \"is\": { is: { AND: [originalIs, guard] } }\n                payload.is = this.and(payload.is, mergedGuard);\n            }\n            if (payload.isNot) {\n                const mergedGuard = this.injectReadGuardForRelationFields(db, fieldInfo.type, payload.isNot, guard);\n                // merge guard with existing \"isNot\":  { isNot: { AND: [originalIsNot, guard] } }\n                payload.isNot = this.and(payload.isNot, mergedGuard);\n            }\n        }\n        else {\n            const mergedGuard = this.injectReadGuardForRelationFields(db, fieldInfo.type, payload, guard);\n            // turn direct conditions into: { is: { AND: [ originalConditions, guard ] } }\n            const combined = this.and((0, deepcopy_1.default)(payload), mergedGuard);\n            Object.keys(payload).forEach((key) => delete payload[key]);\n            payload.is = combined;\n        }\n    }\n    /**\n     * Injects auth guard for read operations.\n     */\n    injectForRead(db, model, args) {\n        // make select and include visible to the injection\n        const injected = { select: args.select, include: args.include };\n        if (!this.injectAuthGuardAsWhere(db, injected, model, 'read')) {\n            return false;\n        }\n        if (args.where) {\n            // inject into relation fields:\n            //   to-many: some/none/every\n            //   to-one: direct-conditions/is/isNot\n            this.injectReadGuardForRelationFields(db, model, args.where, {});\n        }\n        if (injected.where && Object.keys(injected.where).length > 0 && !this.isTrue(injected.where)) {\n            if (!args.where) {\n                args.where = injected.where;\n            }\n            else {\n                this.mergeWhereClause(args.where, injected.where);\n            }\n        }\n        // recursively inject read guard conditions into nested select, include, and _count\n        const hoistedConditions = this.injectNestedReadConditions(db, model, args);\n        // the injection process may generate conditions that need to be hoisted to the toplevel,\n        // if so, merge it with the existing where\n        if (hoistedConditions.length > 0) {\n            if (!args.where) {\n                args.where = this.and(...hoistedConditions);\n            }\n            else {\n                this.mergeWhereClause(args.where, this.and(...hoistedConditions));\n            }\n        }\n        return true;\n    }\n    //#endregion\n    //#region Checker\n    /**\n     * Gets checker constraints for the given model and operation.\n     */\n    getCheckerConstraint(model, operation) {\n        if (this.options.kinds && !this.options.kinds.includes('policy')) {\n            // policy enhancement not enabled, return a constant true checker result\n            return true;\n        }\n        const def = this.getModelPolicyDef(model);\n        const checker = def.modelLevel[operation].permissionChecker;\n        if (checker === undefined) {\n            throw new Error(`Generated permission checkers not found. Please make sure the \"generatePermissionChecker\" option is set to true in the \"@core/enhancer\" plugin.`);\n        }\n        if (typeof checker === 'boolean') {\n            return checker;\n        }\n        if (typeof checker !== 'function') {\n            throw this.unknownError(`invalid ${operation} checker function for ${model}`);\n        }\n        // call checker function\n        return checker({ user: this.user });\n    }\n    //#endregion\n    /**\n     * Gets unique constraints for the given model.\n     */\n    getUniqueConstraints(model) {\n        var _a, _b;\n        return (_b = (_a = this.modelMeta.models[(0, lower_case_first_1.lowerCaseFirst)(model)]) === null || _a === void 0 ? void 0 : _a.uniqueConstraints) !== null && _b !== void 0 ? _b : {};\n    }\n    injectNestedReadConditions(db, model, args) {\n        var _a;\n        const injectTarget = (_a = args.select) !== null && _a !== void 0 ? _a : args.include;\n        if (!injectTarget) {\n            return [];\n        }\n        if (injectTarget._count !== undefined) {\n            // _count needs to respect read policies of related models\n            if (injectTarget._count === true) {\n                // include count for all relations, expand to all fields\n                // so that we can inject guard conditions for each of them\n                injectTarget._count = { select: {} };\n                const modelFields = (0, cross_1.getFields)(this.modelMeta, model);\n                if (modelFields) {\n                    for (const [k, v] of Object.entries(modelFields)) {\n                        if (v.isDataModel && v.isArray) {\n                            // create an entry for to-many relation\n                            injectTarget._count.select[k] = {};\n                        }\n                    }\n                }\n            }\n            // inject conditions for each relation\n            for (const field of Object.keys(injectTarget._count.select)) {\n                if (typeof injectTarget._count.select[field] !== 'object') {\n                    injectTarget._count.select[field] = {};\n                }\n                const fieldInfo = (0, cross_1.resolveField)(this.modelMeta, model, field);\n                if (!fieldInfo) {\n                    continue;\n                }\n                // inject into the \"where\" clause inside select\n                this.injectAuthGuardAsWhere(db, injectTarget._count.select[field], fieldInfo.type, 'read');\n            }\n        }\n        // collect filter conditions that should be hoisted to the toplevel\n        const hoistedConditions = [];\n        for (const field of (0, cross_1.getModelFields)(injectTarget)) {\n            if (injectTarget[field] === false) {\n                continue;\n            }\n            const fieldInfo = (0, cross_1.resolveField)(this.modelMeta, model, field);\n            if (!fieldInfo || !fieldInfo.isDataModel) {\n                // only care about relation fields\n                continue;\n            }\n            let hoisted;\n            if (fieldInfo.isArray ||\n                // Injecting where at include/select level for nullable to-one relation is supported since Prisma 4.8.0\n                // https://github.com/prisma/prisma/discussions/20350\n                fieldInfo.isOptional) {\n                if (typeof injectTarget[field] !== 'object') {\n                    injectTarget[field] = {};\n                }\n                // inject extra condition for to-many or nullable to-one relation\n                this.injectAuthGuardAsWhere(db, injectTarget[field], fieldInfo.type, 'read');\n                // recurse\n                const subHoisted = this.injectNestedReadConditions(db, fieldInfo.type, injectTarget[field]);\n                if (subHoisted.length > 0) {\n                    // we can convert it to a where at this level\n                    injectTarget[field].where = this.and(injectTarget[field].where, ...subHoisted);\n                }\n            }\n            else {\n                // hoist non-nullable to-one filter to the parent level\n                hoisted = this.getAuthGuard(db, fieldInfo.type, 'read');\n                // recurse\n                const subHoisted = this.injectNestedReadConditions(db, fieldInfo.type, injectTarget[field]);\n                if (subHoisted.length > 0) {\n                    hoisted = this.and(hoisted, ...subHoisted);\n                }\n            }\n            if (hoisted && !this.isTrue(hoisted)) {\n                hoistedConditions.push({ [field]: hoisted });\n            }\n        }\n        return hoistedConditions;\n    }\n    /**\n     * Given a model and a unique filter, checks the operation is allowed by policies and field validations.\n     * Rejects with an error if not allowed.\n     */\n    checkPolicyForUnique(model, uniqueFilter, operation, db, args, preValue) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let guard = this.getAuthGuard(db, model, operation, preValue);\n            if (this.isFalse(guard) && !this.hasOverrideAuthGuard(model, operation)) {\n                throw this.deniedByPolicy(model, operation, `entity ${(0, utils_1.formatObject)(uniqueFilter, false)} failed policy check`, constants_1.CrudFailureReason.ACCESS_POLICY_VIOLATION);\n            }\n            let entityChecker;\n            if (operation === 'update' && args) {\n                // merge field-level policy guards\n                const fieldUpdateGuard = this.getFieldUpdateGuards(db, model, args);\n                if (fieldUpdateGuard.rejectedByField) {\n                    // rejected\n                    throw this.deniedByPolicy(model, 'update', `entity ${(0, utils_1.formatObject)(uniqueFilter, false)} failed update policy check for field \"${fieldUpdateGuard.rejectedByField}\"`, constants_1.CrudFailureReason.ACCESS_POLICY_VIOLATION);\n                }\n                if (fieldUpdateGuard.guard) {\n                    // merge field-level guard with AND\n                    guard = this.and(guard, fieldUpdateGuard.guard);\n                }\n                if (fieldUpdateGuard.overrideGuard) {\n                    // merge field-level override guard with OR\n                    guard = this.or(guard, fieldUpdateGuard.overrideGuard);\n                }\n                // field-level entity checker\n                entityChecker = fieldUpdateGuard.entityChecker;\n            }\n            // Zod schema is to be checked for \"create\" and \"postUpdate\"\n            const schema = ['create', 'postUpdate'].includes(operation) ? this.getZodSchema(model) : undefined;\n            // combine field-level entity checker with model-level\n            const modelEntityChecker = this.getEntityChecker(model, operation);\n            entityChecker = this.combineEntityChecker(entityChecker, modelEntityChecker, 'and');\n            if (this.isTrue(guard) && !schema && !entityChecker) {\n                // unconditionally allowed\n                return;\n            }\n            let select = schema\n                ? // need to validate against schema, need to fetch all fields\n                    undefined\n                : // only fetch id fields\n                    this.makeIdSelection(model);\n            if (entityChecker === null || entityChecker === void 0 ? void 0 : entityChecker.selector) {\n                if (!select) {\n                    select = this.makeAllScalarFieldSelect(model);\n                }\n                select = Object.assign(Object.assign({}, select), entityChecker.selector);\n            }\n            let where = this.clone(uniqueFilter);\n            // query args may have be of combined-id form, need to flatten it to call findFirst\n            this.flattenGeneratedUniqueField(model, where);\n            // query with policy guard\n            where = this.and(where, guard);\n            const query = { select, where };\n            if (this.shouldLogQuery) {\n                this.logger.info(`[policy] checking ${model} for ${operation}, \\`findFirst\\`:\\n${(0, utils_1.formatObject)(query)}`);\n            }\n            const result = yield db[model].findFirst(query);\n            if (!result) {\n                throw this.deniedByPolicy(model, operation, `entity ${(0, utils_1.formatObject)(uniqueFilter, false)} failed policy check`, constants_1.CrudFailureReason.ACCESS_POLICY_VIOLATION);\n            }\n            if (entityChecker) {\n                if (this.logger.enabled('info')) {\n                    this.logger.info(`[policy] running entity checker on ${model} for ${operation}`);\n                }\n                if (!entityChecker.func(result, { user: this.user, preValue })) {\n                    throw this.deniedByPolicy(model, operation, `entity ${(0, utils_1.formatObject)(uniqueFilter, false)} failed policy check`, constants_1.CrudFailureReason.ACCESS_POLICY_VIOLATION);\n                }\n            }\n            if (schema) {\n                // TODO: push down schema check to the database\n                const parseResult = schema.safeParse(result);\n                if (!parseResult.success) {\n                    const error = (0, zod_validation_error_1.fromZodError)(parseResult.error);\n                    if (this.logger.enabled('info')) {\n                        this.logger.info(`entity ${model} failed validation for operation ${operation}: ${error}`);\n                    }\n                    throw this.deniedByPolicy(model, operation, `entities ${(0, utils_1.formatObject)(uniqueFilter, false)} failed validation: [${error}]`, constants_1.CrudFailureReason.DATA_VALIDATION_VIOLATION, parseResult.error);\n                }\n            }\n        });\n    }\n    getEntityChecker(model, operation, field) {\n        var _a, _b, _c;\n        const def = this.getModelPolicyDef(model);\n        if (field) {\n            return (_c = (_b = (_a = def.fieldLevel) === null || _a === void 0 ? void 0 : _a[operation]) === null || _b === void 0 ? void 0 : _b[field]) === null || _c === void 0 ? void 0 : _c.entityChecker;\n        }\n        else {\n            return def.modelLevel[operation].entityChecker;\n        }\n    }\n    getUpdateOverrideEntityCheckerForField(model, field) {\n        var _a, _b, _c;\n        const def = this.getModelPolicyDef(model);\n        return (_c = (_b = (_a = def.fieldLevel) === null || _a === void 0 ? void 0 : _a.update) === null || _b === void 0 ? void 0 : _b[field]) === null || _c === void 0 ? void 0 : _c.overrideEntityChecker;\n    }\n    getFieldReadGuards(db, model, args) {\n        const allFields = Object.values((0, cross_1.getFields)(this.modelMeta, model));\n        // all scalar fields by default\n        let fields = allFields.filter((f) => !f.isDataModel);\n        if (args.select) {\n            // explicitly selected fields\n            fields = allFields.filter((f) => { var _a; return ((_a = args.select) === null || _a === void 0 ? void 0 : _a[f.name]) === true; });\n        }\n        else if (args.include) {\n            // included relations\n            fields.push(...allFields.filter((f) => !fields.includes(f) && args.include[f.name]));\n        }\n        if (fields.length === 0) {\n            // this can happen if only selecting pseudo fields like \"_count\"\n            return undefined;\n        }\n        const allFieldGuards = fields.map((field) => this.getFieldOverrideReadAuthGuard(db, model, field.name));\n        return this.and(...allFieldGuards);\n    }\n    getFieldUpdateGuards(db, model, args) {\n        var _a;\n        const allFieldGuards = [];\n        const allOverrideFieldGuards = [];\n        let entityChecker;\n        for (const [field, value] of Object.entries((_a = args.data) !== null && _a !== void 0 ? _a : args)) {\n            if (typeof value === 'undefined') {\n                continue;\n            }\n            const fieldInfo = (0, cross_1.resolveField)(this.modelMeta, model, field);\n            if (fieldInfo === null || fieldInfo === void 0 ? void 0 : fieldInfo.isDataModel) {\n                // relation field update should be treated as foreign key update,\n                // fetch and merge all foreign key guards\n                if (fieldInfo.isRelationOwner && fieldInfo.foreignKeyMapping) {\n                    const foreignKeys = Object.values(fieldInfo.foreignKeyMapping);\n                    for (const fk of foreignKeys) {\n                        const fieldGuard = this.getFieldUpdateAuthGuard(db, model, fk);\n                        if (this.isFalse(fieldGuard)) {\n                            return { guard: fieldGuard, rejectedByField: fk };\n                        }\n                        // add field guard\n                        allFieldGuards.push(fieldGuard);\n                        // add field override guard\n                        const overrideFieldGuard = this.getFieldOverrideUpdateAuthGuard(db, model, fk);\n                        allOverrideFieldGuards.push(overrideFieldGuard);\n                    }\n                }\n            }\n            else {\n                const fieldGuard = this.getFieldUpdateAuthGuard(db, model, field);\n                if (this.isFalse(fieldGuard)) {\n                    return { guard: fieldGuard, rejectedByField: field };\n                }\n                // add field guard\n                allFieldGuards.push(fieldGuard);\n                // add field override guard\n                const overrideFieldGuard = this.getFieldOverrideUpdateAuthGuard(db, model, field);\n                allOverrideFieldGuards.push(overrideFieldGuard);\n            }\n            // merge regular and override entity checkers with OR\n            let checker = this.getEntityChecker(model, 'update', field);\n            const overrideChecker = this.getUpdateOverrideEntityCheckerForField(model, field);\n            checker = this.combineEntityChecker(checker, overrideChecker, 'or');\n            // accumulate entity checker across fields\n            entityChecker = this.combineEntityChecker(entityChecker, checker, 'and');\n        }\n        const allFieldsCombined = this.and(...allFieldGuards);\n        const allOverrideFieldsCombined = allOverrideFieldGuards.length !== 0 ? this.and(...allOverrideFieldGuards) : undefined;\n        return {\n            guard: allFieldsCombined,\n            overrideGuard: allOverrideFieldsCombined,\n            rejectedByField: undefined,\n            entityChecker,\n        };\n    }\n    combineEntityChecker(left, right, combiner) {\n        var _a, _b;\n        if (!left) {\n            return right;\n        }\n        if (!right) {\n            return left;\n        }\n        const func = combiner === 'and'\n            ? (entity, context) => left.func(entity, context) && right.func(entity, context)\n            : (entity, context) => left.func(entity, context) || right.func(entity, context);\n        return {\n            func,\n            selector: (0, deepmerge_1.default)((_a = left.selector) !== null && _a !== void 0 ? _a : {}, (_b = right.selector) !== null && _b !== void 0 ? _b : {}),\n        };\n    }\n    /**\n     * Tries rejecting a request based on static \"false\" policy.\n     */\n    tryReject(db, model, operation) {\n        const guard = this.getAuthGuard(db, model, operation);\n        if (this.isFalse(guard) && !this.hasOverrideAuthGuard(model, operation)) {\n            throw this.deniedByPolicy(model, operation, undefined, constants_1.CrudFailureReason.ACCESS_POLICY_VIOLATION);\n        }\n    }\n    /**\n     * Checks if a model exists given a unique filter.\n     */\n    checkExistence(db_1, model_1, uniqueFilter_1) {\n        return __awaiter(this, arguments, void 0, function* (db, model, uniqueFilter, throwIfNotFound = false) {\n            uniqueFilter = this.clone(uniqueFilter);\n            this.flattenGeneratedUniqueField(model, uniqueFilter);\n            if (this.shouldLogQuery) {\n                this.logger.info(`[policy] checking ${model} existence, \\`findFirst\\`:\\n${(0, utils_1.formatObject)(uniqueFilter)}`);\n            }\n            const existing = yield db[model].findFirst({\n                where: uniqueFilter,\n                select: this.makeIdSelection(model),\n            });\n            if (!existing && throwIfNotFound) {\n                throw this.notFound(model);\n            }\n            return existing;\n        });\n    }\n    /**\n     * Returns an entity given a unique filter with read policy checked. Reject if not readable.\n     */\n    readBack(db, model, operation, selectInclude, uniqueFilter) {\n        return __awaiter(this, void 0, void 0, function* () {\n            uniqueFilter = this.clone(uniqueFilter);\n            this.flattenGeneratedUniqueField(model, uniqueFilter);\n            // make sure only select and include are picked\n            const selectIncludeClean = this.pick(selectInclude, 'select', 'include');\n            const readArgs = Object.assign(Object.assign({}, this.clone(selectIncludeClean)), { where: uniqueFilter });\n            const error = this.deniedByPolicy(model, operation, 'result is not allowed to be read back', constants_1.CrudFailureReason.RESULT_NOT_READABLE);\n            const injectResult = this.injectForRead(db, model, readArgs);\n            if (!injectResult) {\n                return { error, result: undefined };\n            }\n            // inject select needed for field-level read checks\n            this.injectReadCheckSelect(model, readArgs);\n            if (this.shouldLogQuery) {\n                this.logger.info(`[policy] checking read-back, \\`findFirst\\` ${model}:\\n${(0, utils_1.formatObject)(readArgs)}`);\n            }\n            const result = yield db[model].findFirst(readArgs);\n            if (!result) {\n                return { error, result: undefined };\n            }\n            this.postProcessForRead(result, model, selectIncludeClean);\n            return { result, error: undefined };\n        });\n    }\n    /**\n     * Injects field selection needed for checking field-level read policy check and evaluating\n     * entity checker into query args.\n     */\n    injectReadCheckSelect(model, args) {\n        // we need to recurse into relation fields before injecting the current level, because\n        // injection into current level can result in relation being selected/included, which\n        // can then cause infinite recursion when we visit relation later\n        var _a;\n        // recurse into relation fields\n        const visitTarget = (_a = args.select) !== null && _a !== void 0 ? _a : args.include;\n        if (visitTarget) {\n            for (const key of Object.keys(visitTarget)) {\n                const field = (0, cross_1.resolveField)(this.modelMeta, model, key);\n                if ((field === null || field === void 0 ? void 0 : field.isDataModel) && visitTarget[key]) {\n                    if (typeof visitTarget[key] !== 'object') {\n                        // v is \"true\", ensure it's an object\n                        visitTarget[key] = {};\n                    }\n                    this.injectReadCheckSelect(field.type, visitTarget[key]);\n                }\n            }\n        }\n        if (this.hasFieldLevelPolicy(model)) {\n            // recursively inject selection for fields needed for field-level read checks\n            const readFieldSelect = this.getFieldReadCheckSelector(model);\n            if (readFieldSelect) {\n                this.doInjectReadCheckSelect(model, args, { select: readFieldSelect });\n            }\n        }\n        const entityChecker = this.getEntityChecker(model, 'read');\n        if (entityChecker === null || entityChecker === void 0 ? void 0 : entityChecker.selector) {\n            this.doInjectReadCheckSelect(model, args, { select: entityChecker.selector });\n        }\n    }\n    doInjectReadCheckSelect(model, args, input) {\n        // omit should be ignored to avoid interfering with field selection\n        if (args.omit) {\n            delete args.omit;\n        }\n        if (!(input === null || input === void 0 ? void 0 : input.select)) {\n            return;\n        }\n        let target; // injection target\n        let isInclude = false; // if the target is include or select\n        if (args.select) {\n            target = args.select;\n            isInclude = false;\n        }\n        else if (args.include) {\n            target = args.include;\n            isInclude = true;\n        }\n        else {\n            target = args.select = this.makeAllScalarFieldSelect(model);\n            isInclude = false;\n        }\n        if (!isInclude) {\n            // merge selects\n            for (const [k, v] of Object.entries(input.select)) {\n                if (v === true) {\n                    if (!target[k]) {\n                        target[k] = true;\n                    }\n                }\n            }\n        }\n        // recurse into nested selects (relation fields)\n        for (const [k, v] of Object.entries(input.select)) {\n            if (typeof v === 'object' && (v === null || v === void 0 ? void 0 : v.select)) {\n                const field = (0, cross_1.resolveField)(this.modelMeta, model, k);\n                if (field === null || field === void 0 ? void 0 : field.isDataModel) {\n                    // recurse into relation\n                    if (isInclude && target[k] === true) {\n                        // select all fields for the relation\n                        target[k] = { select: this.makeAllScalarFieldSelect(field.type) };\n                    }\n                    else if (!target[k]) {\n                        // ensure an empty select clause\n                        target[k] = { select: {} };\n                    }\n                    // recurse\n                    this.doInjectReadCheckSelect(field.type, target[k], v);\n                }\n            }\n        }\n    }\n    makeAllScalarFieldSelect(model) {\n        const fields = this.getModelFields(model);\n        const result = {};\n        if (fields) {\n            Object.entries(fields).forEach(([k, v]) => {\n                if (!v.isDataModel) {\n                    result[k] = true;\n                }\n            });\n        }\n        return result;\n    }\n    //#endregion\n    //#region Errors\n    deniedByPolicy(model, operation, extra, reason, zodErrors) {\n        const args = { clientVersion: (0, version_1.getVersion)(), code: constants_1.PrismaErrorCode.CONSTRAINED_FAILED, meta: {} };\n        if (reason) {\n            args.meta.reason = reason;\n        }\n        if (zodErrors) {\n            args.meta.zodErrors = zodErrors;\n        }\n        return (0, utils_1.prismaClientKnownRequestError)(this.db, this.prismaModule, `denied by policy: ${model} entities failed '${operation}' check${extra ? ', ' + extra : ''}`, args);\n    }\n    notFound(model) {\n        return (0, utils_1.prismaClientKnownRequestError)(this.db, this.prismaModule, `entity not found for model ${model}`, {\n            clientVersion: (0, version_1.getVersion)(),\n            code: 'P2025',\n        });\n    }\n    //#endregion\n    //#region Misc\n    /**\n     * Gets field selection for fetching pre-update entity values for the given model.\n     */\n    getPreValueSelect(model) {\n        const def = this.getModelPolicyDef(model);\n        return def.modelLevel.postUpdate.preUpdateSelector;\n    }\n    // get a merged selector object for all field-level read policies\n    getFieldReadCheckSelector(model) {\n        var _a, _b, _c;\n        const def = this.getModelPolicyDef(model);\n        let result = {};\n        const fieldLevel = (_a = def.fieldLevel) === null || _a === void 0 ? void 0 : _a.read;\n        if (fieldLevel) {\n            for (const def of Object.values(fieldLevel)) {\n                if ((_b = def.entityChecker) === null || _b === void 0 ? void 0 : _b.selector) {\n                    result = (0, deepmerge_1.default)(result, def.entityChecker.selector);\n                }\n                if ((_c = def.overrideEntityChecker) === null || _c === void 0 ? void 0 : _c.selector) {\n                    result = (0, deepmerge_1.default)(result, def.overrideEntityChecker.selector);\n                }\n            }\n        }\n        return Object.keys(result).length > 0 ? result : undefined;\n    }\n    checkReadField(model, field, entity) {\n        var _a, _b, _c, _d, _e, _f;\n        const def = this.getModelPolicyDef(model);\n        // combine regular and override field-level entity checkers with OR\n        const checker = (_c = (_b = (_a = def.fieldLevel) === null || _a === void 0 ? void 0 : _a.read) === null || _b === void 0 ? void 0 : _b[field]) === null || _c === void 0 ? void 0 : _c.entityChecker;\n        const overrideChecker = (_f = (_e = (_d = def.fieldLevel) === null || _d === void 0 ? void 0 : _d.read) === null || _e === void 0 ? void 0 : _e[field]) === null || _f === void 0 ? void 0 : _f.overrideEntityChecker;\n        const combinedChecker = this.combineEntityChecker(checker, overrideChecker, 'or');\n        if (combinedChecker === undefined) {\n            return true;\n        }\n        else {\n            return combinedChecker.func(entity, { user: this.user });\n        }\n    }\n    hasFieldValidation(model) {\n        var _a, _b;\n        return ((_b = (_a = this.policy.validation) === null || _a === void 0 ? void 0 : _a[(0, lower_case_first_1.lowerCaseFirst)(model)]) === null || _b === void 0 ? void 0 : _b.hasValidation) === true;\n    }\n    hasFieldLevelPolicy(model) {\n        var _a, _b;\n        const def = this.getModelPolicyDef(model);\n        return Object.keys((_b = (_a = def.fieldLevel) === null || _a === void 0 ? void 0 : _a.read) !== null && _b !== void 0 ? _b : {}).length > 0;\n    }\n    /**\n     * Gets Zod schema for the given model and access kind.\n     *\n     * @param kind If undefined, returns the full schema.\n     */\n    getZodSchema(model, kind = undefined) {\n        var _a, _b;\n        if (!this.hasFieldValidation(model)) {\n            return undefined;\n        }\n        const schemaKey = `${(0, upper_case_first_1.upperCaseFirst)(model)}${kind ? 'Prisma' + (0, upper_case_first_1.upperCaseFirst)(kind) : ''}Schema`;\n        return (_b = (_a = this.zodSchemas) === null || _a === void 0 ? void 0 : _a.models) === null || _b === void 0 ? void 0 : _b[schemaKey];\n    }\n    /**\n     * Post processing checks and clean-up for read model entities.\n     */\n    postProcessForRead(data, model, queryArgs) {\n        // preserve the original data as it may be needed for checking field-level readability,\n        // while the \"data\" will be manipulated during traversal (deleting unreadable fields)\n        const origData = this.clone(data);\n        return this.doPostProcessForRead(data, model, origData, queryArgs, this.hasFieldLevelPolicy(model));\n    }\n    doPostProcessForRead(data, model, fullData, queryArgs, hasFieldLevelPolicy, path = '') {\n        var _a, _b, _c;\n        if (data === null || data === undefined) {\n            return data;\n        }\n        let filteredData = data;\n        let filteredFullData = fullData;\n        const entityChecker = this.getEntityChecker(model, 'read');\n        if (entityChecker) {\n            if (Array.isArray(data)) {\n                filteredData = [];\n                filteredFullData = [];\n                for (const [entityData, entityFullData] of (0, cross_1.zip)(data, fullData)) {\n                    if (!entityChecker.func(entityData, { user: this.user })) {\n                        if (this.shouldLogQuery) {\n                            this.logger.info(`[policy] dropping ${model} entity${path ? ' at ' + path : ''} due to entity checker`);\n                        }\n                    }\n                    else {\n                        filteredData.push(entityData);\n                        filteredFullData.push(entityFullData);\n                    }\n                }\n            }\n            else {\n                if (!entityChecker.func(data, { user: this.user })) {\n                    if (this.shouldLogQuery) {\n                        this.logger.info(`[policy] dropping ${model} entity${path ? ' at ' + path : ''} due to entity checker`);\n                    }\n                    return null;\n                }\n            }\n        }\n        for (const [entityData, entityFullData] of (0, cross_1.zip)(filteredData, filteredFullData)) {\n            if (typeof entityData !== 'object' || !entityData) {\n                continue;\n            }\n            for (const [field, fieldData] of Object.entries(entityData)) {\n                if (fieldData === undefined) {\n                    continue;\n                }\n                const fieldInfo = (0, cross_1.resolveField)(this.modelMeta, model, field);\n                if (!fieldInfo) {\n                    // could be _count, etc.\n                    continue;\n                }\n                if (((_a = queryArgs === null || queryArgs === void 0 ? void 0 : queryArgs.omit) === null || _a === void 0 ? void 0 : _a[field]) === true) {\n                    // respect `{ omit: { [field]: true } }`\n                    delete entityData[field];\n                    continue;\n                }\n                if (hasFieldLevelPolicy) {\n                    // 1. remove fields selected for checking field-level policies but not selected by the original query args\n                    // 2. evaluate field-level policies and remove fields that are not readable\n                    if (!fieldInfo.isDataModel) {\n                        // scalar field, delete unselected ones\n                        const select = queryArgs === null || queryArgs === void 0 ? void 0 : queryArgs.select;\n                        if (select && typeof select === 'object' && select[field] !== true) {\n                            // there's a select clause but this field is not included\n                            delete entityData[field];\n                            continue;\n                        }\n                    }\n                    else {\n                        // relation field, delete if not selected or included\n                        const include = queryArgs === null || queryArgs === void 0 ? void 0 : queryArgs.include;\n                        const select = queryArgs === null || queryArgs === void 0 ? void 0 : queryArgs.select;\n                        if (!(include === null || include === void 0 ? void 0 : include[field]) && !(select === null || select === void 0 ? void 0 : select[field])) {\n                            // relation field not included or selected\n                            delete entityData[field];\n                            continue;\n                        }\n                    }\n                    // delete unreadable fields\n                    if (!this.checkReadField(model, field, entityFullData)) {\n                        if (this.shouldLogQuery) {\n                            this.logger.info(`[policy] dropping unreadable field ${path ? path + '.' : ''}${field}`);\n                        }\n                        delete entityData[field];\n                        continue;\n                    }\n                }\n                if (fieldInfo.isDataModel) {\n                    // recurse into nested fields\n                    const nextArgs = (_c = ((_b = queryArgs === null || queryArgs === void 0 ? void 0 : queryArgs.select) !== null && _b !== void 0 ? _b : queryArgs === null || queryArgs === void 0 ? void 0 : queryArgs.include)) === null || _c === void 0 ? void 0 : _c[field];\n                    const nestedResult = this.doPostProcessForRead(fieldData, fieldInfo.type, entityFullData[field], nextArgs, this.hasFieldLevelPolicy(fieldInfo.type), path ? path + '.' + field : field);\n                    if (nestedResult === undefined) {\n                        delete entityData[field];\n                    }\n                    else {\n                        entityData[field] = nestedResult;\n                    }\n                }\n            }\n        }\n        return filteredData;\n    }\n    /**\n     * Clones an object and makes sure it's not empty.\n     */\n    clone(value) {\n        return value ? (0, deepcopy_1.default)(value) : {};\n    }\n    /**\n     * Replace content of `target` object with `withObject` in-place.\n     */\n    replace(target, withObject) {\n        if (!target || typeof target !== 'object' || !withObject || typeof withObject !== 'object') {\n            return;\n        }\n        // remove missing keys\n        for (const key of Object.keys(target)) {\n            if (!(key in withObject)) {\n                delete target[key];\n            }\n        }\n        // overwrite keys\n        for (const [key, value] of Object.entries(withObject)) {\n            target[key] = value;\n        }\n    }\n    /**\n     * Picks properties from an object.\n     */\n    pick(value, ...props) {\n        const v = value;\n        return props.reduce(function (result, prop) {\n            if (prop in v) {\n                result[prop] = v[prop];\n            }\n            return result;\n        }, {});\n    }\n    mergeWhereClause(where, extra) {\n        var _a;\n        if (!where) {\n            throw new Error('invalid where clause');\n        }\n        if (this.isTrue(extra)) {\n            return;\n        }\n        // instead of simply wrapping with AND, we preserve the structure\n        // of the original where clause and merge `extra` into it so that\n        // unique query can continue working\n        if (where.AND) {\n            // merge into existing AND clause\n            const conditions = Array.isArray(where.AND) ? [...where.AND] : [where.AND];\n            conditions.push(extra);\n            const combined = this.and(...conditions);\n            // make sure the merging always goes under AND\n            where.AND = (_a = combined.AND) !== null && _a !== void 0 ? _a : combined;\n        }\n        else {\n            // insert an AND clause\n            where.AND = [extra];\n        }\n    }\n    /**\n     * Given an entity data, returns an object only containing id fields.\n     */\n    getIdFieldValues(model, data) {\n        if (!data) {\n            return undefined;\n        }\n        const idFields = this.getIdFields(model);\n        return Object.fromEntries(idFields.map((f) => [f.name, data[f.name]]));\n    }\n}\nexports.PolicyUtil = PolicyUtil;\n//# sourceMappingURL=policy-utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHplbnN0YWNraHErcnVudGltZUAyLjIuNF9AcHJpc21hK2NsaWVudEA1LjE3LjBfcHJpc21hQDUuMTcuMF8vbm9kZV9tb2R1bGVzL0B6ZW5zdGFja2hxL3J1bnRpbWUvZW5oYW5jZW1lbnRzL3BvbGljeS9wb2xpY3ktdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEIsbUNBQW1DLG1CQUFPLENBQUMsMkZBQVU7QUFDckQsb0NBQW9DLG1CQUFPLENBQUMsZ0dBQVc7QUFDdkQsMkJBQTJCLG1CQUFPLENBQUMsOEhBQWtCO0FBQ3JELDJCQUEyQixtQkFBTyxDQUFDLDhIQUFrQjtBQUNyRCwrQkFBK0IsbUJBQU8sQ0FBQyxrSkFBc0I7QUFDN0Qsb0JBQW9CLG1CQUFPLENBQUMsZ0tBQWlCO0FBQzdDLGdCQUFnQixtQkFBTyxDQUFDLDhKQUFhO0FBQ3JDLGtCQUFrQixtQkFBTyxDQUFDLDRKQUFlO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLG9LQUFXO0FBQ3BDLHNCQUFzQixtQkFBTyxDQUFDLDhLQUFnQjtBQUM5QyxnQkFBZ0IsbUJBQU8sQ0FBQyxrS0FBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQywwQkFBMEIsaUNBQWlDO0FBQzNELDBCQUEwQixhQUFhO0FBQ3ZDLDBCQUEwQixhQUFhO0FBQ3ZDLDhCQUE4QixhQUFhO0FBQzNDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBLDJDQUEyQyxrQkFBa0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSw0Q0FBNEMsaUJBQWlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsTUFBTTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMkJBQTJCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVEsZUFBZSxvQkFBb0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxNQUFNO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFNBQVM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxNQUFNO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxXQUFXLHVCQUF1QixNQUFNO0FBQ3ZGO0FBQ0E7QUFDQSx5QkFBeUIsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxnREFBZ0Q7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZ0RBQWdELHdDQUF3QyxpQ0FBaUM7QUFDbE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLHNEQUFzRCxPQUFPLE1BQU0sVUFBVSxvQkFBb0IsaUNBQWlDO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxnREFBZ0Q7QUFDdEg7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLE9BQU8sTUFBTSxVQUFVO0FBQ2xHO0FBQ0Esa0RBQWtELDJCQUEyQjtBQUM3RSwwRUFBMEUsZ0RBQWdEO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsT0FBTyxrQ0FBa0MsVUFBVSxJQUFJLE1BQU07QUFDaEg7QUFDQSw0RUFBNEUsZ0RBQWdELHNCQUFzQixNQUFNO0FBQ3hKO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUSx1RkFBdUY7QUFDOUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUcsMkRBQTJEO0FBQ2xLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELE9BQU8sNkJBQTZCLHdDQUF3QztBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxxQ0FBcUMscUJBQXFCO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxNQUFNLEtBQUssb0NBQW9DO0FBQzlIO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCx5QkFBeUI7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsZ0NBQWdDO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHLE9BQU8sbUJBQW1CLFVBQVUsU0FBUywwQkFBMEI7QUFDbEw7QUFDQTtBQUNBLG9IQUFvSCxNQUFNO0FBQzFIO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGlCQUFpQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SUFBd0k7QUFDeEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4Q0FBOEMsRUFBRSxvRUFBb0U7QUFDako7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGlCQUFpQjtBQUMzRTtBQUNBLGtFQUFrRSxPQUFPLFFBQVEsMkJBQTJCO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxpQkFBaUI7QUFDakU7QUFDQSw4REFBOEQsT0FBTyxRQUFRLDJCQUEyQjtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRLGlCQUFpQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRix1QkFBdUIsRUFBRSxNQUFNO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXJibGlzbS9uZXh0LWpzLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B6ZW5zdGFja2hxK3J1bnRpbWVAMi4yLjRfQHByaXNtYStjbGllbnRANS4xNy4wX3ByaXNtYUA1LjE3LjBfL25vZGVfbW9kdWxlcy9AemVuc3RhY2tocS9ydW50aW1lL2VuaGFuY2VtZW50cy9wb2xpY3kvcG9saWN5LXV0aWxzLmpzPzlmNjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUG9saWN5VXRpbCA9IHZvaWQgMDtcbmNvbnN0IGRlZXBjb3B5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlZXBjb3B5XCIpKTtcbmNvbnN0IGRlZXBtZXJnZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWVwbWVyZ2VcIikpO1xuY29uc3QgbG93ZXJfY2FzZV9maXJzdF8xID0gcmVxdWlyZShcImxvd2VyLWNhc2UtZmlyc3RcIik7XG5jb25zdCB1cHBlcl9jYXNlX2ZpcnN0XzEgPSByZXF1aXJlKFwidXBwZXItY2FzZS1maXJzdFwiKTtcbmNvbnN0IHpvZF92YWxpZGF0aW9uX2Vycm9yXzEgPSByZXF1aXJlKFwiem9kLXZhbGlkYXRpb24tZXJyb3JcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb25zdGFudHNcIik7XG5jb25zdCBjcm9zc18xID0gcmVxdWlyZShcIi4uLy4uL2Nyb3NzXCIpO1xuY29uc3QgdmVyc2lvbl8xID0gcmVxdWlyZShcIi4uLy4uL3ZlcnNpb25cIik7XG5jb25zdCBsb2dnZXJfMSA9IHJlcXVpcmUoXCIuLi9sb2dnZXJcIik7XG5jb25zdCBxdWVyeV91dGlsc18xID0gcmVxdWlyZShcIi4uL3F1ZXJ5LXV0aWxzXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbi8qKlxuICogQWNjZXNzIHBvbGljeSBlbmZvcmNlbWVudCB1dGlsaXRpZXNcbiAqL1xuY2xhc3MgUG9saWN5VXRpbCBleHRlbmRzIHF1ZXJ5X3V0aWxzXzEuUXVlcnlVdGlscyB7XG4gICAgY29uc3RydWN0b3IoZGIsIG9wdGlvbnMsIGNvbnRleHQsIHNob3VsZExvZ1F1ZXJ5ID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIoZGIsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmRiID0gZGI7XG4gICAgICAgIHRoaXMuc2hvdWxkTG9nUXVlcnkgPSBzaG91bGRMb2dRdWVyeTtcbiAgICAgICAgLy8jZW5kcmVnaW9uXG4gICAgICAgIC8vI3JlZ2lvbiBBdXRoIGd1YXJkXG4gICAgICAgIHRoaXMuRlVMTF9PUEVOX01PREVMX1BPTElDWSA9IHtcbiAgICAgICAgICAgIG1vZGVsTGV2ZWw6IHtcbiAgICAgICAgICAgICAgICByZWFkOiB7IGd1YXJkOiB0cnVlIH0sXG4gICAgICAgICAgICAgICAgY3JlYXRlOiB7IGd1YXJkOiB0cnVlLCBpbnB1dENoZWNrZXI6IHRydWUgfSxcbiAgICAgICAgICAgICAgICB1cGRhdGU6IHsgZ3VhcmQ6IHRydWUgfSxcbiAgICAgICAgICAgICAgICBkZWxldGU6IHsgZ3VhcmQ6IHRydWUgfSxcbiAgICAgICAgICAgICAgICBwb3N0VXBkYXRlOiB7IGd1YXJkOiB0cnVlIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxvZ2dlciA9IG5ldyBsb2dnZXJfMS5Mb2dnZXIoZGIpO1xuICAgICAgICB0aGlzLnVzZXIgPSBjb250ZXh0ID09PSBudWxsIHx8IGNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRleHQudXNlcjtcbiAgICAgICAgKHtcbiAgICAgICAgICAgIG1vZGVsTWV0YTogdGhpcy5tb2RlbE1ldGEsXG4gICAgICAgICAgICBwb2xpY3k6IHRoaXMucG9saWN5LFxuICAgICAgICAgICAgem9kU2NoZW1hczogdGhpcy56b2RTY2hlbWFzLFxuICAgICAgICAgICAgcHJpc21hTW9kdWxlOiB0aGlzLnByaXNtYU1vZHVsZSxcbiAgICAgICAgfSA9IG9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyNyZWdpb24gTG9naWNhbCBvcGVyYXRvcnNcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY29uanVuY3Rpb24gb2YgYSBsaXN0IG9mIHF1ZXJ5IGNvbmRpdGlvbnMuXG4gICAgICovXG4gICAgYW5kKC4uLmNvbmRpdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZmlsdGVyZWQgPSBjb25kaXRpb25zLmZpbHRlcigoYykgPT4gYyAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKGZpbHRlcmVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFrZVRydWUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaWx0ZXJlZC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZHVjZShmaWx0ZXJlZFswXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWR1Y2UoeyBBTkQ6IGZpbHRlcmVkIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkaXNqdW5jdGlvbiBvZiBhIGxpc3Qgb2YgcXVlcnkgY29uZGl0aW9ucy5cbiAgICAgKi9cbiAgICBvciguLi5jb25kaXRpb25zKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkID0gY29uZGl0aW9ucy5maWx0ZXIoKGMpID0+IGMgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChmaWx0ZXJlZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1ha2VGYWxzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpbHRlcmVkLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVkdWNlKGZpbHRlcmVkWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZHVjZSh7IE9SOiBmaWx0ZXJlZCB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmVnYXRpb24gb2YgYSBxdWVyeSBjb25kaXRpb24uXG4gICAgICovXG4gICAgbm90KGNvbmRpdGlvbikge1xuICAgICAgICBpZiAoY29uZGl0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1ha2VUcnVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNvbmRpdGlvbiA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWR1Y2UoIWNvbmRpdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWR1Y2UoeyBOT1Q6IGNvbmRpdGlvbiB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTdGF0aWMgVHJ1ZS9GYWxzZSBjb25kaXRpb25zXG4gICAgLy8gaHR0cHM6Ly93d3cucHJpc21hLmlvL2RvY3MvY29uY2VwdHMvY29tcG9uZW50cy9wcmlzbWEtY2xpZW50L251bGwtYW5kLXVuZGVmaW5lZCN0aGUtZWZmZWN0LW9mLW51bGwtYW5kLXVuZGVmaW5lZC1vbi1jb25kaXRpb25hbHNcbiAgICBpc1RydWUoY29uZGl0aW9uKSB7XG4gICAgICAgIGlmIChjb25kaXRpb24gPT09IG51bGwgfHwgY29uZGl0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoKHR5cGVvZiBjb25kaXRpb24gPT09ICdvYmplY3QnICYmIE9iamVjdC5rZXlzKGNvbmRpdGlvbikubGVuZ3RoID09PSAwKSB8fFxuICAgICAgICAgICAgICAgICgnQU5EJyBpbiBjb25kaXRpb24gJiYgQXJyYXkuaXNBcnJheShjb25kaXRpb24uQU5EKSAmJiBjb25kaXRpb24uQU5ELmxlbmd0aCA9PT0gMCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzRmFsc2UoY29uZGl0aW9uKSB7XG4gICAgICAgIGlmIChjb25kaXRpb24gPT09IG51bGwgfHwgY29uZGl0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnT1InIGluIGNvbmRpdGlvbiAmJiBBcnJheS5pc0FycmF5KGNvbmRpdGlvbi5PUikgJiYgY29uZGl0aW9uLk9SLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYWtlVHJ1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHsgQU5EOiBbXSB9O1xuICAgIH1cbiAgICBtYWtlRmFsc2UoKSB7XG4gICAgICAgIHJldHVybiB7IE9SOiBbXSB9O1xuICAgIH1cbiAgICByZWR1Y2UoY29uZGl0aW9uKSB7XG4gICAgICAgIGlmIChjb25kaXRpb24gPT09IHRydWUgfHwgY29uZGl0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1ha2VUcnVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmRpdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1ha2VGYWxzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25kaXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25kaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGNvbmRpdGlvbikpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRmFsc2UocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgZmFsc2UsIG5vIG5lZWQgdG8gY29udGludWVcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnQU5EJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9ICgwLCBjcm9zc18xLmVudW1lcmF0ZSkodmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKChjKSA9PiB0aGlzLnJlZHVjZShjKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGMpID0+IGMgIT09IHVuZGVmaW5lZCAmJiAhdGhpcy5pc1RydWUoYykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IFtdOyAvLyB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGRyZW4uc29tZSgoYykgPT4gdGhpcy5pc0ZhbHNlKGMpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0WydPUiddID0gW107IC8vIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNUcnVlKHsgQU5EOiByZXN1bHRba2V5XSB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZSBBTkQgb25seSBpZiBpdCdzIG5vdCBhbHJlYWR5IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9ICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgPyBjaGlsZHJlblswXSA6IGNoaWxkcmVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdPUic6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSAoMCwgY3Jvc3NfMS5lbnVtZXJhdGUpKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoYykgPT4gdGhpcy5yZWR1Y2UoYykpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChjKSA9PiBjICE9PSB1bmRlZmluZWQgJiYgIXRoaXMuaXNGYWxzZShjKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gW107IC8vIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGRyZW4uc29tZSgoYykgPT4gdGhpcy5pc1RydWUoYykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbJ0FORCddID0gW107IC8vIHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0ZhbHNlKHsgT1I6IHJlc3VsdFtrZXldIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlIE9SIG9ubHkgaWYgaXQncyBub3QgYWxyZWFkeSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gIUFycmF5LmlzQXJyYXkodmFsdWUpICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSA/IGNoaWxkcmVuWzBdIDogY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ05PVCc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSAoMCwgY3Jvc3NfMS5lbnVtZXJhdGUpKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoYykgPT4gdGhpcy5yZWR1Y2UoYykpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChjKSA9PiBjICE9PSB1bmRlZmluZWQgJiYgIXRoaXMuaXNGYWxzZShjKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbCBjbGF1c2VzIGFyZSBmYWxzZSwgcmVzdWx0IGlzIGEgY29uc3RhbnQgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRodXMgZWxpbWluYXRlZCAobm90IGFkZGluZyBpbnRvIHJlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGlsZHJlbi5zb21lKChjKSA9PiB0aGlzLmlzVHJ1ZShjKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvbWUgY2xhdXNlcyBhcmUgdHJ1ZSwgcmVzdWx0IGlzIGEgY29uc3RhbnQgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlbGltaW5hdGUgYWxsIG90aGVyIGtleXMgYW5kIHNldCBlbnRpcmUgY29uZGl0aW9uIHRvIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhyZXN1bHQpLmZvckVhY2goKGspID0+IGRlbGV0ZSByZXN1bHRba10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0WydPUiddID0gW107IC8vIHRoaXMgd2lsbCBjYXVzZSB0aGUgb3V0ZXIgbG9vcCB0byBleGl0IHRvb1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAxID8gY2hpbGRyZW5bMF0gOiBjaGlsZHJlbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBib29sZWFuS2V5cyA9IFsnQU5EJywgJ09SJywgJ05PVCcsICdpcycsICdpc05vdCcsICdub25lJywgJ2V2ZXJ5JywgJ3NvbWUnXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWN1cnNlIG9ubHkgaWYgdGhlIHZhbHVlIGhhcyBhdCBsZWFzdCBvbmUgYm9vbGVhbiBrZXlcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5zb21lKChrKSA9PiBib29sZWFuS2V5cy5pbmNsdWRlcyhrKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdGhpcy5yZWR1Y2UodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZ2V0TW9kZWxQb2xpY3lEZWYobW9kZWwpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5raW5kcyAmJiAhdGhpcy5vcHRpb25zLmtpbmRzLmluY2x1ZGVzKCdwb2xpY3knKSkge1xuICAgICAgICAgICAgLy8gcG9saWN5IGVuaGFuY2VtZW50IG5vdCBlbmFibGVkLCByZXR1cm4gYW4gZnVsbHkgb3BlbiBndWFyZFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuRlVMTF9PUEVOX01PREVMX1BPTElDWTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWYgPSB0aGlzLnBvbGljeS5wb2xpY3lbKDAsIGxvd2VyX2Nhc2VfZmlyc3RfMS5sb3dlckNhc2VGaXJzdCkobW9kZWwpXTtcbiAgICAgICAgaWYgKCFkZWYpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMudW5rbm93bkVycm9yKGB1bmFibGUgdG8gbG9hZCBwb2xpY3kgZ3VhcmQgZm9yICR7bW9kZWx9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZjtcbiAgICB9XG4gICAgZ2V0TW9kZWxHdWFyZEZvck9wZXJhdGlvbihtb2RlbCwgb3BlcmF0aW9uKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgZGVmID0gdGhpcy5nZXRNb2RlbFBvbGljeURlZihtb2RlbCk7XG4gICAgICAgIHJldHVybiAoX2EgPSBkZWYubW9kZWxMZXZlbFtvcGVyYXRpb25dLmd1YXJkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHByZWdlbmVyYXRlZCBhdXRob3JpemF0aW9uIGd1YXJkIG9iamVjdCBmb3IgYSBnaXZlbiBtb2RlbCBhbmQgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBvcGVyYXRpb24gaXMgdW5jb25kaXRpb25hbGx5IGFsbG93ZWQsIGZhbHNlIGlmIHVuY29uZGl0aW9uYWxseSBkZW5pZWQsXG4gICAgICogb3RoZXJ3aXNlIHJldHVybnMgYSBndWFyZCBvYmplY3RcbiAgICAgKi9cbiAgICBnZXRBdXRoR3VhcmQoZGIsIG1vZGVsLCBvcGVyYXRpb24sIHByZVZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGd1YXJkID0gdGhpcy5nZXRNb2RlbEd1YXJkRm9yT3BlcmF0aW9uKG1vZGVsLCBvcGVyYXRpb24pO1xuICAgICAgICAvLyBjb25zdGFudCBndWFyZFxuICAgICAgICBpZiAodHlwZW9mIGd1YXJkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZHVjZShndWFyZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW52b2tlIGd1YXJkIGZ1bmN0aW9uXG4gICAgICAgIGNvbnN0IHIgPSBndWFyZCh7IHVzZXI6IHRoaXMudXNlciwgcHJlVmFsdWUgfSwgZGIpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWR1Y2Uocik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBmaWVsZC1sZXZlbCByZWFkIGF1dGggZ3VhcmRcbiAgICAgKi9cbiAgICBnZXRGaWVsZFJlYWRBdXRoR3VhcmQoZGIsIG1vZGVsLCBmaWVsZCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgZGVmID0gdGhpcy5nZXRNb2RlbFBvbGljeURlZihtb2RlbCk7XG4gICAgICAgIGNvbnN0IGd1YXJkID0gKF9jID0gKF9iID0gKF9hID0gZGVmLmZpZWxkTGV2ZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWFkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbZmllbGRdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZ3VhcmQ7XG4gICAgICAgIGlmIChndWFyZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBmaWVsZCBhY2Nlc3MgaXMgYWxsb3dlZCBieSBkZWZhdWx0XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWtlVHJ1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZ3VhcmQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVkdWNlKGd1YXJkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByID0gZ3VhcmQoeyB1c2VyOiB0aGlzLnVzZXIgfSwgZGIpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWR1Y2Uocik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBmaWVsZC1sZXZlbCByZWFkIGF1dGggZ3VhcmQgdGhhdCBvdmVycmlkZXMgdGhlIG1vZGVsLWxldmVsXG4gICAgICovXG4gICAgZ2V0RmllbGRPdmVycmlkZVJlYWRBdXRoR3VhcmQoZGIsIG1vZGVsLCBmaWVsZCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgZGVmID0gdGhpcy5nZXRNb2RlbFBvbGljeURlZihtb2RlbCk7XG4gICAgICAgIGNvbnN0IGd1YXJkID0gKF9jID0gKF9iID0gKF9hID0gZGVmLmZpZWxkTGV2ZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWFkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbZmllbGRdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Mub3ZlcnJpZGVHdWFyZDtcbiAgICAgICAgaWYgKGd1YXJkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGZpZWxkIGFjY2VzcyBpcyBkZW5pZWQgYnkgZGVmYXVsdCBpbiBvdmVycmlkZSBtb2RlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWtlRmFsc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGd1YXJkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZHVjZShndWFyZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgciA9IGd1YXJkKHsgdXNlcjogdGhpcy51c2VyIH0sIGRiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVkdWNlKHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZmllbGQtbGV2ZWwgdXBkYXRlIGF1dGggZ3VhcmRcbiAgICAgKi9cbiAgICBnZXRGaWVsZFVwZGF0ZUF1dGhHdWFyZChkYiwgbW9kZWwsIGZpZWxkKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBkZWYgPSB0aGlzLmdldE1vZGVsUG9saWN5RGVmKG1vZGVsKTtcbiAgICAgICAgY29uc3QgZ3VhcmQgPSAoX2MgPSAoX2IgPSAoX2EgPSBkZWYuZmllbGRMZXZlbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVwZGF0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2ZpZWxkXSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmd1YXJkO1xuICAgICAgICBpZiAoZ3VhcmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gZmllbGQgYWNjZXNzIGlzIGFsbG93ZWQgYnkgZGVmYXVsdFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFrZVRydWUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGd1YXJkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZHVjZShndWFyZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgciA9IGd1YXJkKHsgdXNlcjogdGhpcy51c2VyIH0sIGRiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVkdWNlKHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZmllbGQtbGV2ZWwgdXBkYXRlIGF1dGggZ3VhcmQgdGhhdCBvdmVycmlkZXMgdGhlIG1vZGVsLWxldmVsXG4gICAgICovXG4gICAgZ2V0RmllbGRPdmVycmlkZVVwZGF0ZUF1dGhHdWFyZChkYiwgbW9kZWwsIGZpZWxkKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBkZWYgPSB0aGlzLmdldE1vZGVsUG9saWN5RGVmKG1vZGVsKTtcbiAgICAgICAgY29uc3QgZ3VhcmQgPSAoX2MgPSAoX2IgPSAoX2EgPSBkZWYuZmllbGRMZXZlbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVwZGF0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2ZpZWxkXSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm92ZXJyaWRlR3VhcmQ7XG4gICAgICAgIGlmIChndWFyZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBmaWVsZCBhY2Nlc3MgaXMgZGVuaWVkIGJ5IGRlZmF1bHQgaW4gb3ZlcnJpZGUgbW9kZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFrZUZhbHNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBndWFyZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWR1Y2UoZ3VhcmQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHIgPSBndWFyZCh7IHVzZXI6IHRoaXMudXNlciB9LCBkYik7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZHVjZShyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBtb2RlbCBoYXMgYSBwb2xpY3kgZ3VhcmQgZm9yIHRoZSBnaXZlbiBvcGVyYXRpb24uXG4gICAgICovXG4gICAgaGFzQXV0aEd1YXJkKG1vZGVsLCBvcGVyYXRpb24pIHtcbiAgICAgICAgY29uc3QgZ3VhcmQgPSB0aGlzLmdldE1vZGVsR3VhcmRGb3JPcGVyYXRpb24obW9kZWwsIG9wZXJhdGlvbik7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZ3VhcmQgIT09ICdib29sZWFuJyB8fCBndWFyZCAhPT0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBtb2RlbCBoYXMgYW55IGZpZWxkLWxldmVsIG92ZXJyaWRlIHBvbGljeSBndWFyZCBmb3IgdGhlIGdpdmVuIG9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICBoYXNPdmVycmlkZUF1dGhHdWFyZChtb2RlbCwgb3BlcmF0aW9uKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKG9wZXJhdGlvbiAhPT0gJ3JlYWQnICYmIG9wZXJhdGlvbiAhPT0gJ3VwZGF0ZScpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWYgPSB0aGlzLmdldE1vZGVsUG9saWN5RGVmKG1vZGVsKTtcbiAgICAgICAgaWYgKChfYSA9IGRlZi5maWVsZExldmVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Fbb3BlcmF0aW9uXSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoZGVmLmZpZWxkTGV2ZWxbb3BlcmF0aW9uXSkuc29tZSgoZikgPT4gZi5vdmVycmlkZUd1YXJkICE9PSB1bmRlZmluZWQgfHwgZi5vdmVycmlkZUVudGl0eUNoZWNrZXIgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIG1vZGVsIGNyZWF0aW9uIHBvbGljeSBiYXNlZCBvbiBzdGF0aWMgYW5hbHlzaXMgdG8gdGhlIGlucHV0IGFyZ3MuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBib29sZWFuIGlmIHN0YXRpYyBhbmFseXNpcyBpcyBlbm91Z2ggdG8gZGV0ZXJtaW5lIHRoZSByZXN1bHQsIHVuZGVmaW5lZCBpZiBub3RcbiAgICAgKi9cbiAgICBjaGVja0lucHV0R3VhcmQobW9kZWwsIGFyZ3MsIG9wZXJhdGlvbikge1xuICAgICAgICBjb25zdCBkZWYgPSB0aGlzLmdldE1vZGVsUG9saWN5RGVmKG1vZGVsKTtcbiAgICAgICAgY29uc3QgZ3VhcmQgPSBkZWYubW9kZWxMZXZlbFtvcGVyYXRpb25dLmlucHV0Q2hlY2tlcjtcbiAgICAgICAgaWYgKGd1YXJkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBndWFyZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3VhcmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGd1YXJkKGFyZ3MsIHsgdXNlcjogdGhpcy51c2VyIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmplY3RzIG1vZGVsIGF1dGggZ3VhcmQgYXMgd2hlcmUgY2xhdXNlLlxuICAgICAqL1xuICAgIGluamVjdEF1dGhHdWFyZEFzV2hlcmUoZGIsIGFyZ3MsIG1vZGVsLCBvcGVyYXRpb24pIHtcbiAgICAgICAgbGV0IGd1YXJkID0gdGhpcy5nZXRBdXRoR3VhcmQoZGIsIG1vZGVsLCBvcGVyYXRpb24pO1xuICAgICAgICBpZiAob3BlcmF0aW9uID09PSAndXBkYXRlJyAmJiBhcmdzKSB7XG4gICAgICAgICAgICAvLyBtZXJnZSBmaWVsZC1sZXZlbCBwb2xpY3kgZ3VhcmRzXG4gICAgICAgICAgICBjb25zdCBmaWVsZFVwZGF0ZUd1YXJkID0gdGhpcy5nZXRGaWVsZFVwZGF0ZUd1YXJkcyhkYiwgbW9kZWwsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKGZpZWxkVXBkYXRlR3VhcmQucmVqZWN0ZWRCeUZpZWxkKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVqZWN0ZWRcbiAgICAgICAgICAgICAgICBhcmdzLndoZXJlID0gdGhpcy5tYWtlRmFsc2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGRVcGRhdGVHdWFyZC5ndWFyZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtZXJnZSBmaWVsZC1sZXZlbCBndWFyZFxuICAgICAgICAgICAgICAgICAgICBndWFyZCA9IHRoaXMuYW5kKGd1YXJkLCBmaWVsZFVwZGF0ZUd1YXJkLmd1YXJkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkVXBkYXRlR3VhcmQub3ZlcnJpZGVHdWFyZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtZXJnZSBmaWVsZC1sZXZlbCBvdmVycmlkZSBndWFyZCBvbiB0aGUgdG9wIGxldmVsXG4gICAgICAgICAgICAgICAgICAgIGd1YXJkID0gdGhpcy5vcihndWFyZCwgZmllbGRVcGRhdGVHdWFyZC5vdmVycmlkZUd1YXJkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJ3JlYWQnKSB7XG4gICAgICAgICAgICAvLyBtZXJnZSBmaWVsZC1sZXZlbCByZWFkIG92ZXJyaWRlIGd1YXJkc1xuICAgICAgICAgICAgY29uc3QgZmllbGRSZWFkT3ZlcnJpZGVHdWFyZCA9IHRoaXMuZ2V0RmllbGRSZWFkR3VhcmRzKGRiLCBtb2RlbCwgYXJncyk7XG4gICAgICAgICAgICBpZiAoZmllbGRSZWFkT3ZlcnJpZGVHdWFyZCkge1xuICAgICAgICAgICAgICAgIGd1YXJkID0gdGhpcy5vcihndWFyZCwgZmllbGRSZWFkT3ZlcnJpZGVHdWFyZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNGYWxzZShndWFyZCkpIHtcbiAgICAgICAgICAgIGFyZ3Mud2hlcmUgPSB0aGlzLm1ha2VGYWxzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtZXJnZWRHdWFyZCA9IGd1YXJkO1xuICAgICAgICBpZiAoYXJncy53aGVyZSkge1xuICAgICAgICAgICAgLy8gaW5qZWN0IGludG8gcmVsYXRpb24gZmllbGRzOlxuICAgICAgICAgICAgLy8gICB0by1tYW55OiBzb21lL25vbmUvZXZlcnlcbiAgICAgICAgICAgIC8vICAgdG8tb25lOiBkaXJlY3QtY29uZGl0aW9ucy9pcy9pc05vdFxuICAgICAgICAgICAgbWVyZ2VkR3VhcmQgPSB0aGlzLmluamVjdFJlYWRHdWFyZEZvclJlbGF0aW9uRmllbGRzKGRiLCBtb2RlbCwgYXJncy53aGVyZSwgZ3VhcmQpO1xuICAgICAgICB9XG4gICAgICAgIGFyZ3Mud2hlcmUgPSB0aGlzLmFuZChhcmdzLndoZXJlLCBtZXJnZWRHdWFyZCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBJbmplY3RzIGd1YXJkIGZvciByZWxhdGlvbiBmaWVsZHMgbmVzdGVkIGluIGBwYXlsb2FkYC4gVGhlIGBtb2RlbEd1YXJkYCBwYXJhbWV0ZXIgcmVwcmVzZW50cyB0aGUgbW9kZWwtbGV2ZWwgZ3VhcmQgZm9yIGBtb2RlbGAuXG4gICAgLy8gVGhlIGZ1bmN0aW9uIHJldHVybnMgYSBtb2RpZmllZCBjb3B5IG9mIGBtb2RlbEd1YXJkYCB3aXRoIGZpZWxkLWxldmVsIHBvbGljaWVzIGNvbWJpbmVkLlxuICAgIGluamVjdFJlYWRHdWFyZEZvclJlbGF0aW9uRmllbGRzKGRiLCBtb2RlbCwgcGF5bG9hZCwgbW9kZWxHdWFyZCkge1xuICAgICAgICBpZiAoIXBheWxvYWQgfHwgdHlwZW9mIHBheWxvYWQgIT09ICdvYmplY3QnIHx8IE9iamVjdC5rZXlzKHBheWxvYWQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG1vZGVsR3VhcmQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsRmllbGRHdWFyZHMgPSBbXTtcbiAgICAgICAgY29uc3QgYWxsRmllbGRPdmVycmlkZUd1YXJkcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IFtmaWVsZCwgc3ViUGF5bG9hZF0gb2YgT2JqZWN0LmVudHJpZXMocGF5bG9hZCkpIHtcbiAgICAgICAgICAgIGlmICghc3ViUGF5bG9hZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWxsRmllbGRHdWFyZHMucHVzaCh0aGlzLmdldEZpZWxkUmVhZEF1dGhHdWFyZChkYiwgbW9kZWwsIGZpZWxkKSk7XG4gICAgICAgICAgICBhbGxGaWVsZE92ZXJyaWRlR3VhcmRzLnB1c2godGhpcy5nZXRGaWVsZE92ZXJyaWRlUmVhZEF1dGhHdWFyZChkYiwgbW9kZWwsIGZpZWxkKSk7XG4gICAgICAgICAgICBjb25zdCBmaWVsZEluZm8gPSAoMCwgY3Jvc3NfMS5yZXNvbHZlRmllbGQpKHRoaXMubW9kZWxNZXRhLCBtb2RlbCwgZmllbGQpO1xuICAgICAgICAgICAgaWYgKGZpZWxkSW5mbyA9PT0gbnVsbCB8fCBmaWVsZEluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpZWxkSW5mby5pc0RhdGFNb2RlbCkge1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZEluZm8uaXNBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluamVjdFJlYWRHdWFyZEZvclRvTWFueUZpZWxkKGRiLCBmaWVsZEluZm8sIHN1YlBheWxvYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmplY3RSZWFkR3VhcmRGb3JUb09uZUZpZWxkKGRiLCBmaWVsZEluZm8sIHN1YlBheWxvYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhbGwgZXhpc3RpbmcgZmllbGQtbGV2ZWwgZ3VhcmRzIG11c3QgYmUgdHJ1ZVxuICAgICAgICBjb25zdCBtZXJnZWRHdWFyZCA9IHRoaXMuYW5kKC4uLmFsbEZpZWxkR3VhcmRzKTtcbiAgICAgICAgLy8gYWxsIGV4aXN0aW5nIGZpZWxkLWxldmVsIG92ZXJyaWRlIGd1YXJkcyBtdXN0IGJlIHRydWUgZm9yIG92ZXJyaWRlIHRvIHRha2UgZWZmZWN0OyBvdmVycmlkZSBpcyBkaXNhYmxlZCBieSBkZWZhdWx0XG4gICAgICAgIGNvbnN0IG1lcmdlZE92ZXJyaWRlR3VhcmQgPSBhbGxGaWVsZE92ZXJyaWRlR3VhcmRzLmxlbmd0aCA9PT0gMCA/IHRoaXMubWFrZUZhbHNlKCkgOiB0aGlzLmFuZCguLi5hbGxGaWVsZE92ZXJyaWRlR3VhcmRzKTtcbiAgICAgICAgLy8gKG9yaWdpbmFsLWd1YXJkICYmIGZpZWxkLWxldmVsLWd1YXJkKSB8fCBmaWVsZC1sZXZlbC1vdmVycmlkZS1ndWFyZFxuICAgICAgICBjb25zdCB1cGRhdGVkR3VhcmQgPSB0aGlzLm9yKHRoaXMuYW5kKG1vZGVsR3VhcmQsIG1lcmdlZEd1YXJkKSwgbWVyZ2VkT3ZlcnJpZGVHdWFyZCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVkR3VhcmQ7XG4gICAgfVxuICAgIGluamVjdFJlYWRHdWFyZEZvclRvTWFueUZpZWxkKGRiLCBmaWVsZEluZm8sIHBheWxvYWQpIHtcbiAgICAgICAgY29uc3QgZ3VhcmQgPSB0aGlzLmdldEF1dGhHdWFyZChkYiwgZmllbGRJbmZvLnR5cGUsICdyZWFkJyk7XG4gICAgICAgIGlmIChwYXlsb2FkLnNvbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZEd1YXJkID0gdGhpcy5pbmplY3RSZWFkR3VhcmRGb3JSZWxhdGlvbkZpZWxkcyhkYiwgZmllbGRJbmZvLnR5cGUsIHBheWxvYWQuc29tZSwgZ3VhcmQpO1xuICAgICAgICAgICAgLy8gdHVybiBcInNvbWVcIiBpbnRvOiB7IHNvbWU6IHsgQU5EOiBbZ3VhcmQsIHBheWxvYWQuc29tZV0gfSB9XG4gICAgICAgICAgICBwYXlsb2FkLnNvbWUgPSB0aGlzLmFuZChwYXlsb2FkLnNvbWUsIG1lcmdlZEd1YXJkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF5bG9hZC5ub25lKSB7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWRHdWFyZCA9IHRoaXMuaW5qZWN0UmVhZEd1YXJkRm9yUmVsYXRpb25GaWVsZHMoZGIsIGZpZWxkSW5mby50eXBlLCBwYXlsb2FkLm5vbmUsIGd1YXJkKTtcbiAgICAgICAgICAgIC8vIHR1cm4gbm9uZSBpbnRvOiB7IG5vbmU6IHsgQU5EOiBbZ3VhcmQsIHBheWxvYWQubm9uZV0gfSB9XG4gICAgICAgICAgICBwYXlsb2FkLm5vbmUgPSB0aGlzLmFuZChwYXlsb2FkLm5vbmUsIG1lcmdlZEd1YXJkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF5bG9hZC5ldmVyeSAmJlxuICAgICAgICAgICAgdHlwZW9mIHBheWxvYWQuZXZlcnkgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAvLyBpZ25vcmUgZW1wdHkgZXZlcnkgY2xhdXNlXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhwYXlsb2FkLmV2ZXJ5KS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWRHdWFyZCA9IHRoaXMuaW5qZWN0UmVhZEd1YXJkRm9yUmVsYXRpb25GaWVsZHMoZGIsIGZpZWxkSW5mby50eXBlLCBwYXlsb2FkLmV2ZXJ5LCBndWFyZCk7XG4gICAgICAgICAgICAvLyB0dXJuIFwiZXZlcnlcIiBpbnRvOiB7IG5vbmU6IHsgQU5EOiBbZ3VhcmQsIHsgTk9UOiBwYXlsb2FkLmV2ZXJ5IH1dIH0gfVxuICAgICAgICAgICAgaWYgKCFwYXlsb2FkLm5vbmUpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLm5vbmUgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBheWxvYWQubm9uZSA9IHRoaXMuYW5kKHBheWxvYWQubm9uZSwgbWVyZ2VkR3VhcmQsIHRoaXMubm90KHBheWxvYWQuZXZlcnkpKTtcbiAgICAgICAgICAgIGRlbGV0ZSBwYXlsb2FkLmV2ZXJ5O1xuICAgICAgICB9XG4gICAgfVxuICAgIGluamVjdFJlYWRHdWFyZEZvclRvT25lRmllbGQoZGIsIGZpZWxkSW5mbywgcGF5bG9hZCkge1xuICAgICAgICBjb25zdCBndWFyZCA9IHRoaXMuZ2V0QXV0aEd1YXJkKGRiLCBmaWVsZEluZm8udHlwZSwgJ3JlYWQnKTtcbiAgICAgICAgLy8gaXN8aXNOb3QgYW5kIGZsYXQgZmllbGRzIGNvbmRpdGlvbnMgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZVxuICAgICAgICAvLyBpcyBhbmQgaXNOb3QgY2FuIGJlIG51bGwgdmFsdWVcbiAgICAgICAgaWYgKHBheWxvYWQuaXMgIT09IHVuZGVmaW5lZCB8fCBwYXlsb2FkLmlzTm90ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLmlzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVyZ2VkR3VhcmQgPSB0aGlzLmluamVjdFJlYWRHdWFyZEZvclJlbGF0aW9uRmllbGRzKGRiLCBmaWVsZEluZm8udHlwZSwgcGF5bG9hZC5pcywgZ3VhcmQpO1xuICAgICAgICAgICAgICAgIC8vIG1lcmdlIGd1YXJkIHdpdGggZXhpc3RpbmcgXCJpc1wiOiB7IGlzOiB7IEFORDogW29yaWdpbmFsSXMsIGd1YXJkXSB9IH1cbiAgICAgICAgICAgICAgICBwYXlsb2FkLmlzID0gdGhpcy5hbmQocGF5bG9hZC5pcywgbWVyZ2VkR3VhcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBheWxvYWQuaXNOb3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXJnZWRHdWFyZCA9IHRoaXMuaW5qZWN0UmVhZEd1YXJkRm9yUmVsYXRpb25GaWVsZHMoZGIsIGZpZWxkSW5mby50eXBlLCBwYXlsb2FkLmlzTm90LCBndWFyZCk7XG4gICAgICAgICAgICAgICAgLy8gbWVyZ2UgZ3VhcmQgd2l0aCBleGlzdGluZyBcImlzTm90XCI6ICB7IGlzTm90OiB7IEFORDogW29yaWdpbmFsSXNOb3QsIGd1YXJkXSB9IH1cbiAgICAgICAgICAgICAgICBwYXlsb2FkLmlzTm90ID0gdGhpcy5hbmQocGF5bG9hZC5pc05vdCwgbWVyZ2VkR3VhcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkR3VhcmQgPSB0aGlzLmluamVjdFJlYWRHdWFyZEZvclJlbGF0aW9uRmllbGRzKGRiLCBmaWVsZEluZm8udHlwZSwgcGF5bG9hZCwgZ3VhcmQpO1xuICAgICAgICAgICAgLy8gdHVybiBkaXJlY3QgY29uZGl0aW9ucyBpbnRvOiB7IGlzOiB7IEFORDogWyBvcmlnaW5hbENvbmRpdGlvbnMsIGd1YXJkIF0gfSB9XG4gICAgICAgICAgICBjb25zdCBjb21iaW5lZCA9IHRoaXMuYW5kKCgwLCBkZWVwY29weV8xLmRlZmF1bHQpKHBheWxvYWQpLCBtZXJnZWRHdWFyZCk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhwYXlsb2FkKS5mb3JFYWNoKChrZXkpID0+IGRlbGV0ZSBwYXlsb2FkW2tleV0pO1xuICAgICAgICAgICAgcGF5bG9hZC5pcyA9IGNvbWJpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluamVjdHMgYXV0aCBndWFyZCBmb3IgcmVhZCBvcGVyYXRpb25zLlxuICAgICAqL1xuICAgIGluamVjdEZvclJlYWQoZGIsIG1vZGVsLCBhcmdzKSB7XG4gICAgICAgIC8vIG1ha2Ugc2VsZWN0IGFuZCBpbmNsdWRlIHZpc2libGUgdG8gdGhlIGluamVjdGlvblxuICAgICAgICBjb25zdCBpbmplY3RlZCA9IHsgc2VsZWN0OiBhcmdzLnNlbGVjdCwgaW5jbHVkZTogYXJncy5pbmNsdWRlIH07XG4gICAgICAgIGlmICghdGhpcy5pbmplY3RBdXRoR3VhcmRBc1doZXJlKGRiLCBpbmplY3RlZCwgbW9kZWwsICdyZWFkJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJncy53aGVyZSkge1xuICAgICAgICAgICAgLy8gaW5qZWN0IGludG8gcmVsYXRpb24gZmllbGRzOlxuICAgICAgICAgICAgLy8gICB0by1tYW55OiBzb21lL25vbmUvZXZlcnlcbiAgICAgICAgICAgIC8vICAgdG8tb25lOiBkaXJlY3QtY29uZGl0aW9ucy9pcy9pc05vdFxuICAgICAgICAgICAgdGhpcy5pbmplY3RSZWFkR3VhcmRGb3JSZWxhdGlvbkZpZWxkcyhkYiwgbW9kZWwsIGFyZ3Mud2hlcmUsIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5qZWN0ZWQud2hlcmUgJiYgT2JqZWN0LmtleXMoaW5qZWN0ZWQud2hlcmUpLmxlbmd0aCA+IDAgJiYgIXRoaXMuaXNUcnVlKGluamVjdGVkLndoZXJlKSkge1xuICAgICAgICAgICAgaWYgKCFhcmdzLndoZXJlKSB7XG4gICAgICAgICAgICAgICAgYXJncy53aGVyZSA9IGluamVjdGVkLndoZXJlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXJnZVdoZXJlQ2xhdXNlKGFyZ3Mud2hlcmUsIGluamVjdGVkLndoZXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyByZWN1cnNpdmVseSBpbmplY3QgcmVhZCBndWFyZCBjb25kaXRpb25zIGludG8gbmVzdGVkIHNlbGVjdCwgaW5jbHVkZSwgYW5kIF9jb3VudFxuICAgICAgICBjb25zdCBob2lzdGVkQ29uZGl0aW9ucyA9IHRoaXMuaW5qZWN0TmVzdGVkUmVhZENvbmRpdGlvbnMoZGIsIG1vZGVsLCBhcmdzKTtcbiAgICAgICAgLy8gdGhlIGluamVjdGlvbiBwcm9jZXNzIG1heSBnZW5lcmF0ZSBjb25kaXRpb25zIHRoYXQgbmVlZCB0byBiZSBob2lzdGVkIHRvIHRoZSB0b3BsZXZlbCxcbiAgICAgICAgLy8gaWYgc28sIG1lcmdlIGl0IHdpdGggdGhlIGV4aXN0aW5nIHdoZXJlXG4gICAgICAgIGlmIChob2lzdGVkQ29uZGl0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3Mud2hlcmUpIHtcbiAgICAgICAgICAgICAgICBhcmdzLndoZXJlID0gdGhpcy5hbmQoLi4uaG9pc3RlZENvbmRpdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXJnZVdoZXJlQ2xhdXNlKGFyZ3Mud2hlcmUsIHRoaXMuYW5kKC4uLmhvaXN0ZWRDb25kaXRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuICAgIC8vI3JlZ2lvbiBDaGVja2VyXG4gICAgLyoqXG4gICAgICogR2V0cyBjaGVja2VyIGNvbnN0cmFpbnRzIGZvciB0aGUgZ2l2ZW4gbW9kZWwgYW5kIG9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICBnZXRDaGVja2VyQ29uc3RyYWludChtb2RlbCwgb3BlcmF0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMua2luZHMgJiYgIXRoaXMub3B0aW9ucy5raW5kcy5pbmNsdWRlcygncG9saWN5JykpIHtcbiAgICAgICAgICAgIC8vIHBvbGljeSBlbmhhbmNlbWVudCBub3QgZW5hYmxlZCwgcmV0dXJuIGEgY29uc3RhbnQgdHJ1ZSBjaGVja2VyIHJlc3VsdFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmID0gdGhpcy5nZXRNb2RlbFBvbGljeURlZihtb2RlbCk7XG4gICAgICAgIGNvbnN0IGNoZWNrZXIgPSBkZWYubW9kZWxMZXZlbFtvcGVyYXRpb25dLnBlcm1pc3Npb25DaGVja2VyO1xuICAgICAgICBpZiAoY2hlY2tlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdlbmVyYXRlZCBwZXJtaXNzaW9uIGNoZWNrZXJzIG5vdCBmb3VuZC4gUGxlYXNlIG1ha2Ugc3VyZSB0aGUgXCJnZW5lcmF0ZVBlcm1pc3Npb25DaGVja2VyXCIgb3B0aW9uIGlzIHNldCB0byB0cnVlIGluIHRoZSBcIkBjb3JlL2VuaGFuY2VyXCIgcGx1Z2luLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2hlY2tlciA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMudW5rbm93bkVycm9yKGBpbnZhbGlkICR7b3BlcmF0aW9ufSBjaGVja2VyIGZ1bmN0aW9uIGZvciAke21vZGVsfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhbGwgY2hlY2tlciBmdW5jdGlvblxuICAgICAgICByZXR1cm4gY2hlY2tlcih7IHVzZXI6IHRoaXMudXNlciB9KTtcbiAgICB9XG4gICAgLy8jZW5kcmVnaW9uXG4gICAgLyoqXG4gICAgICogR2V0cyB1bmlxdWUgY29uc3RyYWludHMgZm9yIHRoZSBnaXZlbiBtb2RlbC5cbiAgICAgKi9cbiAgICBnZXRVbmlxdWVDb25zdHJhaW50cyhtb2RlbCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5tb2RlbE1ldGEubW9kZWxzWygwLCBsb3dlcl9jYXNlX2ZpcnN0XzEubG93ZXJDYXNlRmlyc3QpKG1vZGVsKV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51bmlxdWVDb25zdHJhaW50cykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge307XG4gICAgfVxuICAgIGluamVjdE5lc3RlZFJlYWRDb25kaXRpb25zKGRiLCBtb2RlbCwgYXJncykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGluamVjdFRhcmdldCA9IChfYSA9IGFyZ3Muc2VsZWN0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBhcmdzLmluY2x1ZGU7XG4gICAgICAgIGlmICghaW5qZWN0VGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluamVjdFRhcmdldC5fY291bnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gX2NvdW50IG5lZWRzIHRvIHJlc3BlY3QgcmVhZCBwb2xpY2llcyBvZiByZWxhdGVkIG1vZGVsc1xuICAgICAgICAgICAgaWYgKGluamVjdFRhcmdldC5fY291bnQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBpbmNsdWRlIGNvdW50IGZvciBhbGwgcmVsYXRpb25zLCBleHBhbmQgdG8gYWxsIGZpZWxkc1xuICAgICAgICAgICAgICAgIC8vIHNvIHRoYXQgd2UgY2FuIGluamVjdCBndWFyZCBjb25kaXRpb25zIGZvciBlYWNoIG9mIHRoZW1cbiAgICAgICAgICAgICAgICBpbmplY3RUYXJnZXQuX2NvdW50ID0geyBzZWxlY3Q6IHt9IH07XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZWxGaWVsZHMgPSAoMCwgY3Jvc3NfMS5nZXRGaWVsZHMpKHRoaXMubW9kZWxNZXRhLCBtb2RlbCk7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGVsRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKG1vZGVsRmllbGRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYuaXNEYXRhTW9kZWwgJiYgdi5pc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIGFuIGVudHJ5IGZvciB0by1tYW55IHJlbGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5qZWN0VGFyZ2V0Ll9jb3VudC5zZWxlY3Rba10gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGluamVjdCBjb25kaXRpb25zIGZvciBlYWNoIHJlbGF0aW9uXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIE9iamVjdC5rZXlzKGluamVjdFRhcmdldC5fY291bnQuc2VsZWN0KSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5qZWN0VGFyZ2V0Ll9jb3VudC5zZWxlY3RbZmllbGRdICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBpbmplY3RUYXJnZXQuX2NvdW50LnNlbGVjdFtmaWVsZF0gPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRJbmZvID0gKDAsIGNyb3NzXzEucmVzb2x2ZUZpZWxkKSh0aGlzLm1vZGVsTWV0YSwgbW9kZWwsIGZpZWxkKTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpZWxkSW5mbykge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaW5qZWN0IGludG8gdGhlIFwid2hlcmVcIiBjbGF1c2UgaW5zaWRlIHNlbGVjdFxuICAgICAgICAgICAgICAgIHRoaXMuaW5qZWN0QXV0aEd1YXJkQXNXaGVyZShkYiwgaW5qZWN0VGFyZ2V0Ll9jb3VudC5zZWxlY3RbZmllbGRdLCBmaWVsZEluZm8udHlwZSwgJ3JlYWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjb2xsZWN0IGZpbHRlciBjb25kaXRpb25zIHRoYXQgc2hvdWxkIGJlIGhvaXN0ZWQgdG8gdGhlIHRvcGxldmVsXG4gICAgICAgIGNvbnN0IGhvaXN0ZWRDb25kaXRpb25zID0gW107XG4gICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgKDAsIGNyb3NzXzEuZ2V0TW9kZWxGaWVsZHMpKGluamVjdFRhcmdldCkpIHtcbiAgICAgICAgICAgIGlmIChpbmplY3RUYXJnZXRbZmllbGRdID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmllbGRJbmZvID0gKDAsIGNyb3NzXzEucmVzb2x2ZUZpZWxkKSh0aGlzLm1vZGVsTWV0YSwgbW9kZWwsIGZpZWxkKTtcbiAgICAgICAgICAgIGlmICghZmllbGRJbmZvIHx8ICFmaWVsZEluZm8uaXNEYXRhTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGNhcmUgYWJvdXQgcmVsYXRpb24gZmllbGRzXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaG9pc3RlZDtcbiAgICAgICAgICAgIGlmIChmaWVsZEluZm8uaXNBcnJheSB8fFxuICAgICAgICAgICAgICAgIC8vIEluamVjdGluZyB3aGVyZSBhdCBpbmNsdWRlL3NlbGVjdCBsZXZlbCBmb3IgbnVsbGFibGUgdG8tb25lIHJlbGF0aW9uIGlzIHN1cHBvcnRlZCBzaW5jZSBQcmlzbWEgNC44LjBcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcHJpc21hL3ByaXNtYS9kaXNjdXNzaW9ucy8yMDM1MFxuICAgICAgICAgICAgICAgIGZpZWxkSW5mby5pc09wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmplY3RUYXJnZXRbZmllbGRdICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBpbmplY3RUYXJnZXRbZmllbGRdID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGluamVjdCBleHRyYSBjb25kaXRpb24gZm9yIHRvLW1hbnkgb3IgbnVsbGFibGUgdG8tb25lIHJlbGF0aW9uXG4gICAgICAgICAgICAgICAgdGhpcy5pbmplY3RBdXRoR3VhcmRBc1doZXJlKGRiLCBpbmplY3RUYXJnZXRbZmllbGRdLCBmaWVsZEluZm8udHlwZSwgJ3JlYWQnKTtcbiAgICAgICAgICAgICAgICAvLyByZWN1cnNlXG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViSG9pc3RlZCA9IHRoaXMuaW5qZWN0TmVzdGVkUmVhZENvbmRpdGlvbnMoZGIsIGZpZWxkSW5mby50eXBlLCBpbmplY3RUYXJnZXRbZmllbGRdKTtcbiAgICAgICAgICAgICAgICBpZiAoc3ViSG9pc3RlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGNhbiBjb252ZXJ0IGl0IHRvIGEgd2hlcmUgYXQgdGhpcyBsZXZlbFxuICAgICAgICAgICAgICAgICAgICBpbmplY3RUYXJnZXRbZmllbGRdLndoZXJlID0gdGhpcy5hbmQoaW5qZWN0VGFyZ2V0W2ZpZWxkXS53aGVyZSwgLi4uc3ViSG9pc3RlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaG9pc3Qgbm9uLW51bGxhYmxlIHRvLW9uZSBmaWx0ZXIgdG8gdGhlIHBhcmVudCBsZXZlbFxuICAgICAgICAgICAgICAgIGhvaXN0ZWQgPSB0aGlzLmdldEF1dGhHdWFyZChkYiwgZmllbGRJbmZvLnR5cGUsICdyZWFkJyk7XG4gICAgICAgICAgICAgICAgLy8gcmVjdXJzZVxuICAgICAgICAgICAgICAgIGNvbnN0IHN1YkhvaXN0ZWQgPSB0aGlzLmluamVjdE5lc3RlZFJlYWRDb25kaXRpb25zKGRiLCBmaWVsZEluZm8udHlwZSwgaW5qZWN0VGFyZ2V0W2ZpZWxkXSk7XG4gICAgICAgICAgICAgICAgaWYgKHN1YkhvaXN0ZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBob2lzdGVkID0gdGhpcy5hbmQoaG9pc3RlZCwgLi4uc3ViSG9pc3RlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhvaXN0ZWQgJiYgIXRoaXMuaXNUcnVlKGhvaXN0ZWQpKSB7XG4gICAgICAgICAgICAgICAgaG9pc3RlZENvbmRpdGlvbnMucHVzaCh7IFtmaWVsZF06IGhvaXN0ZWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhvaXN0ZWRDb25kaXRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIG1vZGVsIGFuZCBhIHVuaXF1ZSBmaWx0ZXIsIGNoZWNrcyB0aGUgb3BlcmF0aW9uIGlzIGFsbG93ZWQgYnkgcG9saWNpZXMgYW5kIGZpZWxkIHZhbGlkYXRpb25zLlxuICAgICAqIFJlamVjdHMgd2l0aCBhbiBlcnJvciBpZiBub3QgYWxsb3dlZC5cbiAgICAgKi9cbiAgICBjaGVja1BvbGljeUZvclVuaXF1ZShtb2RlbCwgdW5pcXVlRmlsdGVyLCBvcGVyYXRpb24sIGRiLCBhcmdzLCBwcmVWYWx1ZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IGd1YXJkID0gdGhpcy5nZXRBdXRoR3VhcmQoZGIsIG1vZGVsLCBvcGVyYXRpb24sIHByZVZhbHVlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRmFsc2UoZ3VhcmQpICYmICF0aGlzLmhhc092ZXJyaWRlQXV0aEd1YXJkKG1vZGVsLCBvcGVyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5kZW5pZWRCeVBvbGljeShtb2RlbCwgb3BlcmF0aW9uLCBgZW50aXR5ICR7KDAsIHV0aWxzXzEuZm9ybWF0T2JqZWN0KSh1bmlxdWVGaWx0ZXIsIGZhbHNlKX0gZmFpbGVkIHBvbGljeSBjaGVja2AsIGNvbnN0YW50c18xLkNydWRGYWlsdXJlUmVhc29uLkFDQ0VTU19QT0xJQ1lfVklPTEFUSU9OKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBlbnRpdHlDaGVja2VyO1xuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJ3VwZGF0ZScgJiYgYXJncykge1xuICAgICAgICAgICAgICAgIC8vIG1lcmdlIGZpZWxkLWxldmVsIHBvbGljeSBndWFyZHNcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZFVwZGF0ZUd1YXJkID0gdGhpcy5nZXRGaWVsZFVwZGF0ZUd1YXJkcyhkYiwgbW9kZWwsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZFVwZGF0ZUd1YXJkLnJlamVjdGVkQnlGaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZWplY3RlZFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmRlbmllZEJ5UG9saWN5KG1vZGVsLCAndXBkYXRlJywgYGVudGl0eSAkeygwLCB1dGlsc18xLmZvcm1hdE9iamVjdCkodW5pcXVlRmlsdGVyLCBmYWxzZSl9IGZhaWxlZCB1cGRhdGUgcG9saWN5IGNoZWNrIGZvciBmaWVsZCBcIiR7ZmllbGRVcGRhdGVHdWFyZC5yZWplY3RlZEJ5RmllbGR9XCJgLCBjb25zdGFudHNfMS5DcnVkRmFpbHVyZVJlYXNvbi5BQ0NFU1NfUE9MSUNZX1ZJT0xBVElPTik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmaWVsZFVwZGF0ZUd1YXJkLmd1YXJkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1lcmdlIGZpZWxkLWxldmVsIGd1YXJkIHdpdGggQU5EXG4gICAgICAgICAgICAgICAgICAgIGd1YXJkID0gdGhpcy5hbmQoZ3VhcmQsIGZpZWxkVXBkYXRlR3VhcmQuZ3VhcmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmllbGRVcGRhdGVHdWFyZC5vdmVycmlkZUd1YXJkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1lcmdlIGZpZWxkLWxldmVsIG92ZXJyaWRlIGd1YXJkIHdpdGggT1JcbiAgICAgICAgICAgICAgICAgICAgZ3VhcmQgPSB0aGlzLm9yKGd1YXJkLCBmaWVsZFVwZGF0ZUd1YXJkLm92ZXJyaWRlR3VhcmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBmaWVsZC1sZXZlbCBlbnRpdHkgY2hlY2tlclxuICAgICAgICAgICAgICAgIGVudGl0eUNoZWNrZXIgPSBmaWVsZFVwZGF0ZUd1YXJkLmVudGl0eUNoZWNrZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBab2Qgc2NoZW1hIGlzIHRvIGJlIGNoZWNrZWQgZm9yIFwiY3JlYXRlXCIgYW5kIFwicG9zdFVwZGF0ZVwiXG4gICAgICAgICAgICBjb25zdCBzY2hlbWEgPSBbJ2NyZWF0ZScsICdwb3N0VXBkYXRlJ10uaW5jbHVkZXMob3BlcmF0aW9uKSA/IHRoaXMuZ2V0Wm9kU2NoZW1hKG1vZGVsKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIC8vIGNvbWJpbmUgZmllbGQtbGV2ZWwgZW50aXR5IGNoZWNrZXIgd2l0aCBtb2RlbC1sZXZlbFxuICAgICAgICAgICAgY29uc3QgbW9kZWxFbnRpdHlDaGVja2VyID0gdGhpcy5nZXRFbnRpdHlDaGVja2VyKG1vZGVsLCBvcGVyYXRpb24pO1xuICAgICAgICAgICAgZW50aXR5Q2hlY2tlciA9IHRoaXMuY29tYmluZUVudGl0eUNoZWNrZXIoZW50aXR5Q2hlY2tlciwgbW9kZWxFbnRpdHlDaGVja2VyLCAnYW5kJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1RydWUoZ3VhcmQpICYmICFzY2hlbWEgJiYgIWVudGl0eUNoZWNrZXIpIHtcbiAgICAgICAgICAgICAgICAvLyB1bmNvbmRpdGlvbmFsbHkgYWxsb3dlZFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzZWxlY3QgPSBzY2hlbWFcbiAgICAgICAgICAgICAgICA/IC8vIG5lZWQgdG8gdmFsaWRhdGUgYWdhaW5zdCBzY2hlbWEsIG5lZWQgdG8gZmV0Y2ggYWxsIGZpZWxkc1xuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA6IC8vIG9ubHkgZmV0Y2ggaWQgZmllbGRzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFrZUlkU2VsZWN0aW9uKG1vZGVsKTtcbiAgICAgICAgICAgIGlmIChlbnRpdHlDaGVja2VyID09PSBudWxsIHx8IGVudGl0eUNoZWNrZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVudGl0eUNoZWNrZXIuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3QgPSB0aGlzLm1ha2VBbGxTY2FsYXJGaWVsZFNlbGVjdChtb2RlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGVjdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2VsZWN0KSwgZW50aXR5Q2hlY2tlci5zZWxlY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgd2hlcmUgPSB0aGlzLmNsb25lKHVuaXF1ZUZpbHRlcik7XG4gICAgICAgICAgICAvLyBxdWVyeSBhcmdzIG1heSBoYXZlIGJlIG9mIGNvbWJpbmVkLWlkIGZvcm0sIG5lZWQgdG8gZmxhdHRlbiBpdCB0byBjYWxsIGZpbmRGaXJzdFxuICAgICAgICAgICAgdGhpcy5mbGF0dGVuR2VuZXJhdGVkVW5pcXVlRmllbGQobW9kZWwsIHdoZXJlKTtcbiAgICAgICAgICAgIC8vIHF1ZXJ5IHdpdGggcG9saWN5IGd1YXJkXG4gICAgICAgICAgICB3aGVyZSA9IHRoaXMuYW5kKHdoZXJlLCBndWFyZCk7XG4gICAgICAgICAgICBjb25zdCBxdWVyeSA9IHsgc2VsZWN0LCB3aGVyZSB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkTG9nUXVlcnkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKGBbcG9saWN5XSBjaGVja2luZyAke21vZGVsfSBmb3IgJHtvcGVyYXRpb259LCBcXGBmaW5kRmlyc3RcXGA6XFxuJHsoMCwgdXRpbHNfMS5mb3JtYXRPYmplY3QpKHF1ZXJ5KX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIGRiW21vZGVsXS5maW5kRmlyc3QocXVlcnkpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmRlbmllZEJ5UG9saWN5KG1vZGVsLCBvcGVyYXRpb24sIGBlbnRpdHkgJHsoMCwgdXRpbHNfMS5mb3JtYXRPYmplY3QpKHVuaXF1ZUZpbHRlciwgZmFsc2UpfSBmYWlsZWQgcG9saWN5IGNoZWNrYCwgY29uc3RhbnRzXzEuQ3J1ZEZhaWx1cmVSZWFzb24uQUNDRVNTX1BPTElDWV9WSU9MQVRJT04pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudGl0eUNoZWNrZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sb2dnZXIuZW5hYmxlZCgnaW5mbycpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oYFtwb2xpY3ldIHJ1bm5pbmcgZW50aXR5IGNoZWNrZXIgb24gJHttb2RlbH0gZm9yICR7b3BlcmF0aW9ufWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWVudGl0eUNoZWNrZXIuZnVuYyhyZXN1bHQsIHsgdXNlcjogdGhpcy51c2VyLCBwcmVWYWx1ZSB9KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmRlbmllZEJ5UG9saWN5KG1vZGVsLCBvcGVyYXRpb24sIGBlbnRpdHkgJHsoMCwgdXRpbHNfMS5mb3JtYXRPYmplY3QpKHVuaXF1ZUZpbHRlciwgZmFsc2UpfSBmYWlsZWQgcG9saWN5IGNoZWNrYCwgY29uc3RhbnRzXzEuQ3J1ZEZhaWx1cmVSZWFzb24uQUNDRVNTX1BPTElDWV9WSU9MQVRJT04pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBwdXNoIGRvd24gc2NoZW1hIGNoZWNrIHRvIHRoZSBkYXRhYmFzZVxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gc2NoZW1hLnNhZmVQYXJzZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyc2VSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9ICgwLCB6b2RfdmFsaWRhdGlvbl9lcnJvcl8xLmZyb21ab2RFcnJvcikocGFyc2VSZXN1bHQuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5sb2dnZXIuZW5hYmxlZCgnaW5mbycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKGBlbnRpdHkgJHttb2RlbH0gZmFpbGVkIHZhbGlkYXRpb24gZm9yIG9wZXJhdGlvbiAke29wZXJhdGlvbn06ICR7ZXJyb3J9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5kZW5pZWRCeVBvbGljeShtb2RlbCwgb3BlcmF0aW9uLCBgZW50aXRpZXMgJHsoMCwgdXRpbHNfMS5mb3JtYXRPYmplY3QpKHVuaXF1ZUZpbHRlciwgZmFsc2UpfSBmYWlsZWQgdmFsaWRhdGlvbjogWyR7ZXJyb3J9XWAsIGNvbnN0YW50c18xLkNydWRGYWlsdXJlUmVhc29uLkRBVEFfVkFMSURBVElPTl9WSU9MQVRJT04sIHBhcnNlUmVzdWx0LmVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRFbnRpdHlDaGVja2VyKG1vZGVsLCBvcGVyYXRpb24sIGZpZWxkKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBkZWYgPSB0aGlzLmdldE1vZGVsUG9saWN5RGVmKG1vZGVsKTtcbiAgICAgICAgaWYgKGZpZWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gKF9jID0gKF9iID0gKF9hID0gZGVmLmZpZWxkTGV2ZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtvcGVyYXRpb25dKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbZmllbGRdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZW50aXR5Q2hlY2tlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkZWYubW9kZWxMZXZlbFtvcGVyYXRpb25dLmVudGl0eUNoZWNrZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0VXBkYXRlT3ZlcnJpZGVFbnRpdHlDaGVja2VyRm9yRmllbGQobW9kZWwsIGZpZWxkKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBkZWYgPSB0aGlzLmdldE1vZGVsUG9saWN5RGVmKG1vZGVsKTtcbiAgICAgICAgcmV0dXJuIChfYyA9IChfYiA9IChfYSA9IGRlZi5maWVsZExldmVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudXBkYXRlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbZmllbGRdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Mub3ZlcnJpZGVFbnRpdHlDaGVja2VyO1xuICAgIH1cbiAgICBnZXRGaWVsZFJlYWRHdWFyZHMoZGIsIG1vZGVsLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IGFsbEZpZWxkcyA9IE9iamVjdC52YWx1ZXMoKDAsIGNyb3NzXzEuZ2V0RmllbGRzKSh0aGlzLm1vZGVsTWV0YSwgbW9kZWwpKTtcbiAgICAgICAgLy8gYWxsIHNjYWxhciBmaWVsZHMgYnkgZGVmYXVsdFxuICAgICAgICBsZXQgZmllbGRzID0gYWxsRmllbGRzLmZpbHRlcigoZikgPT4gIWYuaXNEYXRhTW9kZWwpO1xuICAgICAgICBpZiAoYXJncy5zZWxlY3QpIHtcbiAgICAgICAgICAgIC8vIGV4cGxpY2l0bHkgc2VsZWN0ZWQgZmllbGRzXG4gICAgICAgICAgICBmaWVsZHMgPSBhbGxGaWVsZHMuZmlsdGVyKChmKSA9PiB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSBhcmdzLnNlbGVjdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2YubmFtZV0pID09PSB0cnVlOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcmdzLmluY2x1ZGUpIHtcbiAgICAgICAgICAgIC8vIGluY2x1ZGVkIHJlbGF0aW9uc1xuICAgICAgICAgICAgZmllbGRzLnB1c2goLi4uYWxsRmllbGRzLmZpbHRlcigoZikgPT4gIWZpZWxkcy5pbmNsdWRlcyhmKSAmJiBhcmdzLmluY2x1ZGVbZi5uYW1lXSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGNhbiBoYXBwZW4gaWYgb25seSBzZWxlY3RpbmcgcHNldWRvIGZpZWxkcyBsaWtlIFwiX2NvdW50XCJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsRmllbGRHdWFyZHMgPSBmaWVsZHMubWFwKChmaWVsZCkgPT4gdGhpcy5nZXRGaWVsZE92ZXJyaWRlUmVhZEF1dGhHdWFyZChkYiwgbW9kZWwsIGZpZWxkLm5hbWUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5kKC4uLmFsbEZpZWxkR3VhcmRzKTtcbiAgICB9XG4gICAgZ2V0RmllbGRVcGRhdGVHdWFyZHMoZGIsIG1vZGVsLCBhcmdzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgYWxsRmllbGRHdWFyZHMgPSBbXTtcbiAgICAgICAgY29uc3QgYWxsT3ZlcnJpZGVGaWVsZEd1YXJkcyA9IFtdO1xuICAgICAgICBsZXQgZW50aXR5Q2hlY2tlcjtcbiAgICAgICAgZm9yIChjb25zdCBbZmllbGQsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcygoX2EgPSBhcmdzLmRhdGEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGFyZ3MpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmllbGRJbmZvID0gKDAsIGNyb3NzXzEucmVzb2x2ZUZpZWxkKSh0aGlzLm1vZGVsTWV0YSwgbW9kZWwsIGZpZWxkKTtcbiAgICAgICAgICAgIGlmIChmaWVsZEluZm8gPT09IG51bGwgfHwgZmllbGRJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWVsZEluZm8uaXNEYXRhTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAvLyByZWxhdGlvbiBmaWVsZCB1cGRhdGUgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgZm9yZWlnbiBrZXkgdXBkYXRlLFxuICAgICAgICAgICAgICAgIC8vIGZldGNoIGFuZCBtZXJnZSBhbGwgZm9yZWlnbiBrZXkgZ3VhcmRzXG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkSW5mby5pc1JlbGF0aW9uT3duZXIgJiYgZmllbGRJbmZvLmZvcmVpZ25LZXlNYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvcmVpZ25LZXlzID0gT2JqZWN0LnZhbHVlcyhmaWVsZEluZm8uZm9yZWlnbktleU1hcHBpbmcpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZrIG9mIGZvcmVpZ25LZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZEd1YXJkID0gdGhpcy5nZXRGaWVsZFVwZGF0ZUF1dGhHdWFyZChkYiwgbW9kZWwsIGZrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRmFsc2UoZmllbGRHdWFyZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBndWFyZDogZmllbGRHdWFyZCwgcmVqZWN0ZWRCeUZpZWxkOiBmayB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGZpZWxkIGd1YXJkXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxGaWVsZEd1YXJkcy5wdXNoKGZpZWxkR3VhcmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGZpZWxkIG92ZXJyaWRlIGd1YXJkXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvdmVycmlkZUZpZWxkR3VhcmQgPSB0aGlzLmdldEZpZWxkT3ZlcnJpZGVVcGRhdGVBdXRoR3VhcmQoZGIsIG1vZGVsLCBmayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxPdmVycmlkZUZpZWxkR3VhcmRzLnB1c2gob3ZlcnJpZGVGaWVsZEd1YXJkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkR3VhcmQgPSB0aGlzLmdldEZpZWxkVXBkYXRlQXV0aEd1YXJkKGRiLCBtb2RlbCwgZmllbGQpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRmFsc2UoZmllbGRHdWFyZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZ3VhcmQ6IGZpZWxkR3VhcmQsIHJlamVjdGVkQnlGaWVsZDogZmllbGQgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYWRkIGZpZWxkIGd1YXJkXG4gICAgICAgICAgICAgICAgYWxsRmllbGRHdWFyZHMucHVzaChmaWVsZEd1YXJkKTtcbiAgICAgICAgICAgICAgICAvLyBhZGQgZmllbGQgb3ZlcnJpZGUgZ3VhcmRcbiAgICAgICAgICAgICAgICBjb25zdCBvdmVycmlkZUZpZWxkR3VhcmQgPSB0aGlzLmdldEZpZWxkT3ZlcnJpZGVVcGRhdGVBdXRoR3VhcmQoZGIsIG1vZGVsLCBmaWVsZCk7XG4gICAgICAgICAgICAgICAgYWxsT3ZlcnJpZGVGaWVsZEd1YXJkcy5wdXNoKG92ZXJyaWRlRmllbGRHdWFyZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtZXJnZSByZWd1bGFyIGFuZCBvdmVycmlkZSBlbnRpdHkgY2hlY2tlcnMgd2l0aCBPUlxuICAgICAgICAgICAgbGV0IGNoZWNrZXIgPSB0aGlzLmdldEVudGl0eUNoZWNrZXIobW9kZWwsICd1cGRhdGUnLCBmaWVsZCk7XG4gICAgICAgICAgICBjb25zdCBvdmVycmlkZUNoZWNrZXIgPSB0aGlzLmdldFVwZGF0ZU92ZXJyaWRlRW50aXR5Q2hlY2tlckZvckZpZWxkKG1vZGVsLCBmaWVsZCk7XG4gICAgICAgICAgICBjaGVja2VyID0gdGhpcy5jb21iaW5lRW50aXR5Q2hlY2tlcihjaGVja2VyLCBvdmVycmlkZUNoZWNrZXIsICdvcicpO1xuICAgICAgICAgICAgLy8gYWNjdW11bGF0ZSBlbnRpdHkgY2hlY2tlciBhY3Jvc3MgZmllbGRzXG4gICAgICAgICAgICBlbnRpdHlDaGVja2VyID0gdGhpcy5jb21iaW5lRW50aXR5Q2hlY2tlcihlbnRpdHlDaGVja2VyLCBjaGVja2VyLCAnYW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsRmllbGRzQ29tYmluZWQgPSB0aGlzLmFuZCguLi5hbGxGaWVsZEd1YXJkcyk7XG4gICAgICAgIGNvbnN0IGFsbE92ZXJyaWRlRmllbGRzQ29tYmluZWQgPSBhbGxPdmVycmlkZUZpZWxkR3VhcmRzLmxlbmd0aCAhPT0gMCA/IHRoaXMuYW5kKC4uLmFsbE92ZXJyaWRlRmllbGRHdWFyZHMpIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ3VhcmQ6IGFsbEZpZWxkc0NvbWJpbmVkLFxuICAgICAgICAgICAgb3ZlcnJpZGVHdWFyZDogYWxsT3ZlcnJpZGVGaWVsZHNDb21iaW5lZCxcbiAgICAgICAgICAgIHJlamVjdGVkQnlGaWVsZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZW50aXR5Q2hlY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29tYmluZUVudGl0eUNoZWNrZXIobGVmdCwgcmlnaHQsIGNvbWJpbmVyKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICghbGVmdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiBsZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bmMgPSBjb21iaW5lciA9PT0gJ2FuZCdcbiAgICAgICAgICAgID8gKGVudGl0eSwgY29udGV4dCkgPT4gbGVmdC5mdW5jKGVudGl0eSwgY29udGV4dCkgJiYgcmlnaHQuZnVuYyhlbnRpdHksIGNvbnRleHQpXG4gICAgICAgICAgICA6IChlbnRpdHksIGNvbnRleHQpID0+IGxlZnQuZnVuYyhlbnRpdHksIGNvbnRleHQpIHx8IHJpZ2h0LmZ1bmMoZW50aXR5LCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZ1bmMsXG4gICAgICAgICAgICBzZWxlY3RvcjogKDAsIGRlZXBtZXJnZV8xLmRlZmF1bHQpKChfYSA9IGxlZnQuc2VsZWN0b3IpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9LCAoX2IgPSByaWdodC5zZWxlY3RvcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge30pLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmllcyByZWplY3RpbmcgYSByZXF1ZXN0IGJhc2VkIG9uIHN0YXRpYyBcImZhbHNlXCIgcG9saWN5LlxuICAgICAqL1xuICAgIHRyeVJlamVjdChkYiwgbW9kZWwsIG9wZXJhdGlvbikge1xuICAgICAgICBjb25zdCBndWFyZCA9IHRoaXMuZ2V0QXV0aEd1YXJkKGRiLCBtb2RlbCwgb3BlcmF0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMuaXNGYWxzZShndWFyZCkgJiYgIXRoaXMuaGFzT3ZlcnJpZGVBdXRoR3VhcmQobW9kZWwsIG9wZXJhdGlvbikpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuZGVuaWVkQnlQb2xpY3kobW9kZWwsIG9wZXJhdGlvbiwgdW5kZWZpbmVkLCBjb25zdGFudHNfMS5DcnVkRmFpbHVyZVJlYXNvbi5BQ0NFU1NfUE9MSUNZX1ZJT0xBVElPTik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgbW9kZWwgZXhpc3RzIGdpdmVuIGEgdW5pcXVlIGZpbHRlci5cbiAgICAgKi9cbiAgICBjaGVja0V4aXN0ZW5jZShkYl8xLCBtb2RlbF8xLCB1bmlxdWVGaWx0ZXJfMSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiogKGRiLCBtb2RlbCwgdW5pcXVlRmlsdGVyLCB0aHJvd0lmTm90Rm91bmQgPSBmYWxzZSkge1xuICAgICAgICAgICAgdW5pcXVlRmlsdGVyID0gdGhpcy5jbG9uZSh1bmlxdWVGaWx0ZXIpO1xuICAgICAgICAgICAgdGhpcy5mbGF0dGVuR2VuZXJhdGVkVW5pcXVlRmllbGQobW9kZWwsIHVuaXF1ZUZpbHRlcik7XG4gICAgICAgICAgICBpZiAodGhpcy5zaG91bGRMb2dRdWVyeSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oYFtwb2xpY3ldIGNoZWNraW5nICR7bW9kZWx9IGV4aXN0ZW5jZSwgXFxgZmluZEZpcnN0XFxgOlxcbiR7KDAsIHV0aWxzXzEuZm9ybWF0T2JqZWN0KSh1bmlxdWVGaWx0ZXIpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSB5aWVsZCBkYlttb2RlbF0uZmluZEZpcnN0KHtcbiAgICAgICAgICAgICAgICB3aGVyZTogdW5pcXVlRmlsdGVyLFxuICAgICAgICAgICAgICAgIHNlbGVjdDogdGhpcy5tYWtlSWRTZWxlY3Rpb24obW9kZWwpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWV4aXN0aW5nICYmIHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMubm90Rm91bmQobW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBlbnRpdHkgZ2l2ZW4gYSB1bmlxdWUgZmlsdGVyIHdpdGggcmVhZCBwb2xpY3kgY2hlY2tlZC4gUmVqZWN0IGlmIG5vdCByZWFkYWJsZS5cbiAgICAgKi9cbiAgICByZWFkQmFjayhkYiwgbW9kZWwsIG9wZXJhdGlvbiwgc2VsZWN0SW5jbHVkZSwgdW5pcXVlRmlsdGVyKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB1bmlxdWVGaWx0ZXIgPSB0aGlzLmNsb25lKHVuaXF1ZUZpbHRlcik7XG4gICAgICAgICAgICB0aGlzLmZsYXR0ZW5HZW5lcmF0ZWRVbmlxdWVGaWVsZChtb2RlbCwgdW5pcXVlRmlsdGVyKTtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBvbmx5IHNlbGVjdCBhbmQgaW5jbHVkZSBhcmUgcGlja2VkXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RJbmNsdWRlQ2xlYW4gPSB0aGlzLnBpY2soc2VsZWN0SW5jbHVkZSwgJ3NlbGVjdCcsICdpbmNsdWRlJyk7XG4gICAgICAgICAgICBjb25zdCByZWFkQXJncyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jbG9uZShzZWxlY3RJbmNsdWRlQ2xlYW4pKSwgeyB3aGVyZTogdW5pcXVlRmlsdGVyIH0pO1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmRlbmllZEJ5UG9saWN5KG1vZGVsLCBvcGVyYXRpb24sICdyZXN1bHQgaXMgbm90IGFsbG93ZWQgdG8gYmUgcmVhZCBiYWNrJywgY29uc3RhbnRzXzEuQ3J1ZEZhaWx1cmVSZWFzb24uUkVTVUxUX05PVF9SRUFEQUJMRSk7XG4gICAgICAgICAgICBjb25zdCBpbmplY3RSZXN1bHQgPSB0aGlzLmluamVjdEZvclJlYWQoZGIsIG1vZGVsLCByZWFkQXJncyk7XG4gICAgICAgICAgICBpZiAoIWluamVjdFJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yLCByZXN1bHQ6IHVuZGVmaW5lZCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaW5qZWN0IHNlbGVjdCBuZWVkZWQgZm9yIGZpZWxkLWxldmVsIHJlYWQgY2hlY2tzXG4gICAgICAgICAgICB0aGlzLmluamVjdFJlYWRDaGVja1NlbGVjdChtb2RlbCwgcmVhZEFyZ3MpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkTG9nUXVlcnkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKGBbcG9saWN5XSBjaGVja2luZyByZWFkLWJhY2ssIFxcYGZpbmRGaXJzdFxcYCAke21vZGVsfTpcXG4keygwLCB1dGlsc18xLmZvcm1hdE9iamVjdCkocmVhZEFyZ3MpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgZGJbbW9kZWxdLmZpbmRGaXJzdChyZWFkQXJncyk7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yLCByZXN1bHQ6IHVuZGVmaW5lZCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wb3N0UHJvY2Vzc0ZvclJlYWQocmVzdWx0LCBtb2RlbCwgc2VsZWN0SW5jbHVkZUNsZWFuKTtcbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdCwgZXJyb3I6IHVuZGVmaW5lZCB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5qZWN0cyBmaWVsZCBzZWxlY3Rpb24gbmVlZGVkIGZvciBjaGVja2luZyBmaWVsZC1sZXZlbCByZWFkIHBvbGljeSBjaGVjayBhbmQgZXZhbHVhdGluZ1xuICAgICAqIGVudGl0eSBjaGVja2VyIGludG8gcXVlcnkgYXJncy5cbiAgICAgKi9cbiAgICBpbmplY3RSZWFkQ2hlY2tTZWxlY3QobW9kZWwsIGFyZ3MpIHtcbiAgICAgICAgLy8gd2UgbmVlZCB0byByZWN1cnNlIGludG8gcmVsYXRpb24gZmllbGRzIGJlZm9yZSBpbmplY3RpbmcgdGhlIGN1cnJlbnQgbGV2ZWwsIGJlY2F1c2VcbiAgICAgICAgLy8gaW5qZWN0aW9uIGludG8gY3VycmVudCBsZXZlbCBjYW4gcmVzdWx0IGluIHJlbGF0aW9uIGJlaW5nIHNlbGVjdGVkL2luY2x1ZGVkLCB3aGljaFxuICAgICAgICAvLyBjYW4gdGhlbiBjYXVzZSBpbmZpbml0ZSByZWN1cnNpb24gd2hlbiB3ZSB2aXNpdCByZWxhdGlvbiBsYXRlclxuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIHJlY3Vyc2UgaW50byByZWxhdGlvbiBmaWVsZHNcbiAgICAgICAgY29uc3QgdmlzaXRUYXJnZXQgPSAoX2EgPSBhcmdzLnNlbGVjdCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogYXJncy5pbmNsdWRlO1xuICAgICAgICBpZiAodmlzaXRUYXJnZXQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHZpc2l0VGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gKDAsIGNyb3NzXzEucmVzb2x2ZUZpZWxkKSh0aGlzLm1vZGVsTWV0YSwgbW9kZWwsIGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKChmaWVsZCA9PT0gbnVsbCB8fCBmaWVsZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmllbGQuaXNEYXRhTW9kZWwpICYmIHZpc2l0VGFyZ2V0W2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2aXNpdFRhcmdldFtrZXldICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdiBpcyBcInRydWVcIiwgZW5zdXJlIGl0J3MgYW4gb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpdFRhcmdldFtrZXldID0ge307XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmplY3RSZWFkQ2hlY2tTZWxlY3QoZmllbGQudHlwZSwgdmlzaXRUYXJnZXRba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhhc0ZpZWxkTGV2ZWxQb2xpY3kobW9kZWwpKSB7XG4gICAgICAgICAgICAvLyByZWN1cnNpdmVseSBpbmplY3Qgc2VsZWN0aW9uIGZvciBmaWVsZHMgbmVlZGVkIGZvciBmaWVsZC1sZXZlbCByZWFkIGNoZWNrc1xuICAgICAgICAgICAgY29uc3QgcmVhZEZpZWxkU2VsZWN0ID0gdGhpcy5nZXRGaWVsZFJlYWRDaGVja1NlbGVjdG9yKG1vZGVsKTtcbiAgICAgICAgICAgIGlmIChyZWFkRmllbGRTZWxlY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvSW5qZWN0UmVhZENoZWNrU2VsZWN0KG1vZGVsLCBhcmdzLCB7IHNlbGVjdDogcmVhZEZpZWxkU2VsZWN0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVudGl0eUNoZWNrZXIgPSB0aGlzLmdldEVudGl0eUNoZWNrZXIobW9kZWwsICdyZWFkJyk7XG4gICAgICAgIGlmIChlbnRpdHlDaGVja2VyID09PSBudWxsIHx8IGVudGl0eUNoZWNrZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVudGl0eUNoZWNrZXIuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuZG9JbmplY3RSZWFkQ2hlY2tTZWxlY3QobW9kZWwsIGFyZ3MsIHsgc2VsZWN0OiBlbnRpdHlDaGVja2VyLnNlbGVjdG9yIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRvSW5qZWN0UmVhZENoZWNrU2VsZWN0KG1vZGVsLCBhcmdzLCBpbnB1dCkge1xuICAgICAgICAvLyBvbWl0IHNob3VsZCBiZSBpZ25vcmVkIHRvIGF2b2lkIGludGVyZmVyaW5nIHdpdGggZmllbGQgc2VsZWN0aW9uXG4gICAgICAgIGlmIChhcmdzLm9taXQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBhcmdzLm9taXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoaW5wdXQgPT09IG51bGwgfHwgaW5wdXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlucHV0LnNlbGVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGFyZ2V0OyAvLyBpbmplY3Rpb24gdGFyZ2V0XG4gICAgICAgIGxldCBpc0luY2x1ZGUgPSBmYWxzZTsgLy8gaWYgdGhlIHRhcmdldCBpcyBpbmNsdWRlIG9yIHNlbGVjdFxuICAgICAgICBpZiAoYXJncy5zZWxlY3QpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IGFyZ3Muc2VsZWN0O1xuICAgICAgICAgICAgaXNJbmNsdWRlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJncy5pbmNsdWRlKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBhcmdzLmluY2x1ZGU7XG4gICAgICAgICAgICBpc0luY2x1ZGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0ID0gYXJncy5zZWxlY3QgPSB0aGlzLm1ha2VBbGxTY2FsYXJGaWVsZFNlbGVjdChtb2RlbCk7XG4gICAgICAgICAgICBpc0luY2x1ZGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzSW5jbHVkZSkge1xuICAgICAgICAgICAgLy8gbWVyZ2Ugc2VsZWN0c1xuICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoaW5wdXQuc2VsZWN0KSkge1xuICAgICAgICAgICAgICAgIGlmICh2ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0W2tdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRba10gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHJlY3Vyc2UgaW50byBuZXN0ZWQgc2VsZWN0cyAocmVsYXRpb24gZmllbGRzKVxuICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhpbnB1dC5zZWxlY3QpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdvYmplY3QnICYmICh2ID09PSBudWxsIHx8IHYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHYuc2VsZWN0KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gKDAsIGNyb3NzXzEucmVzb2x2ZUZpZWxkKSh0aGlzLm1vZGVsTWV0YSwgbW9kZWwsIGspO1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZCA9PT0gbnVsbCB8fCBmaWVsZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmllbGQuaXNEYXRhTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVjdXJzZSBpbnRvIHJlbGF0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0luY2x1ZGUgJiYgdGFyZ2V0W2tdID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWxlY3QgYWxsIGZpZWxkcyBmb3IgdGhlIHJlbGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRba10gPSB7IHNlbGVjdDogdGhpcy5tYWtlQWxsU2NhbGFyRmllbGRTZWxlY3QoZmllbGQudHlwZSkgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghdGFyZ2V0W2tdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlbnN1cmUgYW4gZW1wdHkgc2VsZWN0IGNsYXVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tdID0geyBzZWxlY3Q6IHt9IH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVjdXJzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvSW5qZWN0UmVhZENoZWNrU2VsZWN0KGZpZWxkLnR5cGUsIHRhcmdldFtrXSwgdik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG1ha2VBbGxTY2FsYXJGaWVsZFNlbGVjdChtb2RlbCkge1xuICAgICAgICBjb25zdCBmaWVsZHMgPSB0aGlzLmdldE1vZGVsRmllbGRzKG1vZGVsKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGlmIChmaWVsZHMpIHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGZpZWxkcykuZm9yRWFjaCgoW2ssIHZdKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF2LmlzRGF0YU1vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8jZW5kcmVnaW9uXG4gICAgLy8jcmVnaW9uIEVycm9yc1xuICAgIGRlbmllZEJ5UG9saWN5KG1vZGVsLCBvcGVyYXRpb24sIGV4dHJhLCByZWFzb24sIHpvZEVycm9ycykge1xuICAgICAgICBjb25zdCBhcmdzID0geyBjbGllbnRWZXJzaW9uOiAoMCwgdmVyc2lvbl8xLmdldFZlcnNpb24pKCksIGNvZGU6IGNvbnN0YW50c18xLlByaXNtYUVycm9yQ29kZS5DT05TVFJBSU5FRF9GQUlMRUQsIG1ldGE6IHt9IH07XG4gICAgICAgIGlmIChyZWFzb24pIHtcbiAgICAgICAgICAgIGFyZ3MubWV0YS5yZWFzb24gPSByZWFzb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHpvZEVycm9ycykge1xuICAgICAgICAgICAgYXJncy5tZXRhLnpvZEVycm9ycyA9IHpvZEVycm9ycztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEucHJpc21hQ2xpZW50S25vd25SZXF1ZXN0RXJyb3IpKHRoaXMuZGIsIHRoaXMucHJpc21hTW9kdWxlLCBgZGVuaWVkIGJ5IHBvbGljeTogJHttb2RlbH0gZW50aXRpZXMgZmFpbGVkICcke29wZXJhdGlvbn0nIGNoZWNrJHtleHRyYSA/ICcsICcgKyBleHRyYSA6ICcnfWAsIGFyZ3MpO1xuICAgIH1cbiAgICBub3RGb3VuZChtb2RlbCkge1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEucHJpc21hQ2xpZW50S25vd25SZXF1ZXN0RXJyb3IpKHRoaXMuZGIsIHRoaXMucHJpc21hTW9kdWxlLCBgZW50aXR5IG5vdCBmb3VuZCBmb3IgbW9kZWwgJHttb2RlbH1gLCB7XG4gICAgICAgICAgICBjbGllbnRWZXJzaW9uOiAoMCwgdmVyc2lvbl8xLmdldFZlcnNpb24pKCksXG4gICAgICAgICAgICBjb2RlOiAnUDIwMjUnLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8jZW5kcmVnaW9uXG4gICAgLy8jcmVnaW9uIE1pc2NcbiAgICAvKipcbiAgICAgKiBHZXRzIGZpZWxkIHNlbGVjdGlvbiBmb3IgZmV0Y2hpbmcgcHJlLXVwZGF0ZSBlbnRpdHkgdmFsdWVzIGZvciB0aGUgZ2l2ZW4gbW9kZWwuXG4gICAgICovXG4gICAgZ2V0UHJlVmFsdWVTZWxlY3QobW9kZWwpIHtcbiAgICAgICAgY29uc3QgZGVmID0gdGhpcy5nZXRNb2RlbFBvbGljeURlZihtb2RlbCk7XG4gICAgICAgIHJldHVybiBkZWYubW9kZWxMZXZlbC5wb3N0VXBkYXRlLnByZVVwZGF0ZVNlbGVjdG9yO1xuICAgIH1cbiAgICAvLyBnZXQgYSBtZXJnZWQgc2VsZWN0b3Igb2JqZWN0IGZvciBhbGwgZmllbGQtbGV2ZWwgcmVhZCBwb2xpY2llc1xuICAgIGdldEZpZWxkUmVhZENoZWNrU2VsZWN0b3IobW9kZWwpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IGRlZiA9IHRoaXMuZ2V0TW9kZWxQb2xpY3lEZWYobW9kZWwpO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgICAgIGNvbnN0IGZpZWxkTGV2ZWwgPSAoX2EgPSBkZWYuZmllbGRMZXZlbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlYWQ7XG4gICAgICAgIGlmIChmaWVsZExldmVsKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRlZiBvZiBPYmplY3QudmFsdWVzKGZpZWxkTGV2ZWwpKSB7XG4gICAgICAgICAgICAgICAgaWYgKChfYiA9IGRlZi5lbnRpdHlDaGVja2VyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gKDAsIGRlZXBtZXJnZV8xLmRlZmF1bHQpKHJlc3VsdCwgZGVmLmVudGl0eUNoZWNrZXIuc2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKF9jID0gZGVmLm92ZXJyaWRlRW50aXR5Q2hlY2tlcikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICgwLCBkZWVwbWVyZ2VfMS5kZWZhdWx0KShyZXN1bHQsIGRlZi5vdmVycmlkZUVudGl0eUNoZWNrZXIuc2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMocmVzdWx0KS5sZW5ndGggPiAwID8gcmVzdWx0IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjaGVja1JlYWRGaWVsZChtb2RlbCwgZmllbGQsIGVudGl0eSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgY29uc3QgZGVmID0gdGhpcy5nZXRNb2RlbFBvbGljeURlZihtb2RlbCk7XG4gICAgICAgIC8vIGNvbWJpbmUgcmVndWxhciBhbmQgb3ZlcnJpZGUgZmllbGQtbGV2ZWwgZW50aXR5IGNoZWNrZXJzIHdpdGggT1JcbiAgICAgICAgY29uc3QgY2hlY2tlciA9IChfYyA9IChfYiA9IChfYSA9IGRlZi5maWVsZExldmVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVhZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2ZpZWxkXSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmVudGl0eUNoZWNrZXI7XG4gICAgICAgIGNvbnN0IG92ZXJyaWRlQ2hlY2tlciA9IChfZiA9IChfZSA9IChfZCA9IGRlZi5maWVsZExldmVsKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QucmVhZCkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lW2ZpZWxkXSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLm92ZXJyaWRlRW50aXR5Q2hlY2tlcjtcbiAgICAgICAgY29uc3QgY29tYmluZWRDaGVja2VyID0gdGhpcy5jb21iaW5lRW50aXR5Q2hlY2tlcihjaGVja2VyLCBvdmVycmlkZUNoZWNrZXIsICdvcicpO1xuICAgICAgICBpZiAoY29tYmluZWRDaGVja2VyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNvbWJpbmVkQ2hlY2tlci5mdW5jKGVudGl0eSwgeyB1c2VyOiB0aGlzLnVzZXIgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzRmllbGRWYWxpZGF0aW9uKG1vZGVsKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoKF9iID0gKF9hID0gdGhpcy5wb2xpY3kudmFsaWRhdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWygwLCBsb3dlcl9jYXNlX2ZpcnN0XzEubG93ZXJDYXNlRmlyc3QpKG1vZGVsKV0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5oYXNWYWxpZGF0aW9uKSA9PT0gdHJ1ZTtcbiAgICB9XG4gICAgaGFzRmllbGRMZXZlbFBvbGljeShtb2RlbCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBkZWYgPSB0aGlzLmdldE1vZGVsUG9saWN5RGVmKG1vZGVsKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKChfYiA9IChfYSA9IGRlZi5maWVsZExldmVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVhZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge30pLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgWm9kIHNjaGVtYSBmb3IgdGhlIGdpdmVuIG1vZGVsIGFuZCBhY2Nlc3Mga2luZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBraW5kIElmIHVuZGVmaW5lZCwgcmV0dXJucyB0aGUgZnVsbCBzY2hlbWEuXG4gICAgICovXG4gICAgZ2V0Wm9kU2NoZW1hKG1vZGVsLCBraW5kID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICghdGhpcy5oYXNGaWVsZFZhbGlkYXRpb24obW9kZWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjaGVtYUtleSA9IGAkeygwLCB1cHBlcl9jYXNlX2ZpcnN0XzEudXBwZXJDYXNlRmlyc3QpKG1vZGVsKX0ke2tpbmQgPyAnUHJpc21hJyArICgwLCB1cHBlcl9jYXNlX2ZpcnN0XzEudXBwZXJDYXNlRmlyc3QpKGtpbmQpIDogJyd9U2NoZW1hYDtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuem9kU2NoZW1hcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1vZGVscykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW3NjaGVtYUtleV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBvc3QgcHJvY2Vzc2luZyBjaGVja3MgYW5kIGNsZWFuLXVwIGZvciByZWFkIG1vZGVsIGVudGl0aWVzLlxuICAgICAqL1xuICAgIHBvc3RQcm9jZXNzRm9yUmVhZChkYXRhLCBtb2RlbCwgcXVlcnlBcmdzKSB7XG4gICAgICAgIC8vIHByZXNlcnZlIHRoZSBvcmlnaW5hbCBkYXRhIGFzIGl0IG1heSBiZSBuZWVkZWQgZm9yIGNoZWNraW5nIGZpZWxkLWxldmVsIHJlYWRhYmlsaXR5LFxuICAgICAgICAvLyB3aGlsZSB0aGUgXCJkYXRhXCIgd2lsbCBiZSBtYW5pcHVsYXRlZCBkdXJpbmcgdHJhdmVyc2FsIChkZWxldGluZyB1bnJlYWRhYmxlIGZpZWxkcylcbiAgICAgICAgY29uc3Qgb3JpZ0RhdGEgPSB0aGlzLmNsb25lKGRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcy5kb1Bvc3RQcm9jZXNzRm9yUmVhZChkYXRhLCBtb2RlbCwgb3JpZ0RhdGEsIHF1ZXJ5QXJncywgdGhpcy5oYXNGaWVsZExldmVsUG9saWN5KG1vZGVsKSk7XG4gICAgfVxuICAgIGRvUG9zdFByb2Nlc3NGb3JSZWFkKGRhdGEsIG1vZGVsLCBmdWxsRGF0YSwgcXVlcnlBcmdzLCBoYXNGaWVsZExldmVsUG9saWN5LCBwYXRoID0gJycpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGlmIChkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZpbHRlcmVkRGF0YSA9IGRhdGE7XG4gICAgICAgIGxldCBmaWx0ZXJlZEZ1bGxEYXRhID0gZnVsbERhdGE7XG4gICAgICAgIGNvbnN0IGVudGl0eUNoZWNrZXIgPSB0aGlzLmdldEVudGl0eUNoZWNrZXIobW9kZWwsICdyZWFkJyk7XG4gICAgICAgIGlmIChlbnRpdHlDaGVja2VyKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIGZpbHRlcmVkRGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIGZpbHRlcmVkRnVsbERhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtlbnRpdHlEYXRhLCBlbnRpdHlGdWxsRGF0YV0gb2YgKDAsIGNyb3NzXzEuemlwKShkYXRhLCBmdWxsRGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbnRpdHlDaGVja2VyLmZ1bmMoZW50aXR5RGF0YSwgeyB1c2VyOiB0aGlzLnVzZXIgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZExvZ1F1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgW3BvbGljeV0gZHJvcHBpbmcgJHttb2RlbH0gZW50aXR5JHtwYXRoID8gJyBhdCAnICsgcGF0aCA6ICcnfSBkdWUgdG8gZW50aXR5IGNoZWNrZXJgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkRGF0YS5wdXNoKGVudGl0eURhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRGdWxsRGF0YS5wdXNoKGVudGl0eUZ1bGxEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghZW50aXR5Q2hlY2tlci5mdW5jKGRhdGEsIHsgdXNlcjogdGhpcy51c2VyIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZExvZ1F1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKGBbcG9saWN5XSBkcm9wcGluZyAke21vZGVsfSBlbnRpdHkke3BhdGggPyAnIGF0ICcgKyBwYXRoIDogJyd9IGR1ZSB0byBlbnRpdHkgY2hlY2tlcmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtlbnRpdHlEYXRhLCBlbnRpdHlGdWxsRGF0YV0gb2YgKDAsIGNyb3NzXzEuemlwKShmaWx0ZXJlZERhdGEsIGZpbHRlcmVkRnVsbERhdGEpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVudGl0eURhdGEgIT09ICdvYmplY3QnIHx8ICFlbnRpdHlEYXRhKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtmaWVsZCwgZmllbGREYXRhXSBvZiBPYmplY3QuZW50cmllcyhlbnRpdHlEYXRhKSkge1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZERhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRJbmZvID0gKDAsIGNyb3NzXzEucmVzb2x2ZUZpZWxkKSh0aGlzLm1vZGVsTWV0YSwgbW9kZWwsIGZpZWxkKTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpZWxkSW5mbykge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb3VsZCBiZSBfY291bnQsIGV0Yy5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoKF9hID0gcXVlcnlBcmdzID09PSBudWxsIHx8IHF1ZXJ5QXJncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcXVlcnlBcmdzLm9taXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtmaWVsZF0pID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc3BlY3QgYHsgb21pdDogeyBbZmllbGRdOiB0cnVlIH0gfWBcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGVudGl0eURhdGFbZmllbGRdO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhhc0ZpZWxkTGV2ZWxQb2xpY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gMS4gcmVtb3ZlIGZpZWxkcyBzZWxlY3RlZCBmb3IgY2hlY2tpbmcgZmllbGQtbGV2ZWwgcG9saWNpZXMgYnV0IG5vdCBzZWxlY3RlZCBieSB0aGUgb3JpZ2luYWwgcXVlcnkgYXJnc1xuICAgICAgICAgICAgICAgICAgICAvLyAyLiBldmFsdWF0ZSBmaWVsZC1sZXZlbCBwb2xpY2llcyBhbmQgcmVtb3ZlIGZpZWxkcyB0aGF0IGFyZSBub3QgcmVhZGFibGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZEluZm8uaXNEYXRhTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNjYWxhciBmaWVsZCwgZGVsZXRlIHVuc2VsZWN0ZWQgb25lc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0ID0gcXVlcnlBcmdzID09PSBudWxsIHx8IHF1ZXJ5QXJncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcXVlcnlBcmdzLnNlbGVjdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3QgJiYgdHlwZW9mIHNlbGVjdCA9PT0gJ29iamVjdCcgJiYgc2VsZWN0W2ZpZWxkXSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZXJlJ3MgYSBzZWxlY3QgY2xhdXNlIGJ1dCB0aGlzIGZpZWxkIGlzIG5vdCBpbmNsdWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlbnRpdHlEYXRhW2ZpZWxkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbGF0aW9uIGZpZWxkLCBkZWxldGUgaWYgbm90IHNlbGVjdGVkIG9yIGluY2x1ZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmNsdWRlID0gcXVlcnlBcmdzID09PSBudWxsIHx8IHF1ZXJ5QXJncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcXVlcnlBcmdzLmluY2x1ZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3QgPSBxdWVyeUFyZ3MgPT09IG51bGwgfHwgcXVlcnlBcmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBxdWVyeUFyZ3Muc2VsZWN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaW5jbHVkZSA9PT0gbnVsbCB8fCBpbmNsdWRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbmNsdWRlW2ZpZWxkXSkgJiYgIShzZWxlY3QgPT09IG51bGwgfHwgc2VsZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3RbZmllbGRdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbGF0aW9uIGZpZWxkIG5vdCBpbmNsdWRlZCBvciBzZWxlY3RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlbnRpdHlEYXRhW2ZpZWxkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBkZWxldGUgdW5yZWFkYWJsZSBmaWVsZHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrUmVhZEZpZWxkKG1vZGVsLCBmaWVsZCwgZW50aXR5RnVsbERhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG91bGRMb2dRdWVyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oYFtwb2xpY3ldIGRyb3BwaW5nIHVucmVhZGFibGUgZmllbGQgJHtwYXRoID8gcGF0aCArICcuJyA6ICcnfSR7ZmllbGR9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZW50aXR5RGF0YVtmaWVsZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmllbGRJbmZvLmlzRGF0YU1vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlY3Vyc2UgaW50byBuZXN0ZWQgZmllbGRzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRBcmdzID0gKF9jID0gKChfYiA9IHF1ZXJ5QXJncyA9PT0gbnVsbCB8fCBxdWVyeUFyZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHF1ZXJ5QXJncy5zZWxlY3QpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHF1ZXJ5QXJncyA9PT0gbnVsbCB8fCBxdWVyeUFyZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHF1ZXJ5QXJncy5pbmNsdWRlKSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jW2ZpZWxkXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmVzdGVkUmVzdWx0ID0gdGhpcy5kb1Bvc3RQcm9jZXNzRm9yUmVhZChmaWVsZERhdGEsIGZpZWxkSW5mby50eXBlLCBlbnRpdHlGdWxsRGF0YVtmaWVsZF0sIG5leHRBcmdzLCB0aGlzLmhhc0ZpZWxkTGV2ZWxQb2xpY3koZmllbGRJbmZvLnR5cGUpLCBwYXRoID8gcGF0aCArICcuJyArIGZpZWxkIDogZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmVzdGVkUmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlbnRpdHlEYXRhW2ZpZWxkXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGl0eURhdGFbZmllbGRdID0gbmVzdGVkUmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWx0ZXJlZERhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb25lcyBhbiBvYmplY3QgYW5kIG1ha2VzIHN1cmUgaXQncyBub3QgZW1wdHkuXG4gICAgICovXG4gICAgY2xvbmUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID8gKDAsIGRlZXBjb3B5XzEuZGVmYXVsdCkodmFsdWUpIDoge307XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcGxhY2UgY29udGVudCBvZiBgdGFyZ2V0YCBvYmplY3Qgd2l0aCBgd2l0aE9iamVjdGAgaW4tcGxhY2UuXG4gICAgICovXG4gICAgcmVwbGFjZSh0YXJnZXQsIHdpdGhPYmplY3QpIHtcbiAgICAgICAgaWYgKCF0YXJnZXQgfHwgdHlwZW9mIHRhcmdldCAhPT0gJ29iamVjdCcgfHwgIXdpdGhPYmplY3QgfHwgdHlwZW9mIHdpdGhPYmplY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtb3ZlIG1pc3Npbmcga2V5c1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0YXJnZXQpKSB7XG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gd2l0aE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGFyZ2V0W2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3ZlcndyaXRlIGtleXNcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMod2l0aE9iamVjdCkpIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGlja3MgcHJvcGVydGllcyBmcm9tIGFuIG9iamVjdC5cbiAgICAgKi9cbiAgICBwaWNrKHZhbHVlLCAuLi5wcm9wcykge1xuICAgICAgICBjb25zdCB2ID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBwcm9wcy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgcHJvcCkge1xuICAgICAgICAgICAgaWYgKHByb3AgaW4gdikge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtwcm9wXSA9IHZbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxuICAgIG1lcmdlV2hlcmVDbGF1c2Uod2hlcmUsIGV4dHJhKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF3aGVyZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHdoZXJlIGNsYXVzZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzVHJ1ZShleHRyYSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbnN0ZWFkIG9mIHNpbXBseSB3cmFwcGluZyB3aXRoIEFORCwgd2UgcHJlc2VydmUgdGhlIHN0cnVjdHVyZVxuICAgICAgICAvLyBvZiB0aGUgb3JpZ2luYWwgd2hlcmUgY2xhdXNlIGFuZCBtZXJnZSBgZXh0cmFgIGludG8gaXQgc28gdGhhdFxuICAgICAgICAvLyB1bmlxdWUgcXVlcnkgY2FuIGNvbnRpbnVlIHdvcmtpbmdcbiAgICAgICAgaWYgKHdoZXJlLkFORCkge1xuICAgICAgICAgICAgLy8gbWVyZ2UgaW50byBleGlzdGluZyBBTkQgY2xhdXNlXG4gICAgICAgICAgICBjb25zdCBjb25kaXRpb25zID0gQXJyYXkuaXNBcnJheSh3aGVyZS5BTkQpID8gWy4uLndoZXJlLkFORF0gOiBbd2hlcmUuQU5EXTtcbiAgICAgICAgICAgIGNvbmRpdGlvbnMucHVzaChleHRyYSk7XG4gICAgICAgICAgICBjb25zdCBjb21iaW5lZCA9IHRoaXMuYW5kKC4uLmNvbmRpdGlvbnMpO1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBtZXJnaW5nIGFsd2F5cyBnb2VzIHVuZGVyIEFORFxuICAgICAgICAgICAgd2hlcmUuQU5EID0gKF9hID0gY29tYmluZWQuQU5EKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb21iaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGluc2VydCBhbiBBTkQgY2xhdXNlXG4gICAgICAgICAgICB3aGVyZS5BTkQgPSBbZXh0cmFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGFuIGVudGl0eSBkYXRhLCByZXR1cm5zIGFuIG9iamVjdCBvbmx5IGNvbnRhaW5pbmcgaWQgZmllbGRzLlxuICAgICAqL1xuICAgIGdldElkRmllbGRWYWx1ZXMobW9kZWwsIGRhdGEpIHtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlkRmllbGRzID0gdGhpcy5nZXRJZEZpZWxkcyhtb2RlbCk7XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoaWRGaWVsZHMubWFwKChmKSA9PiBbZi5uYW1lLCBkYXRhW2YubmFtZV1dKSk7XG4gICAgfVxufVxuZXhwb3J0cy5Qb2xpY3lVdGlsID0gUG9saWN5VXRpbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvbGljeS11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/policy/policy-utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/promise.js":
/*!****************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/promise.js ***!
  \****************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/* eslint-disable @typescript-eslint/no-explicit-any */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createFluentPromise = exports.createDeferredPromise = void 0;\nconst cross_1 = __webpack_require__(/*! ../cross */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/cross/index.js\");\n/**\n * Creates a promise that only executes when it's awaited or .then() is called.\n * @see https://github.com/prisma/prisma/blob/main/packages/client/src/runtime/core/request/createPrismaPromise.ts\n */\nfunction createDeferredPromise(callback) {\n    let promise;\n    const cb = () => {\n        try {\n            return (promise !== null && promise !== void 0 ? promise : (promise = valueToPromise(callback())));\n        }\n        catch (err) {\n            // deal with synchronous errors\n            return Promise.reject(err);\n        }\n    };\n    return {\n        then(onFulfilled, onRejected) {\n            return cb().then(onFulfilled, onRejected);\n        },\n        catch(onRejected) {\n            return cb().catch(onRejected);\n        },\n        finally(onFinally) {\n            return cb().finally(onFinally);\n        },\n        [Symbol.toStringTag]: 'ZenStackPromise',\n    };\n}\nexports.createDeferredPromise = createDeferredPromise;\nfunction valueToPromise(thing) {\n    if (typeof thing === 'object' && typeof (thing === null || thing === void 0 ? void 0 : thing.then) === 'function') {\n        return thing;\n    }\n    else {\n        return Promise.resolve(thing);\n    }\n}\n/**\n * Create a deferred promise with fluent API call stub installed.\n *\n * @param callback The callback to execute when the promise is awaited.\n * @param parentArgs The parent promise's query args.\n * @param modelMeta The model metadata.\n * @param model The model name.\n */\nfunction createFluentPromise(callback, parentArgs, modelMeta, model) {\n    const promise = createDeferredPromise(callback);\n    const modelInfo = (0, cross_1.getModelInfo)(modelMeta, model);\n    if (!modelInfo) {\n        return promise;\n    }\n    // install fluent call stub for model fields\n    Object.values(modelInfo.fields)\n        .filter((field) => field.isDataModel)\n        .forEach((field) => {\n        // e.g., `posts` in `db.user.findUnique(...).posts()`\n        promise[field.name] = (fluentArgs) => {\n            if (field.isArray) {\n                // an array relation terminates fluent call chain\n                return createDeferredPromise(() => __awaiter(this, void 0, void 0, function* () {\n                    var _a;\n                    setFluentSelect(parentArgs, field.name, fluentArgs !== null && fluentArgs !== void 0 ? fluentArgs : true);\n                    const parentResult = yield promise;\n                    return (_a = parentResult === null || parentResult === void 0 ? void 0 : parentResult[field.name]) !== null && _a !== void 0 ? _a : null;\n                }));\n            }\n            else {\n                fluentArgs = Object.assign({}, fluentArgs);\n                // create a chained subsequent fluent call promise\n                return createFluentPromise(() => __awaiter(this, void 0, void 0, function* () {\n                    var _b;\n                    setFluentSelect(parentArgs, field.name, fluentArgs);\n                    const parentResult = yield promise;\n                    return (_b = parentResult === null || parentResult === void 0 ? void 0 : parentResult[field.name]) !== null && _b !== void 0 ? _b : null;\n                }), fluentArgs, modelMeta, field.type);\n            }\n        };\n    });\n    return promise;\n}\nexports.createFluentPromise = createFluentPromise;\nfunction setFluentSelect(args, fluentFieldName, fluentArgs) {\n    delete args.include;\n    args.select = { [fluentFieldName]: fluentArgs };\n}\n//# sourceMappingURL=promise.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHplbnN0YWNraHErcnVudGltZUAyLjIuNF9AcHJpc21hK2NsaWVudEA1LjE3LjBfcHJpc21hQDUuMTcuMF8vbm9kZV9tb2R1bGVzL0B6ZW5zdGFja2hxL3J1bnRpbWUvZW5oYW5jZW1lbnRzL3Byb21pc2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCLEdBQUcsNkJBQTZCO0FBQzNELGdCQUFnQixtQkFBTyxDQUFDLDJKQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXJibGlzbS9uZXh0LWpzLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B6ZW5zdGFja2hxK3J1bnRpbWVAMi4yLjRfQHByaXNtYStjbGllbnRANS4xNy4wX3ByaXNtYUA1LjE3LjBfL25vZGVfbW9kdWxlcy9AemVuc3RhY2tocS9ydW50aW1lL2VuaGFuY2VtZW50cy9wcm9taXNlLmpzPzU3YWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlRmx1ZW50UHJvbWlzZSA9IGV4cG9ydHMuY3JlYXRlRGVmZXJyZWRQcm9taXNlID0gdm9pZCAwO1xuY29uc3QgY3Jvc3NfMSA9IHJlcXVpcmUoXCIuLi9jcm9zc1wiKTtcbi8qKlxuICogQ3JlYXRlcyBhIHByb21pc2UgdGhhdCBvbmx5IGV4ZWN1dGVzIHdoZW4gaXQncyBhd2FpdGVkIG9yIC50aGVuKCkgaXMgY2FsbGVkLlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJpc21hL3ByaXNtYS9ibG9iL21haW4vcGFja2FnZXMvY2xpZW50L3NyYy9ydW50aW1lL2NvcmUvcmVxdWVzdC9jcmVhdGVQcmlzbWFQcm9taXNlLnRzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURlZmVycmVkUHJvbWlzZShjYWxsYmFjaykge1xuICAgIGxldCBwcm9taXNlO1xuICAgIGNvbnN0IGNiID0gKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIChwcm9taXNlICE9PSBudWxsICYmIHByb21pc2UgIT09IHZvaWQgMCA/IHByb21pc2UgOiAocHJvbWlzZSA9IHZhbHVlVG9Qcm9taXNlKGNhbGxiYWNrKCkpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gZGVhbCB3aXRoIHN5bmNocm9ub3VzIGVycm9yc1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYigpLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICAgICAgICB9LFxuICAgICAgICBjYXRjaChvblJlamVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gY2IoKS5jYXRjaChvblJlamVjdGVkKTtcbiAgICAgICAgfSxcbiAgICAgICAgZmluYWxseShvbkZpbmFsbHkpIHtcbiAgICAgICAgICAgIHJldHVybiBjYigpLmZpbmFsbHkob25GaW5hbGx5KTtcbiAgICAgICAgfSxcbiAgICAgICAgW1N5bWJvbC50b1N0cmluZ1RhZ106ICdaZW5TdGFja1Byb21pc2UnLFxuICAgIH07XG59XG5leHBvcnRzLmNyZWF0ZURlZmVycmVkUHJvbWlzZSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZTtcbmZ1bmN0aW9uIHZhbHVlVG9Qcm9taXNlKHRoaW5nKSB7XG4gICAgaWYgKHR5cGVvZiB0aGluZyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mICh0aGluZyA9PT0gbnVsbCB8fCB0aGluZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGhpbmcudGhlbikgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRoaW5nO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGluZyk7XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGUgYSBkZWZlcnJlZCBwcm9taXNlIHdpdGggZmx1ZW50IEFQSSBjYWxsIHN0dWIgaW5zdGFsbGVkLlxuICpcbiAqIEBwYXJhbSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSBwcm9taXNlIGlzIGF3YWl0ZWQuXG4gKiBAcGFyYW0gcGFyZW50QXJncyBUaGUgcGFyZW50IHByb21pc2UncyBxdWVyeSBhcmdzLlxuICogQHBhcmFtIG1vZGVsTWV0YSBUaGUgbW9kZWwgbWV0YWRhdGEuXG4gKiBAcGFyYW0gbW9kZWwgVGhlIG1vZGVsIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZsdWVudFByb21pc2UoY2FsbGJhY2ssIHBhcmVudEFyZ3MsIG1vZGVsTWV0YSwgbW9kZWwpIHtcbiAgICBjb25zdCBwcm9taXNlID0gY3JlYXRlRGVmZXJyZWRQcm9taXNlKGNhbGxiYWNrKTtcbiAgICBjb25zdCBtb2RlbEluZm8gPSAoMCwgY3Jvc3NfMS5nZXRNb2RlbEluZm8pKG1vZGVsTWV0YSwgbW9kZWwpO1xuICAgIGlmICghbW9kZWxJbmZvKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICAvLyBpbnN0YWxsIGZsdWVudCBjYWxsIHN0dWIgZm9yIG1vZGVsIGZpZWxkc1xuICAgIE9iamVjdC52YWx1ZXMobW9kZWxJbmZvLmZpZWxkcylcbiAgICAgICAgLmZpbHRlcigoZmllbGQpID0+IGZpZWxkLmlzRGF0YU1vZGVsKVxuICAgICAgICAuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgICAgLy8gZS5nLiwgYHBvc3RzYCBpbiBgZGIudXNlci5maW5kVW5pcXVlKC4uLikucG9zdHMoKWBcbiAgICAgICAgcHJvbWlzZVtmaWVsZC5uYW1lXSA9IChmbHVlbnRBcmdzKSA9PiB7XG4gICAgICAgICAgICBpZiAoZmllbGQuaXNBcnJheSkge1xuICAgICAgICAgICAgICAgIC8vIGFuIGFycmF5IHJlbGF0aW9uIHRlcm1pbmF0ZXMgZmx1ZW50IGNhbGwgY2hhaW5cbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlRGVmZXJyZWRQcm9taXNlKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBzZXRGbHVlbnRTZWxlY3QocGFyZW50QXJncywgZmllbGQubmFtZSwgZmx1ZW50QXJncyAhPT0gbnVsbCAmJiBmbHVlbnRBcmdzICE9PSB2b2lkIDAgPyBmbHVlbnRBcmdzIDogdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudFJlc3VsdCA9IHlpZWxkIHByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoX2EgPSBwYXJlbnRSZXN1bHQgPT09IG51bGwgfHwgcGFyZW50UmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnRSZXN1bHRbZmllbGQubmFtZV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmx1ZW50QXJncyA9IE9iamVjdC5hc3NpZ24oe30sIGZsdWVudEFyZ3MpO1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhIGNoYWluZWQgc3Vic2VxdWVudCBmbHVlbnQgY2FsbCBwcm9taXNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUZsdWVudFByb21pc2UoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2I7XG4gICAgICAgICAgICAgICAgICAgIHNldEZsdWVudFNlbGVjdChwYXJlbnRBcmdzLCBmaWVsZC5uYW1lLCBmbHVlbnRBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50UmVzdWx0ID0geWllbGQgcHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfYiA9IHBhcmVudFJlc3VsdCA9PT0gbnVsbCB8fCBwYXJlbnRSZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudFJlc3VsdFtmaWVsZC5uYW1lXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbDtcbiAgICAgICAgICAgICAgICB9KSwgZmx1ZW50QXJncywgbW9kZWxNZXRhLCBmaWVsZC50eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbmV4cG9ydHMuY3JlYXRlRmx1ZW50UHJvbWlzZSA9IGNyZWF0ZUZsdWVudFByb21pc2U7XG5mdW5jdGlvbiBzZXRGbHVlbnRTZWxlY3QoYXJncywgZmx1ZW50RmllbGROYW1lLCBmbHVlbnRBcmdzKSB7XG4gICAgZGVsZXRlIGFyZ3MuaW5jbHVkZTtcbiAgICBhcmdzLnNlbGVjdCA9IHsgW2ZsdWVudEZpZWxkTmFtZV06IGZsdWVudEFyZ3MgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb21pc2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/promise.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/proxy.js":
/*!**************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/proxy.js ***!
  \**************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/* eslint-disable @typescript-eslint/no-explicit-any */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.makeProxy = exports.DefaultPrismaProxyHandler = void 0;\nconst deepcopy_1 = __importDefault(__webpack_require__(/*! deepcopy */ \"(rsc)/./node_modules/.pnpm/deepcopy@2.1.0/node_modules/deepcopy/index.mjs\"));\nconst constants_1 = __webpack_require__(/*! ../constants */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/constants.js\");\nconst promise_1 = __webpack_require__(/*! ./promise */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/promise.js\");\n/**\n * A default implementation of @see PrismaProxyHandler which directly\n * delegates to the wrapped Prisma client. It offers a few overridable\n * methods to allow more easily inject custom logic.\n */\nclass DefaultPrismaProxyHandler {\n    constructor(prisma, model, options) {\n        this.prisma = prisma;\n        this.model = model;\n        this.options = options;\n    }\n    withFluentCall(method, args, postProcess = true) {\n        args = args ? (0, deepcopy_1.default)(args) : {};\n        const promise = (0, promise_1.createFluentPromise)(() => __awaiter(this, void 0, void 0, function* () {\n            args = yield this.preprocessArgs(method, args);\n            const r = yield this.prisma[this.model][method](args);\n            return postProcess ? this.processResultEntity(r) : r;\n        }), args, this.options.modelMeta, this.model);\n        return promise;\n    }\n    deferred(method, args, postProcess = true) {\n        return (0, promise_1.createDeferredPromise)(() => __awaiter(this, void 0, void 0, function* () {\n            args = yield this.preprocessArgs(method, args);\n            const r = yield this.prisma[this.model][method](args);\n            return postProcess ? this.processResultEntity(r) : r;\n        }));\n    }\n    findUnique(args) {\n        return this.withFluentCall('findUnique', args);\n    }\n    findUniqueOrThrow(args) {\n        return this.withFluentCall('findUniqueOrThrow', args);\n    }\n    findFirst(args) {\n        return this.withFluentCall('findFirst', args);\n    }\n    findFirstOrThrow(args) {\n        return this.withFluentCall('findFirstOrThrow', args);\n    }\n    findMany(args) {\n        return this.deferred('findMany', args);\n    }\n    create(args) {\n        return this.deferred('create', args);\n    }\n    createMany(args) {\n        return this.deferred('createMany', args, false);\n    }\n    createManyAndReturn(args) {\n        return this.deferred('createManyAndReturn', args);\n    }\n    update(args) {\n        return this.deferred('update', args);\n    }\n    updateMany(args) {\n        return this.deferred('updateMany', args, false);\n    }\n    upsert(args) {\n        return this.deferred('upsert', args);\n    }\n    delete(args) {\n        return this.deferred('delete', args);\n    }\n    deleteMany(args) {\n        return this.deferred('deleteMany', args, false);\n    }\n    aggregate(args) {\n        return this.deferred('aggregate', args, false);\n    }\n    groupBy(args) {\n        return this.deferred('groupBy', args, false);\n    }\n    count(args) {\n        return this.deferred('count', args, false);\n    }\n    subscribe(args) {\n        return this.deferred('subscribe', args, false);\n    }\n    /**\n     * Processes result entities before they're returned\n     */\n    processResultEntity(data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return data;\n        });\n    }\n    /**\n     * Processes query args before they're passed to Prisma.\n     */\n    preprocessArgs(method, args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return args;\n        });\n    }\n}\nexports.DefaultPrismaProxyHandler = DefaultPrismaProxyHandler;\n// a marker for filtering error stack trace\nconst ERROR_MARKER = '__error_marker__';\nconst customInspect = Symbol.for('nodejs.util.inspect.custom');\n/**\n * Makes a Prisma client proxy.\n */\nfunction makeProxy(prisma, modelMeta, makeHandler, name = 'unnamed_enhancer', errorTransformer) {\n    const models = Object.keys(modelMeta.models).map((k) => k.toLowerCase());\n    const proxy = new Proxy(prisma, {\n        get: (target, prop, receiver) => {\n            // enhancer metadata\n            if (prop === constants_1.PRISMA_PROXY_ENHANCER) {\n                return name;\n            }\n            if (prop === '$transaction') {\n                // for interactive transactions, we need to proxy the transaction function so that\n                // when it runs the callback, it provides a proxy to the Prisma client wrapped with\n                // the same handler\n                //\n                // TODO: batch transaction is not supported yet, how?\n                const $transaction = Reflect.get(target, prop, receiver);\n                if ($transaction) {\n                    return (input, ...rest) => {\n                        if (Array.isArray(input)) {\n                            throw new Error('Sequential operations transaction is not supported by ZenStack enhanced Prisma client. Please use interactive transaction instead.');\n                        }\n                        else if (typeof input !== 'function') {\n                            throw new Error('A function value input is expected');\n                        }\n                        const txFunc = input;\n                        return $transaction.bind(target)((tx) => {\n                            // create a proxy for the transaction function\n                            const txProxy = makeProxy(tx, modelMeta, makeHandler, name + '$tx');\n                            // call the transaction function with the proxy\n                            return txFunc(txProxy);\n                        }, ...rest);\n                    };\n                }\n                else {\n                    return $transaction;\n                }\n            }\n            if (typeof prop !== 'string' || prop.startsWith('$') || !models.includes(prop.toLowerCase())) {\n                // skip non-model fields\n                return Reflect.get(target, prop, receiver);\n            }\n            const propVal = Reflect.get(target, prop, receiver);\n            if (!propVal || typeof propVal !== 'object') {\n                return propVal;\n            }\n            return createHandlerProxy(makeHandler(target, prop), propVal, prop, errorTransformer);\n        },\n    });\n    proxy[customInspect] = `$zenstack_prisma_${prisma._clientVersion}`;\n    return proxy;\n}\nexports.makeProxy = makeProxy;\n// A proxy for capturing errors and processing stack trace\nfunction createHandlerProxy(handler, origTarget, model, errorTransformer) {\n    return new Proxy(handler, {\n        get(target, propKey) {\n            const prop = target[propKey];\n            if (typeof prop !== 'function') {\n                // the proxy handler doesn't have this method, fall back to the original target\n                // this can happen for new methods added by Prisma Client Extensions\n                return origTarget[propKey];\n            }\n            // eslint-disable-next-line @typescript-eslint/ban-types\n            const origMethod = prop;\n            return function (...args) {\n                // using proxy with async functions results in messed-up error stack trace,\n                // create an error to capture the current stack\n                const capture = new Error(ERROR_MARKER);\n                // the original proxy returned by the PrismaClient proxy\n                const promise = origMethod.apply(handler, args);\n                // modify the error stack\n                const resultPromise = (0, promise_1.createDeferredPromise)(() => {\n                    return new Promise((resolve, reject) => {\n                        promise.then((value) => resolve(value), (err) => {\n                            if (capture.stack && err instanceof Error) {\n                                // save the original stack and replace it with a clean one\n                                err.internalStack = err.stack;\n                                err.stack = cleanCallStack(capture.stack, model, propKey.toString(), err.message);\n                            }\n                            if (errorTransformer) {\n                                err = errorTransformer ? errorTransformer(err) : err;\n                            }\n                            reject(err);\n                        });\n                    });\n                });\n                // carry over extra fields from the original promise\n                for (const [k, v] of Object.entries(promise)) {\n                    if (!(k in resultPromise)) {\n                        resultPromise[k] = v;\n                    }\n                }\n                return resultPromise;\n            };\n        },\n    });\n}\n// Filter out @zenstackhq/runtime stack (generated by proxy) from stack trace\nfunction cleanCallStack(stack, model, method, message) {\n    // message line\n    let resultStack = `Error calling enhanced Prisma method \\`${model}.${method}\\`: ${message}`;\n    const lines = stack.split('\\n');\n    let foundMarker = false;\n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i];\n        if (!foundMarker) {\n            // find marker, then stack trace lines follow\n            if (line.includes(ERROR_MARKER)) {\n                foundMarker = true;\n            }\n            continue;\n        }\n        // skip leading zenstack and anonymous lines\n        if (line.includes('@zenstackhq/runtime') || line.includes('Proxy.<anonymous>')) {\n            continue;\n        }\n        // capture remaining lines\n        resultStack += lines\n            .slice(i)\n            .map((l) => '\\n' + l)\n            .join();\n        break;\n    }\n    return resultStack;\n}\n//# sourceMappingURL=proxy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHplbnN0YWNraHErcnVudGltZUAyLjIuNF9AcHJpc21hK2NsaWVudEA1LjE3LjBfcHJpc21hQDUuMTcuMF8vbm9kZV9tb2R1bGVzL0B6ZW5zdGFja2hxL3J1bnRpbWUvZW5oYW5jZW1lbnRzL3Byb3h5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcsaUNBQWlDO0FBQ3JELG1DQUFtQyxtQkFBTyxDQUFDLDJGQUFVO0FBQ3JELG9CQUFvQixtQkFBTyxDQUFDLDZKQUFjO0FBQzFDLGtCQUFrQixtQkFBTyxDQUFDLHFLQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0wsK0NBQStDLHNCQUFzQjtBQUNyRTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsTUFBTSxHQUFHLE9BQU8sTUFBTSxRQUFRO0FBQzlGO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hcmJsaXNtL25leHQtanMvLi9ub2RlX21vZHVsZXMvLnBucG0vQHplbnN0YWNraHErcnVudGltZUAyLjIuNF9AcHJpc21hK2NsaWVudEA1LjE3LjBfcHJpc21hQDUuMTcuMF8vbm9kZV9tb2R1bGVzL0B6ZW5zdGFja2hxL3J1bnRpbWUvZW5oYW5jZW1lbnRzL3Byb3h5LmpzPzYxOWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubWFrZVByb3h5ID0gZXhwb3J0cy5EZWZhdWx0UHJpc21hUHJveHlIYW5kbGVyID0gdm9pZCAwO1xuY29uc3QgZGVlcGNvcHlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVlcGNvcHlcIikpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xuY29uc3QgcHJvbWlzZV8xID0gcmVxdWlyZShcIi4vcHJvbWlzZVwiKTtcbi8qKlxuICogQSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIEBzZWUgUHJpc21hUHJveHlIYW5kbGVyIHdoaWNoIGRpcmVjdGx5XG4gKiBkZWxlZ2F0ZXMgdG8gdGhlIHdyYXBwZWQgUHJpc21hIGNsaWVudC4gSXQgb2ZmZXJzIGEgZmV3IG92ZXJyaWRhYmxlXG4gKiBtZXRob2RzIHRvIGFsbG93IG1vcmUgZWFzaWx5IGluamVjdCBjdXN0b20gbG9naWMuXG4gKi9cbmNsYXNzIERlZmF1bHRQcmlzbWFQcm94eUhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKHByaXNtYSwgbW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5wcmlzbWEgPSBwcmlzbWE7XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgd2l0aEZsdWVudENhbGwobWV0aG9kLCBhcmdzLCBwb3N0UHJvY2VzcyA9IHRydWUpIHtcbiAgICAgICAgYXJncyA9IGFyZ3MgPyAoMCwgZGVlcGNvcHlfMS5kZWZhdWx0KShhcmdzKSA6IHt9O1xuICAgICAgICBjb25zdCBwcm9taXNlID0gKDAsIHByb21pc2VfMS5jcmVhdGVGbHVlbnRQcm9taXNlKSgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBhcmdzID0geWllbGQgdGhpcy5wcmVwcm9jZXNzQXJncyhtZXRob2QsIGFyZ3MpO1xuICAgICAgICAgICAgY29uc3QgciA9IHlpZWxkIHRoaXMucHJpc21hW3RoaXMubW9kZWxdW21ldGhvZF0oYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gcG9zdFByb2Nlc3MgPyB0aGlzLnByb2Nlc3NSZXN1bHRFbnRpdHkocikgOiByO1xuICAgICAgICB9KSwgYXJncywgdGhpcy5vcHRpb25zLm1vZGVsTWV0YSwgdGhpcy5tb2RlbCk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBkZWZlcnJlZChtZXRob2QsIGFyZ3MsIHBvc3RQcm9jZXNzID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gKDAsIHByb21pc2VfMS5jcmVhdGVEZWZlcnJlZFByb21pc2UpKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGFyZ3MgPSB5aWVsZCB0aGlzLnByZXByb2Nlc3NBcmdzKG1ldGhvZCwgYXJncyk7XG4gICAgICAgICAgICBjb25zdCByID0geWllbGQgdGhpcy5wcmlzbWFbdGhpcy5tb2RlbF1bbWV0aG9kXShhcmdzKTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0UHJvY2VzcyA/IHRoaXMucHJvY2Vzc1Jlc3VsdEVudGl0eShyKSA6IHI7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgZmluZFVuaXF1ZShhcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhGbHVlbnRDYWxsKCdmaW5kVW5pcXVlJywgYXJncyk7XG4gICAgfVxuICAgIGZpbmRVbmlxdWVPclRocm93KGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aEZsdWVudENhbGwoJ2ZpbmRVbmlxdWVPclRocm93JywgYXJncyk7XG4gICAgfVxuICAgIGZpbmRGaXJzdChhcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhGbHVlbnRDYWxsKCdmaW5kRmlyc3QnLCBhcmdzKTtcbiAgICB9XG4gICAgZmluZEZpcnN0T3JUaHJvdyhhcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhGbHVlbnRDYWxsKCdmaW5kRmlyc3RPclRocm93JywgYXJncyk7XG4gICAgfVxuICAgIGZpbmRNYW55KGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmZXJyZWQoJ2ZpbmRNYW55JywgYXJncyk7XG4gICAgfVxuICAgIGNyZWF0ZShhcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZmVycmVkKCdjcmVhdGUnLCBhcmdzKTtcbiAgICB9XG4gICAgY3JlYXRlTWFueShhcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZmVycmVkKCdjcmVhdGVNYW55JywgYXJncywgZmFsc2UpO1xuICAgIH1cbiAgICBjcmVhdGVNYW55QW5kUmV0dXJuKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmZXJyZWQoJ2NyZWF0ZU1hbnlBbmRSZXR1cm4nLCBhcmdzKTtcbiAgICB9XG4gICAgdXBkYXRlKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmZXJyZWQoJ3VwZGF0ZScsIGFyZ3MpO1xuICAgIH1cbiAgICB1cGRhdGVNYW55KGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmZXJyZWQoJ3VwZGF0ZU1hbnknLCBhcmdzLCBmYWxzZSk7XG4gICAgfVxuICAgIHVwc2VydChhcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZmVycmVkKCd1cHNlcnQnLCBhcmdzKTtcbiAgICB9XG4gICAgZGVsZXRlKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmZXJyZWQoJ2RlbGV0ZScsIGFyZ3MpO1xuICAgIH1cbiAgICBkZWxldGVNYW55KGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmZXJyZWQoJ2RlbGV0ZU1hbnknLCBhcmdzLCBmYWxzZSk7XG4gICAgfVxuICAgIGFnZ3JlZ2F0ZShhcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZmVycmVkKCdhZ2dyZWdhdGUnLCBhcmdzLCBmYWxzZSk7XG4gICAgfVxuICAgIGdyb3VwQnkoYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWZlcnJlZCgnZ3JvdXBCeScsIGFyZ3MsIGZhbHNlKTtcbiAgICB9XG4gICAgY291bnQoYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWZlcnJlZCgnY291bnQnLCBhcmdzLCBmYWxzZSk7XG4gICAgfVxuICAgIHN1YnNjcmliZShhcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZmVycmVkKCdzdWJzY3JpYmUnLCBhcmdzLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3NlcyByZXN1bHQgZW50aXRpZXMgYmVmb3JlIHRoZXkncmUgcmV0dXJuZWRcbiAgICAgKi9cbiAgICBwcm9jZXNzUmVzdWx0RW50aXR5KGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2Vzc2VzIHF1ZXJ5IGFyZ3MgYmVmb3JlIHRoZXkncmUgcGFzc2VkIHRvIFByaXNtYS5cbiAgICAgKi9cbiAgICBwcmVwcm9jZXNzQXJncyhtZXRob2QsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkRlZmF1bHRQcmlzbWFQcm94eUhhbmRsZXIgPSBEZWZhdWx0UHJpc21hUHJveHlIYW5kbGVyO1xuLy8gYSBtYXJrZXIgZm9yIGZpbHRlcmluZyBlcnJvciBzdGFjayB0cmFjZVxuY29uc3QgRVJST1JfTUFSS0VSID0gJ19fZXJyb3JfbWFya2VyX18nO1xuY29uc3QgY3VzdG9tSW5zcGVjdCA9IFN5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyk7XG4vKipcbiAqIE1ha2VzIGEgUHJpc21hIGNsaWVudCBwcm94eS5cbiAqL1xuZnVuY3Rpb24gbWFrZVByb3h5KHByaXNtYSwgbW9kZWxNZXRhLCBtYWtlSGFuZGxlciwgbmFtZSA9ICd1bm5hbWVkX2VuaGFuY2VyJywgZXJyb3JUcmFuc2Zvcm1lcikge1xuICAgIGNvbnN0IG1vZGVscyA9IE9iamVjdC5rZXlzKG1vZGVsTWV0YS5tb2RlbHMpLm1hcCgoaykgPT4gay50b0xvd2VyQ2FzZSgpKTtcbiAgICBjb25zdCBwcm94eSA9IG5ldyBQcm94eShwcmlzbWEsIHtcbiAgICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgPT4ge1xuICAgICAgICAgICAgLy8gZW5oYW5jZXIgbWV0YWRhdGFcbiAgICAgICAgICAgIGlmIChwcm9wID09PSBjb25zdGFudHNfMS5QUklTTUFfUFJPWFlfRU5IQU5DRVIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wID09PSAnJHRyYW5zYWN0aW9uJykge1xuICAgICAgICAgICAgICAgIC8vIGZvciBpbnRlcmFjdGl2ZSB0cmFuc2FjdGlvbnMsIHdlIG5lZWQgdG8gcHJveHkgdGhlIHRyYW5zYWN0aW9uIGZ1bmN0aW9uIHNvIHRoYXRcbiAgICAgICAgICAgICAgICAvLyB3aGVuIGl0IHJ1bnMgdGhlIGNhbGxiYWNrLCBpdCBwcm92aWRlcyBhIHByb3h5IHRvIHRoZSBQcmlzbWEgY2xpZW50IHdyYXBwZWQgd2l0aFxuICAgICAgICAgICAgICAgIC8vIHRoZSBzYW1lIGhhbmRsZXJcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGJhdGNoIHRyYW5zYWN0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgeWV0LCBob3c/XG4gICAgICAgICAgICAgICAgY29uc3QgJHRyYW5zYWN0aW9uID0gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICAgICAgaWYgKCR0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGlucHV0LCAuLi5yZXN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcXVlbnRpYWwgb3BlcmF0aW9ucyB0cmFuc2FjdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGJ5IFplblN0YWNrIGVuaGFuY2VkIFByaXNtYSBjbGllbnQuIFBsZWFzZSB1c2UgaW50ZXJhY3RpdmUgdHJhbnNhY3Rpb24gaW5zdGVhZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSBmdW5jdGlvbiB2YWx1ZSBpbnB1dCBpcyBleHBlY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHhGdW5jID0gaW5wdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRyYW5zYWN0aW9uLmJpbmQodGFyZ2V0KSgodHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSBwcm94eSBmb3IgdGhlIHRyYW5zYWN0aW9uIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHhQcm94eSA9IG1ha2VQcm94eSh0eCwgbW9kZWxNZXRhLCBtYWtlSGFuZGxlciwgbmFtZSArICckdHgnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWxsIHRoZSB0cmFuc2FjdGlvbiBmdW5jdGlvbiB3aXRoIHRoZSBwcm94eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0eEZ1bmModHhQcm94eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAuLi5yZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdHJhbnNhY3Rpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wICE9PSAnc3RyaW5nJyB8fCBwcm9wLnN0YXJ0c1dpdGgoJyQnKSB8fCAhbW9kZWxzLmluY2x1ZGVzKHByb3AudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBza2lwIG5vbi1tb2RlbCBmaWVsZHNcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcm9wVmFsID0gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICBpZiAoIXByb3BWYWwgfHwgdHlwZW9mIHByb3BWYWwgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3BWYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlSGFuZGxlclByb3h5KG1ha2VIYW5kbGVyKHRhcmdldCwgcHJvcCksIHByb3BWYWwsIHByb3AsIGVycm9yVHJhbnNmb3JtZXIpO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHByb3h5W2N1c3RvbUluc3BlY3RdID0gYCR6ZW5zdGFja19wcmlzbWFfJHtwcmlzbWEuX2NsaWVudFZlcnNpb259YDtcbiAgICByZXR1cm4gcHJveHk7XG59XG5leHBvcnRzLm1ha2VQcm94eSA9IG1ha2VQcm94eTtcbi8vIEEgcHJveHkgZm9yIGNhcHR1cmluZyBlcnJvcnMgYW5kIHByb2Nlc3Npbmcgc3RhY2sgdHJhY2VcbmZ1bmN0aW9uIGNyZWF0ZUhhbmRsZXJQcm94eShoYW5kbGVyLCBvcmlnVGFyZ2V0LCBtb2RlbCwgZXJyb3JUcmFuc2Zvcm1lcikge1xuICAgIHJldHVybiBuZXcgUHJveHkoaGFuZGxlciwge1xuICAgICAgICBnZXQodGFyZ2V0LCBwcm9wS2V5KSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wID0gdGFyZ2V0W3Byb3BLZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIHByb3h5IGhhbmRsZXIgZG9lc24ndCBoYXZlIHRoaXMgbWV0aG9kLCBmYWxsIGJhY2sgdG8gdGhlIG9yaWdpbmFsIHRhcmdldFxuICAgICAgICAgICAgICAgIC8vIHRoaXMgY2FuIGhhcHBlbiBmb3IgbmV3IG1ldGhvZHMgYWRkZWQgYnkgUHJpc21hIENsaWVudCBFeHRlbnNpb25zXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdUYXJnZXRbcHJvcEtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuICAgICAgICAgICAgY29uc3Qgb3JpZ01ldGhvZCA9IHByb3A7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAvLyB1c2luZyBwcm94eSB3aXRoIGFzeW5jIGZ1bmN0aW9ucyByZXN1bHRzIGluIG1lc3NlZC11cCBlcnJvciBzdGFjayB0cmFjZSxcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYW4gZXJyb3IgdG8gY2FwdHVyZSB0aGUgY3VycmVudCBzdGFja1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhcHR1cmUgPSBuZXcgRXJyb3IoRVJST1JfTUFSS0VSKTtcbiAgICAgICAgICAgICAgICAvLyB0aGUgb3JpZ2luYWwgcHJveHkgcmV0dXJuZWQgYnkgdGhlIFByaXNtYUNsaWVudCBwcm94eVxuICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBvcmlnTWV0aG9kLmFwcGx5KGhhbmRsZXIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIC8vIG1vZGlmeSB0aGUgZXJyb3Igc3RhY2tcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRQcm9taXNlID0gKDAsIHByb21pc2VfMS5jcmVhdGVEZWZlcnJlZFByb21pc2UpKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UudGhlbigodmFsdWUpID0+IHJlc29sdmUodmFsdWUpLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhcHR1cmUuc3RhY2sgJiYgZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSB0aGUgb3JpZ2luYWwgc3RhY2sgYW5kIHJlcGxhY2UgaXQgd2l0aCBhIGNsZWFuIG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIuaW50ZXJuYWxTdGFjayA9IGVyci5zdGFjaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyLnN0YWNrID0gY2xlYW5DYWxsU3RhY2soY2FwdHVyZS5zdGFjaywgbW9kZWwsIHByb3BLZXkudG9TdHJpbmcoKSwgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JUcmFuc2Zvcm1lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSBlcnJvclRyYW5zZm9ybWVyID8gZXJyb3JUcmFuc2Zvcm1lcihlcnIpIDogZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBjYXJyeSBvdmVyIGV4dHJhIGZpZWxkcyBmcm9tIHRoZSBvcmlnaW5hbCBwcm9taXNlXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMocHJvbWlzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoayBpbiByZXN1bHRQcm9taXNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0UHJvbWlzZVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFByb21pc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLy8gRmlsdGVyIG91dCBAemVuc3RhY2tocS9ydW50aW1lIHN0YWNrIChnZW5lcmF0ZWQgYnkgcHJveHkpIGZyb20gc3RhY2sgdHJhY2VcbmZ1bmN0aW9uIGNsZWFuQ2FsbFN0YWNrKHN0YWNrLCBtb2RlbCwgbWV0aG9kLCBtZXNzYWdlKSB7XG4gICAgLy8gbWVzc2FnZSBsaW5lXG4gICAgbGV0IHJlc3VsdFN0YWNrID0gYEVycm9yIGNhbGxpbmcgZW5oYW5jZWQgUHJpc21hIG1ldGhvZCBcXGAke21vZGVsfS4ke21ldGhvZH1cXGA6ICR7bWVzc2FnZX1gO1xuICAgIGNvbnN0IGxpbmVzID0gc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgIGxldCBmb3VuZE1hcmtlciA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgICBpZiAoIWZvdW5kTWFya2VyKSB7XG4gICAgICAgICAgICAvLyBmaW5kIG1hcmtlciwgdGhlbiBzdGFjayB0cmFjZSBsaW5lcyBmb2xsb3dcbiAgICAgICAgICAgIGlmIChsaW5lLmluY2x1ZGVzKEVSUk9SX01BUktFUikpIHtcbiAgICAgICAgICAgICAgICBmb3VuZE1hcmtlciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBza2lwIGxlYWRpbmcgemVuc3RhY2sgYW5kIGFub255bW91cyBsaW5lc1xuICAgICAgICBpZiAobGluZS5pbmNsdWRlcygnQHplbnN0YWNraHEvcnVudGltZScpIHx8IGxpbmUuaW5jbHVkZXMoJ1Byb3h5Ljxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhcHR1cmUgcmVtYWluaW5nIGxpbmVzXG4gICAgICAgIHJlc3VsdFN0YWNrICs9IGxpbmVzXG4gICAgICAgICAgICAuc2xpY2UoaSlcbiAgICAgICAgICAgIC5tYXAoKGwpID0+ICdcXG4nICsgbClcbiAgICAgICAgICAgIC5qb2luKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0U3RhY2s7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm94eS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/proxy.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/query-utils.js":
/*!********************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/query-utils.js ***!
  \********************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.QueryUtils = void 0;\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst cross_1 = __webpack_require__(/*! ../cross */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/cross/index.js\");\nconst version_1 = __webpack_require__(/*! ../version */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/version.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/utils.js\");\nclass QueryUtils {\n    constructor(prisma, options) {\n        this.prisma = prisma;\n        this.options = options;\n    }\n    getIdFields(model) {\n        return (0, cross_1.getIdFields)(this.options.modelMeta, model, true);\n    }\n    makeIdSelection(model) {\n        const idFields = this.getIdFields(model);\n        return Object.assign({}, ...idFields.map((f) => ({ [f.name]: true })));\n    }\n    getEntityIds(model, entityData) {\n        const idFields = this.getIdFields(model);\n        const result = {};\n        for (const idField of idFields) {\n            result[idField.name] = entityData[idField.name];\n        }\n        return result;\n    }\n    /**\n     * Initiates a transaction.\n     */\n    transaction(db, action) {\n        const fullDb = db;\n        if (fullDb['$transaction']) {\n            return fullDb.$transaction((tx) => {\n                tx[Symbol.for('nodejs.util.inspect.custom')] = 'PrismaClient$tx';\n                return action(tx);\n            }, {\n                maxWait: this.options.transactionMaxWait,\n                timeout: this.options.transactionTimeout,\n                isolationLevel: this.options.transactionIsolationLevel,\n            });\n        }\n        else {\n            // already in transaction, don't nest\n            return action(db);\n        }\n    }\n    /**\n     * Builds a reversed query for the given nested path.\n     */\n    buildReversedQuery(context, forMutationPayload = false, unsafeOperation = false) {\n        let result, currQuery;\n        let currField;\n        for (let i = context.nestingPath.length - 1; i >= 0; i--) {\n            const { field, model, where } = context.nestingPath[i];\n            // never modify the original where because it's shared in the structure\n            const visitWhere = Object.assign({}, where);\n            if (model && where) {\n                // make sure composite unique condition is flattened\n                this.flattenGeneratedUniqueField(model, visitWhere);\n            }\n            if (!result) {\n                // first segment (bottom), just use its where clause\n                result = currQuery = Object.assign({}, visitWhere);\n                currField = field;\n            }\n            else {\n                if (!currField) {\n                    throw this.unknownError(`missing field in nested path`);\n                }\n                if (!currField.backLink) {\n                    throw this.unknownError(`field ${currField.type}.${currField.name} doesn't have a backLink`);\n                }\n                const backLinkField = this.getModelField(currField.type, currField.backLink);\n                if (!backLinkField) {\n                    throw this.unknownError(`missing backLink field ${currField.backLink} in ${currField.type}`);\n                }\n                if (backLinkField.isArray && !forMutationPayload) {\n                    // many-side of relationship, wrap with \"some\" query\n                    currQuery[currField.backLink] = { some: Object.assign({}, visitWhere) };\n                    currQuery = currQuery[currField.backLink].some;\n                }\n                else {\n                    const fkMapping = where && backLinkField.isRelationOwner && backLinkField.foreignKeyMapping;\n                    // calculate if we should preserve the relation condition (e.g., { user: { id: 1 } })\n                    const shouldPreserveRelationCondition = \n                    // doing a mutation\n                    forMutationPayload &&\n                        // and it's a safe mutate\n                        !unsafeOperation &&\n                        // and the current segment is the direct parent (the last one is the mutate itself),\n                        // the relation condition should be preserved and will be converted to a \"connect\" later\n                        i === context.nestingPath.length - 2;\n                    if (fkMapping && !shouldPreserveRelationCondition) {\n                        // turn relation condition into foreign key condition, e.g.:\n                        //     { user: { id: 1 } } => { userId: 1 }\n                        for (const [r, fk] of Object.entries(fkMapping)) {\n                            currQuery[fk] = visitWhere[r];\n                        }\n                        if (i > 0) {\n                            // prepare for the next segment\n                            currQuery[currField.backLink] = {};\n                        }\n                    }\n                    else {\n                        // preserve the original structure\n                        currQuery[currField.backLink] = Object.assign({}, visitWhere);\n                    }\n                    if (forMutationPayload && currQuery[currField.backLink]) {\n                        // reconstruct compound unique field\n                        currQuery[currField.backLink] = this.composeCompoundUniqueField(backLinkField.type, currQuery[currField.backLink]);\n                    }\n                    currQuery = currQuery[currField.backLink];\n                }\n                currField = field;\n            }\n        }\n        return result;\n    }\n    /**\n     * Composes a compound unique field from multiple fields. E.g.:  { a: '1', b: '1' } => { a_b: { a: '1', b: '1' } }.\n     */\n    composeCompoundUniqueField(model, fieldData) {\n        const uniqueConstraints = (0, cross_1.getUniqueConstraints)(this.options.modelMeta, model);\n        if (!uniqueConstraints) {\n            return fieldData;\n        }\n        const result = (0, utils_1.clone)(fieldData);\n        for (const [name, constraint] of Object.entries(uniqueConstraints)) {\n            if (constraint.fields.length > 1 && constraint.fields.every((f) => fieldData[f] !== undefined)) {\n                // multi-field unique constraint, compose it\n                result[name] = constraint.fields.reduce((prev, field) => (Object.assign(Object.assign({}, prev), { [field]: fieldData[field] })), {});\n                constraint.fields.forEach((f) => delete result[f]);\n            }\n        }\n        return result;\n    }\n    /**\n     * Flattens a generated unique field. E.g.: { a_b: { a: '1', b: '1' } } => { a: '1', b: '1' }.\n     */\n    flattenGeneratedUniqueField(model, args) {\n        const uniqueConstraints = (0, cross_1.getUniqueConstraints)(this.options.modelMeta, model);\n        if (uniqueConstraints && Object.keys(uniqueConstraints).length > 0) {\n            for (const [field, value] of Object.entries(args)) {\n                if (uniqueConstraints[field] &&\n                    uniqueConstraints[field].fields.length > 1 &&\n                    typeof value === 'object') {\n                    // multi-field unique constraint, flatten it\n                    delete args[field];\n                    if (value) {\n                        for (const [f, v] of Object.entries(value)) {\n                            args[f] = v;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    validationError(message) {\n        return (0, utils_1.prismaClientValidationError)(this.prisma, this.options.prismaModule, message);\n    }\n    unknownError(message) {\n        return (0, utils_1.prismaClientUnknownRequestError)(this.prisma, this.options.prismaModule, message, {\n            clientVersion: (0, version_1.getVersion)(),\n        });\n    }\n    getModelFields(model) {\n        var _a;\n        return (_a = (0, cross_1.getModelInfo)(this.options.modelMeta, model)) === null || _a === void 0 ? void 0 : _a.fields;\n    }\n    /**\n     * Gets information for a specific model field.\n     */\n    getModelField(model, field) {\n        return (0, cross_1.resolveField)(this.options.modelMeta, model, field);\n    }\n}\nexports.QueryUtils = QueryUtils;\n//# sourceMappingURL=query-utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHplbnN0YWNraHErcnVudGltZUAyLjIuNF9AcHJpc21hK2NsaWVudEA1LjE3LjBfcHJpc21hQDUuMTcuMF8vbm9kZV9tb2R1bGVzL0B6ZW5zdGFja2hxL3J1bnRpbWUvZW5oYW5jZW1lbnRzL3F1ZXJ5LXV0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQjtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLDJKQUFVO0FBQ2xDLGtCQUFrQixtQkFBTyxDQUFDLHlKQUFZO0FBQ3RDLGdCQUFnQixtQkFBTyxDQUFDLGlLQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDRCQUE0QixnQkFBZ0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsUUFBUTtBQUM3RCxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxlQUFlLEdBQUcsZ0JBQWdCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxvQkFBb0IsS0FBSyxlQUFlO0FBQzlHO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxzQkFBc0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsUUFBUSxTQUFTO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVEsVUFBVSxLQUFLO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLGlCQUFpQixLQUFLLE9BQU8sa0JBQWtCO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLFdBQVcsMkJBQTJCLE1BQU07QUFDcEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELE9BQU8sbUJBQW1CLEtBQUssZ0JBQWdCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXJibGlzbS9uZXh0LWpzLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B6ZW5zdGFja2hxK3J1bnRpbWVAMi4yLjRfQHByaXNtYStjbGllbnRANS4xNy4wX3ByaXNtYUA1LjE3LjBfL25vZGVfbW9kdWxlcy9AemVuc3RhY2tocS9ydW50aW1lL2VuaGFuY2VtZW50cy9xdWVyeS11dGlscy5qcz8zYWNlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5RdWVyeVV0aWxzID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuY29uc3QgY3Jvc3NfMSA9IHJlcXVpcmUoXCIuLi9jcm9zc1wiKTtcbmNvbnN0IHZlcnNpb25fMSA9IHJlcXVpcmUoXCIuLi92ZXJzaW9uXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY2xhc3MgUXVlcnlVdGlscyB7XG4gICAgY29uc3RydWN0b3IocHJpc21hLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMucHJpc21hID0gcHJpc21hO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICBnZXRJZEZpZWxkcyhtb2RlbCkge1xuICAgICAgICByZXR1cm4gKDAsIGNyb3NzXzEuZ2V0SWRGaWVsZHMpKHRoaXMub3B0aW9ucy5tb2RlbE1ldGEsIG1vZGVsLCB0cnVlKTtcbiAgICB9XG4gICAgbWFrZUlkU2VsZWN0aW9uKG1vZGVsKSB7XG4gICAgICAgIGNvbnN0IGlkRmllbGRzID0gdGhpcy5nZXRJZEZpZWxkcyhtb2RlbCk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCAuLi5pZEZpZWxkcy5tYXAoKGYpID0+ICh7IFtmLm5hbWVdOiB0cnVlIH0pKSk7XG4gICAgfVxuICAgIGdldEVudGl0eUlkcyhtb2RlbCwgZW50aXR5RGF0YSkge1xuICAgICAgICBjb25zdCBpZEZpZWxkcyA9IHRoaXMuZ2V0SWRGaWVsZHMobW9kZWwpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBpZEZpZWxkIG9mIGlkRmllbGRzKSB7XG4gICAgICAgICAgICByZXN1bHRbaWRGaWVsZC5uYW1lXSA9IGVudGl0eURhdGFbaWRGaWVsZC5uYW1lXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWF0ZXMgYSB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICB0cmFuc2FjdGlvbihkYiwgYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGZ1bGxEYiA9IGRiO1xuICAgICAgICBpZiAoZnVsbERiWyckdHJhbnNhY3Rpb24nXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bGxEYi4kdHJhbnNhY3Rpb24oKHR4KSA9PiB7XG4gICAgICAgICAgICAgICAgdHhbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0gPSAnUHJpc21hQ2xpZW50JHR4JztcbiAgICAgICAgICAgICAgICByZXR1cm4gYWN0aW9uKHR4KTtcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBtYXhXYWl0OiB0aGlzLm9wdGlvbnMudHJhbnNhY3Rpb25NYXhXYWl0LFxuICAgICAgICAgICAgICAgIHRpbWVvdXQ6IHRoaXMub3B0aW9ucy50cmFuc2FjdGlvblRpbWVvdXQsXG4gICAgICAgICAgICAgICAgaXNvbGF0aW9uTGV2ZWw6IHRoaXMub3B0aW9ucy50cmFuc2FjdGlvbklzb2xhdGlvbkxldmVsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBhbHJlYWR5IGluIHRyYW5zYWN0aW9uLCBkb24ndCBuZXN0XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uKGRiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgYSByZXZlcnNlZCBxdWVyeSBmb3IgdGhlIGdpdmVuIG5lc3RlZCBwYXRoLlxuICAgICAqL1xuICAgIGJ1aWxkUmV2ZXJzZWRRdWVyeShjb250ZXh0LCBmb3JNdXRhdGlvblBheWxvYWQgPSBmYWxzZSwgdW5zYWZlT3BlcmF0aW9uID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHJlc3VsdCwgY3VyclF1ZXJ5O1xuICAgICAgICBsZXQgY3VyckZpZWxkO1xuICAgICAgICBmb3IgKGxldCBpID0gY29udGV4dC5uZXN0aW5nUGF0aC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgeyBmaWVsZCwgbW9kZWwsIHdoZXJlIH0gPSBjb250ZXh0Lm5lc3RpbmdQYXRoW2ldO1xuICAgICAgICAgICAgLy8gbmV2ZXIgbW9kaWZ5IHRoZSBvcmlnaW5hbCB3aGVyZSBiZWNhdXNlIGl0J3Mgc2hhcmVkIGluIHRoZSBzdHJ1Y3R1cmVcbiAgICAgICAgICAgIGNvbnN0IHZpc2l0V2hlcmUgPSBPYmplY3QuYXNzaWduKHt9LCB3aGVyZSk7XG4gICAgICAgICAgICBpZiAobW9kZWwgJiYgd2hlcmUpIHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgY29tcG9zaXRlIHVuaXF1ZSBjb25kaXRpb24gaXMgZmxhdHRlbmVkXG4gICAgICAgICAgICAgICAgdGhpcy5mbGF0dGVuR2VuZXJhdGVkVW5pcXVlRmllbGQobW9kZWwsIHZpc2l0V2hlcmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAvLyBmaXJzdCBzZWdtZW50IChib3R0b20pLCBqdXN0IHVzZSBpdHMgd2hlcmUgY2xhdXNlXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY3VyclF1ZXJ5ID0gT2JqZWN0LmFzc2lnbih7fSwgdmlzaXRXaGVyZSk7XG4gICAgICAgICAgICAgICAgY3VyckZpZWxkID0gZmllbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJGaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLnVua25vd25FcnJvcihgbWlzc2luZyBmaWVsZCBpbiBuZXN0ZWQgcGF0aGApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJGaWVsZC5iYWNrTGluaykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLnVua25vd25FcnJvcihgZmllbGQgJHtjdXJyRmllbGQudHlwZX0uJHtjdXJyRmllbGQubmFtZX0gZG9lc24ndCBoYXZlIGEgYmFja0xpbmtgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYmFja0xpbmtGaWVsZCA9IHRoaXMuZ2V0TW9kZWxGaWVsZChjdXJyRmllbGQudHlwZSwgY3VyckZpZWxkLmJhY2tMaW5rKTtcbiAgICAgICAgICAgICAgICBpZiAoIWJhY2tMaW5rRmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy51bmtub3duRXJyb3IoYG1pc3NpbmcgYmFja0xpbmsgZmllbGQgJHtjdXJyRmllbGQuYmFja0xpbmt9IGluICR7Y3VyckZpZWxkLnR5cGV9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChiYWNrTGlua0ZpZWxkLmlzQXJyYXkgJiYgIWZvck11dGF0aW9uUGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYW55LXNpZGUgb2YgcmVsYXRpb25zaGlwLCB3cmFwIHdpdGggXCJzb21lXCIgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgY3VyclF1ZXJ5W2N1cnJGaWVsZC5iYWNrTGlua10gPSB7IHNvbWU6IE9iamVjdC5hc3NpZ24oe30sIHZpc2l0V2hlcmUpIH07XG4gICAgICAgICAgICAgICAgICAgIGN1cnJRdWVyeSA9IGN1cnJRdWVyeVtjdXJyRmllbGQuYmFja0xpbmtdLnNvbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBma01hcHBpbmcgPSB3aGVyZSAmJiBiYWNrTGlua0ZpZWxkLmlzUmVsYXRpb25Pd25lciAmJiBiYWNrTGlua0ZpZWxkLmZvcmVpZ25LZXlNYXBwaW5nO1xuICAgICAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgaWYgd2Ugc2hvdWxkIHByZXNlcnZlIHRoZSByZWxhdGlvbiBjb25kaXRpb24gKGUuZy4sIHsgdXNlcjogeyBpZDogMSB9IH0pXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNob3VsZFByZXNlcnZlUmVsYXRpb25Db25kaXRpb24gPSBcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9pbmcgYSBtdXRhdGlvblxuICAgICAgICAgICAgICAgICAgICBmb3JNdXRhdGlvblBheWxvYWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBpdCdzIGEgc2FmZSBtdXRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICF1bnNhZmVPcGVyYXRpb24gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB0aGUgY3VycmVudCBzZWdtZW50IGlzIHRoZSBkaXJlY3QgcGFyZW50ICh0aGUgbGFzdCBvbmUgaXMgdGhlIG11dGF0ZSBpdHNlbGYpLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHJlbGF0aW9uIGNvbmRpdGlvbiBzaG91bGQgYmUgcHJlc2VydmVkIGFuZCB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIFwiY29ubmVjdFwiIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBpID09PSBjb250ZXh0Lm5lc3RpbmdQYXRoLmxlbmd0aCAtIDI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChma01hcHBpbmcgJiYgIXNob3VsZFByZXNlcnZlUmVsYXRpb25Db25kaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHR1cm4gcmVsYXRpb24gY29uZGl0aW9uIGludG8gZm9yZWlnbiBrZXkgY29uZGl0aW9uLCBlLmcuOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIHsgdXNlcjogeyBpZDogMSB9IH0gPT4geyB1c2VySWQ6IDEgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbciwgZmtdIG9mIE9iamVjdC5lbnRyaWVzKGZrTWFwcGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyUXVlcnlbZmtdID0gdmlzaXRXaGVyZVtyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZXBhcmUgZm9yIHRoZSBuZXh0IHNlZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyUXVlcnlbY3VyckZpZWxkLmJhY2tMaW5rXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJlc2VydmUgdGhlIG9yaWdpbmFsIHN0cnVjdHVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyclF1ZXJ5W2N1cnJGaWVsZC5iYWNrTGlua10gPSBPYmplY3QuYXNzaWduKHt9LCB2aXNpdFdoZXJlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZm9yTXV0YXRpb25QYXlsb2FkICYmIGN1cnJRdWVyeVtjdXJyRmllbGQuYmFja0xpbmtdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWNvbnN0cnVjdCBjb21wb3VuZCB1bmlxdWUgZmllbGRcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJRdWVyeVtjdXJyRmllbGQuYmFja0xpbmtdID0gdGhpcy5jb21wb3NlQ29tcG91bmRVbmlxdWVGaWVsZChiYWNrTGlua0ZpZWxkLnR5cGUsIGN1cnJRdWVyeVtjdXJyRmllbGQuYmFja0xpbmtdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyUXVlcnkgPSBjdXJyUXVlcnlbY3VyckZpZWxkLmJhY2tMaW5rXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VyckZpZWxkID0gZmllbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcG9zZXMgYSBjb21wb3VuZCB1bmlxdWUgZmllbGQgZnJvbSBtdWx0aXBsZSBmaWVsZHMuIEUuZy46ICB7IGE6ICcxJywgYjogJzEnIH0gPT4geyBhX2I6IHsgYTogJzEnLCBiOiAnMScgfSB9LlxuICAgICAqL1xuICAgIGNvbXBvc2VDb21wb3VuZFVuaXF1ZUZpZWxkKG1vZGVsLCBmaWVsZERhdGEpIHtcbiAgICAgICAgY29uc3QgdW5pcXVlQ29uc3RyYWludHMgPSAoMCwgY3Jvc3NfMS5nZXRVbmlxdWVDb25zdHJhaW50cykodGhpcy5vcHRpb25zLm1vZGVsTWV0YSwgbW9kZWwpO1xuICAgICAgICBpZiAoIXVuaXF1ZUNvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmllbGREYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9ICgwLCB1dGlsc18xLmNsb25lKShmaWVsZERhdGEpO1xuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBjb25zdHJhaW50XSBvZiBPYmplY3QuZW50cmllcyh1bmlxdWVDb25zdHJhaW50cykpIHtcbiAgICAgICAgICAgIGlmIChjb25zdHJhaW50LmZpZWxkcy5sZW5ndGggPiAxICYmIGNvbnN0cmFpbnQuZmllbGRzLmV2ZXJ5KChmKSA9PiBmaWVsZERhdGFbZl0gIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICAvLyBtdWx0aS1maWVsZCB1bmlxdWUgY29uc3RyYWludCwgY29tcG9zZSBpdFxuICAgICAgICAgICAgICAgIHJlc3VsdFtuYW1lXSA9IGNvbnN0cmFpbnQuZmllbGRzLnJlZHVjZSgocHJldiwgZmllbGQpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByZXYpLCB7IFtmaWVsZF06IGZpZWxkRGF0YVtmaWVsZF0gfSkpLCB7fSk7XG4gICAgICAgICAgICAgICAgY29uc3RyYWludC5maWVsZHMuZm9yRWFjaCgoZikgPT4gZGVsZXRlIHJlc3VsdFtmXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmxhdHRlbnMgYSBnZW5lcmF0ZWQgdW5pcXVlIGZpZWxkLiBFLmcuOiB7IGFfYjogeyBhOiAnMScsIGI6ICcxJyB9IH0gPT4geyBhOiAnMScsIGI6ICcxJyB9LlxuICAgICAqL1xuICAgIGZsYXR0ZW5HZW5lcmF0ZWRVbmlxdWVGaWVsZChtb2RlbCwgYXJncykge1xuICAgICAgICBjb25zdCB1bmlxdWVDb25zdHJhaW50cyA9ICgwLCBjcm9zc18xLmdldFVuaXF1ZUNvbnN0cmFpbnRzKSh0aGlzLm9wdGlvbnMubW9kZWxNZXRhLCBtb2RlbCk7XG4gICAgICAgIGlmICh1bmlxdWVDb25zdHJhaW50cyAmJiBPYmplY3Qua2V5cyh1bmlxdWVDb25zdHJhaW50cykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbZmllbGQsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhcmdzKSkge1xuICAgICAgICAgICAgICAgIGlmICh1bmlxdWVDb25zdHJhaW50c1tmaWVsZF0gJiZcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlQ29uc3RyYWludHNbZmllbGRdLmZpZWxkcy5sZW5ndGggPiAxICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbXVsdGktZmllbGQgdW5pcXVlIGNvbnN0cmFpbnQsIGZsYXR0ZW4gaXRcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGFyZ3NbZmllbGRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2YsIHZdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbZl0gPSB2O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZhbGlkYXRpb25FcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5wcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IpKHRoaXMucHJpc21hLCB0aGlzLm9wdGlvbnMucHJpc21hTW9kdWxlLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgdW5rbm93bkVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLnByaXNtYUNsaWVudFVua25vd25SZXF1ZXN0RXJyb3IpKHRoaXMucHJpc21hLCB0aGlzLm9wdGlvbnMucHJpc21hTW9kdWxlLCBtZXNzYWdlLCB7XG4gICAgICAgICAgICBjbGllbnRWZXJzaW9uOiAoMCwgdmVyc2lvbl8xLmdldFZlcnNpb24pKCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRNb2RlbEZpZWxkcyhtb2RlbCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSAoMCwgY3Jvc3NfMS5nZXRNb2RlbEluZm8pKHRoaXMub3B0aW9ucy5tb2RlbE1ldGEsIG1vZGVsKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpZWxkcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBpbmZvcm1hdGlvbiBmb3IgYSBzcGVjaWZpYyBtb2RlbCBmaWVsZC5cbiAgICAgKi9cbiAgICBnZXRNb2RlbEZpZWxkKG1vZGVsLCBmaWVsZCkge1xuICAgICAgICByZXR1cm4gKDAsIGNyb3NzXzEucmVzb2x2ZUZpZWxkKSh0aGlzLm9wdGlvbnMubW9kZWxNZXRhLCBtb2RlbCwgZmllbGQpO1xuICAgIH1cbn1cbmV4cG9ydHMuUXVlcnlVdGlscyA9IFF1ZXJ5VXRpbHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/query-utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/types.js":
/*!**************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/types.js ***!
  \**************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHplbnN0YWNraHErcnVudGltZUAyLjIuNF9AcHJpc21hK2NsaWVudEA1LjE3LjBfcHJpc21hQDUuMTcuMF8vbm9kZV9tb2R1bGVzL0B6ZW5zdGFja2hxL3J1bnRpbWUvZW5oYW5jZW1lbnRzL3R5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hcmJsaXNtL25leHQtanMvLi9ub2RlX21vZHVsZXMvLnBucG0vQHplbnN0YWNraHErcnVudGltZUAyLjIuNF9AcHJpc21hK2NsaWVudEA1LjE3LjBfcHJpc21hQDUuMTcuMF8vbm9kZV9tb2R1bGVzL0B6ZW5zdGFja2hxL3J1bnRpbWUvZW5oYW5jZW1lbnRzL3R5cGVzLmpzPzE4OTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/utils.js":
/*!**************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/utils.js ***!
  \**************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.clone = exports.isAutoIncrementIdField = exports.isUnsafeMutate = exports.prismaClientUnknownRequestError = exports.prismaClientKnownRequestError = exports.prismaClientValidationError = exports.formatObject = void 0;\nconst deepcopy_1 = __importDefault(__webpack_require__(/*! deepcopy */ \"(rsc)/./node_modules/.pnpm/deepcopy@2.1.0/node_modules/deepcopy/index.mjs\"));\nconst safe_json_stringify_1 = __importDefault(__webpack_require__(/*! safe-json-stringify */ \"(rsc)/./node_modules/.pnpm/safe-json-stringify@1.2.0/node_modules/safe-json-stringify/index.js\"));\nconst __1 = __webpack_require__(/*! .. */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/index.js\");\n/**\n * Formats an object for pretty printing.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction formatObject(value, multiLine = true) {\n    return multiLine ? (0, safe_json_stringify_1.default)(value, undefined, 2) : (0, safe_json_stringify_1.default)(value);\n}\nexports.formatObject = formatObject;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction prismaClientValidationError(prisma, prismaModule, message) {\n    throw new prismaModule.PrismaClientValidationError(message, { clientVersion: prisma._clientVersion });\n}\nexports.prismaClientValidationError = prismaClientValidationError;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction prismaClientKnownRequestError(prisma, prismaModule, ...args) {\n    return new prismaModule.PrismaClientKnownRequestError(...args);\n}\nexports.prismaClientKnownRequestError = prismaClientKnownRequestError;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction prismaClientUnknownRequestError(prismaModule, ...args) {\n    throw new prismaModule.PrismaClientUnknownRequestError(...args);\n}\nexports.prismaClientUnknownRequestError = prismaClientUnknownRequestError;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isUnsafeMutate(model, args, modelMeta) {\n    if (!args) {\n        return false;\n    }\n    for (const k of Object.keys(args)) {\n        const field = (0, __1.resolveField)(modelMeta, model, k);\n        if (field && (isAutoIncrementIdField(field) || field.isForeignKey)) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.isUnsafeMutate = isUnsafeMutate;\nfunction isAutoIncrementIdField(field) {\n    return field.isId && field.isAutoIncrement;\n}\nexports.isAutoIncrementIdField = isAutoIncrementIdField;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction clone(value) {\n    return value ? (0, deepcopy_1.default)(value) : {};\n}\nexports.clone = clone;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHplbnN0YWNraHErcnVudGltZUAyLjIuNF9AcHJpc21hK2NsaWVudEA1LjE3LjBfcHJpc21hQDUuMTcuMF8vbm9kZV9tb2R1bGVzL0B6ZW5zdGFja2hxL3J1bnRpbWUvZW5oYW5jZW1lbnRzL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxHQUFHLDhCQUE4QixHQUFHLHNCQUFzQixHQUFHLHVDQUF1QyxHQUFHLHFDQUFxQyxHQUFHLG1DQUFtQyxHQUFHLG9CQUFvQjtBQUN0TixtQ0FBbUMsbUJBQU8sQ0FBQywyRkFBVTtBQUNyRCw4Q0FBOEMsbUJBQU8sQ0FBQywySEFBcUI7QUFDM0UsWUFBWSxtQkFBTyxDQUFDLCtJQUFJO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxrRUFBa0Usc0NBQXNDO0FBQ3hHO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXJibGlzbS9uZXh0LWpzLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B6ZW5zdGFja2hxK3J1bnRpbWVAMi4yLjRfQHByaXNtYStjbGllbnRANS4xNy4wX3ByaXNtYUA1LjE3LjBfL25vZGVfbW9kdWxlcy9AemVuc3RhY2tocS9ydW50aW1lL2VuaGFuY2VtZW50cy91dGlscy5qcz81OGE1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jbG9uZSA9IGV4cG9ydHMuaXNBdXRvSW5jcmVtZW50SWRGaWVsZCA9IGV4cG9ydHMuaXNVbnNhZmVNdXRhdGUgPSBleHBvcnRzLnByaXNtYUNsaWVudFVua25vd25SZXF1ZXN0RXJyb3IgPSBleHBvcnRzLnByaXNtYUNsaWVudEtub3duUmVxdWVzdEVycm9yID0gZXhwb3J0cy5wcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IgPSBleHBvcnRzLmZvcm1hdE9iamVjdCA9IHZvaWQgMDtcbmNvbnN0IGRlZXBjb3B5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlZXBjb3B5XCIpKTtcbmNvbnN0IHNhZmVfanNvbl9zdHJpbmdpZnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwic2FmZS1qc29uLXN0cmluZ2lmeVwiKSk7XG5jb25zdCBfXzEgPSByZXF1aXJlKFwiLi5cIik7XG4vKipcbiAqIEZvcm1hdHMgYW4gb2JqZWN0IGZvciBwcmV0dHkgcHJpbnRpbmcuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBmb3JtYXRPYmplY3QodmFsdWUsIG11bHRpTGluZSA9IHRydWUpIHtcbiAgICByZXR1cm4gbXVsdGlMaW5lID8gKDAsIHNhZmVfanNvbl9zdHJpbmdpZnlfMS5kZWZhdWx0KSh2YWx1ZSwgdW5kZWZpbmVkLCAyKSA6ICgwLCBzYWZlX2pzb25fc3RyaW5naWZ5XzEuZGVmYXVsdCkodmFsdWUpO1xufVxuZXhwb3J0cy5mb3JtYXRPYmplY3QgPSBmb3JtYXRPYmplY3Q7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gcHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yKHByaXNtYSwgcHJpc21hTW9kdWxlLCBtZXNzYWdlKSB7XG4gICAgdGhyb3cgbmV3IHByaXNtYU1vZHVsZS5QcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IobWVzc2FnZSwgeyBjbGllbnRWZXJzaW9uOiBwcmlzbWEuX2NsaWVudFZlcnNpb24gfSk7XG59XG5leHBvcnRzLnByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvciA9IHByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvcjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBwcmlzbWFDbGllbnRLbm93blJlcXVlc3RFcnJvcihwcmlzbWEsIHByaXNtYU1vZHVsZSwgLi4uYXJncykge1xuICAgIHJldHVybiBuZXcgcHJpc21hTW9kdWxlLlByaXNtYUNsaWVudEtub3duUmVxdWVzdEVycm9yKC4uLmFyZ3MpO1xufVxuZXhwb3J0cy5wcmlzbWFDbGllbnRLbm93blJlcXVlc3RFcnJvciA9IHByaXNtYUNsaWVudEtub3duUmVxdWVzdEVycm9yO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIHByaXNtYUNsaWVudFVua25vd25SZXF1ZXN0RXJyb3IocHJpc21hTW9kdWxlLCAuLi5hcmdzKSB7XG4gICAgdGhyb3cgbmV3IHByaXNtYU1vZHVsZS5QcmlzbWFDbGllbnRVbmtub3duUmVxdWVzdEVycm9yKC4uLmFyZ3MpO1xufVxuZXhwb3J0cy5wcmlzbWFDbGllbnRVbmtub3duUmVxdWVzdEVycm9yID0gcHJpc21hQ2xpZW50VW5rbm93blJlcXVlc3RFcnJvcjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBpc1Vuc2FmZU11dGF0ZShtb2RlbCwgYXJncywgbW9kZWxNZXRhKSB7XG4gICAgaWYgKCFhcmdzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrIG9mIE9iamVjdC5rZXlzKGFyZ3MpKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gKDAsIF9fMS5yZXNvbHZlRmllbGQpKG1vZGVsTWV0YSwgbW9kZWwsIGspO1xuICAgICAgICBpZiAoZmllbGQgJiYgKGlzQXV0b0luY3JlbWVudElkRmllbGQoZmllbGQpIHx8IGZpZWxkLmlzRm9yZWlnbktleSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuaXNVbnNhZmVNdXRhdGUgPSBpc1Vuc2FmZU11dGF0ZTtcbmZ1bmN0aW9uIGlzQXV0b0luY3JlbWVudElkRmllbGQoZmllbGQpIHtcbiAgICByZXR1cm4gZmllbGQuaXNJZCAmJiBmaWVsZC5pc0F1dG9JbmNyZW1lbnQ7XG59XG5leHBvcnRzLmlzQXV0b0luY3JlbWVudElkRmllbGQgPSBpc0F1dG9JbmNyZW1lbnRJZEZpZWxkO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIGNsb25lKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID8gKDAsIGRlZXBjb3B5XzEuZGVmYXVsdCkodmFsdWUpIDoge307XG59XG5leHBvcnRzLmNsb25lID0gY2xvbmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/error.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/error.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isPrismaClientValidationError = exports.isPrismaClientUnknownRequestError = exports.isPrismaClientKnownRequestError = void 0;\n/* eslint-disable @typescript-eslint/no-explicit-any */\nfunction isPrismaClientKnownRequestError(err) {\n    return findConstructorName(err.__proto__, 'PrismaClientKnownRequestError');\n}\nexports.isPrismaClientKnownRequestError = isPrismaClientKnownRequestError;\nfunction isPrismaClientUnknownRequestError(err) {\n    return findConstructorName(err.__proto__, 'PrismaClientUnknownRequestError');\n}\nexports.isPrismaClientUnknownRequestError = isPrismaClientUnknownRequestError;\nfunction isPrismaClientValidationError(err) {\n    return findConstructorName(err.__proto__, 'PrismaClientValidationError');\n}\nexports.isPrismaClientValidationError = isPrismaClientValidationError;\nfunction findConstructorName(proto, name) {\n    if (!proto) {\n        return false;\n    }\n    return proto.constructor.name === name || findConstructorName(proto.__proto__, name);\n}\n//# sourceMappingURL=error.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHplbnN0YWNraHErcnVudGltZUAyLjIuNF9AcHJpc21hK2NsaWVudEA1LjE3LjBfcHJpc21hQDUuMTcuMF8vbm9kZV9tb2R1bGVzL0B6ZW5zdGFja2hxL3J1bnRpbWUvZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUNBQXFDLEdBQUcseUNBQXlDLEdBQUcsdUNBQXVDO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbWFyYmxpc20vbmV4dC1qcy8uL25vZGVfbW9kdWxlcy8ucG5wbS9AemVuc3RhY2tocStydW50aW1lQDIuMi40X0BwcmlzbWErY2xpZW50QDUuMTcuMF9wcmlzbWFANS4xNy4wXy9ub2RlX21vZHVsZXMvQHplbnN0YWNraHEvcnVudGltZS9lcnJvci5qcz9lNTAyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc1ByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvciA9IGV4cG9ydHMuaXNQcmlzbWFDbGllbnRVbmtub3duUmVxdWVzdEVycm9yID0gZXhwb3J0cy5pc1ByaXNtYUNsaWVudEtub3duUmVxdWVzdEVycm9yID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuZnVuY3Rpb24gaXNQcmlzbWFDbGllbnRLbm93blJlcXVlc3RFcnJvcihlcnIpIHtcbiAgICByZXR1cm4gZmluZENvbnN0cnVjdG9yTmFtZShlcnIuX19wcm90b19fLCAnUHJpc21hQ2xpZW50S25vd25SZXF1ZXN0RXJyb3InKTtcbn1cbmV4cG9ydHMuaXNQcmlzbWFDbGllbnRLbm93blJlcXVlc3RFcnJvciA9IGlzUHJpc21hQ2xpZW50S25vd25SZXF1ZXN0RXJyb3I7XG5mdW5jdGlvbiBpc1ByaXNtYUNsaWVudFVua25vd25SZXF1ZXN0RXJyb3IoZXJyKSB7XG4gICAgcmV0dXJuIGZpbmRDb25zdHJ1Y3Rvck5hbWUoZXJyLl9fcHJvdG9fXywgJ1ByaXNtYUNsaWVudFVua25vd25SZXF1ZXN0RXJyb3InKTtcbn1cbmV4cG9ydHMuaXNQcmlzbWFDbGllbnRVbmtub3duUmVxdWVzdEVycm9yID0gaXNQcmlzbWFDbGllbnRVbmtub3duUmVxdWVzdEVycm9yO1xuZnVuY3Rpb24gaXNQcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IoZXJyKSB7XG4gICAgcmV0dXJuIGZpbmRDb25zdHJ1Y3Rvck5hbWUoZXJyLl9fcHJvdG9fXywgJ1ByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvcicpO1xufVxuZXhwb3J0cy5pc1ByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvciA9IGlzUHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yO1xuZnVuY3Rpb24gZmluZENvbnN0cnVjdG9yTmFtZShwcm90bywgbmFtZSkge1xuICAgIGlmICghcHJvdG8pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gcHJvdG8uY29uc3RydWN0b3IubmFtZSA9PT0gbmFtZSB8fCBmaW5kQ29uc3RydWN0b3JOYW1lKHByb3RvLl9fcHJvdG9fXywgbmFtZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/index.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/index.js ***!
  \*************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/constants.js\"), exports);\n__exportStar(__webpack_require__(/*! ./enhancements */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhancements/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./error */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/error.js\"), exports);\n__exportStar(__webpack_require__(/*! ./types */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/types.js\"), exports);\n__exportStar(__webpack_require__(/*! ./validation */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/validation.js\"), exports);\n__exportStar(__webpack_require__(/*! ./version */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/version.js\"), exports);\n__exportStar(__webpack_require__(/*! ./enhance */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/enhance.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHplbnN0YWNraHErcnVudGltZUAyLjIuNF9AcHJpc21hK2NsaWVudEA1LjE3LjBfcHJpc21hQDUuMTcuMF8vbm9kZV9tb2R1bGVzL0B6ZW5zdGFja2hxL3J1bnRpbWUvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLDRKQUFhO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyx3S0FBZ0I7QUFDckMsYUFBYSxtQkFBTyxDQUFDLG9KQUFTO0FBQzlCLGFBQWEsbUJBQU8sQ0FBQyxvSkFBUztBQUM5QixhQUFhLG1CQUFPLENBQUMsOEpBQWM7QUFDbkMsYUFBYSxtQkFBTyxDQUFDLHdKQUFXO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyx3SkFBVztBQUNoQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXJibGlzbS9uZXh0LWpzLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B6ZW5zdGFja2hxK3J1bnRpbWVAMi4yLjRfQHByaXNtYStjbGllbnRANS4xNy4wX3ByaXNtYUA1LjE3LjBfL25vZGVfbW9kdWxlcy9AemVuc3RhY2tocS9ydW50aW1lL2luZGV4LmpzPzEzMTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb25zdGFudHNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2VuaGFuY2VtZW50c1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXJyb3JcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3R5cGVzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YWxpZGF0aW9uXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92ZXJzaW9uXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9lbmhhbmNlXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/types.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/types.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/* eslint-disable @typescript-eslint/no-explicit-any */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHplbnN0YWNraHErcnVudGltZUAyLjIuNF9AcHJpc21hK2NsaWVudEA1LjE3LjBfcHJpc21hQDUuMTcuMF8vbm9kZV9tb2R1bGVzL0B6ZW5zdGFja2hxL3J1bnRpbWUvdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXJibGlzbS9uZXh0LWpzLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B6ZW5zdGFja2hxK3J1bnRpbWVAMi4yLjRfQHByaXNtYStjbGllbnRANS4xNy4wX3ByaXNtYUA1LjE3LjBfL25vZGVfbW9kdWxlcy9AemVuc3RhY2tocS9ydW50aW1lL3R5cGVzLmpzP2E4MTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/validation.js":
/*!******************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/validation.js ***!
  \******************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.allFieldsEqual = exports.hasAllFields = exports.validate = exports.ValidationError = void 0;\nconst zod_validation_error_1 = __webpack_require__(/*! zod-validation-error */ \"(rsc)/./node_modules/.pnpm/zod-validation-error@1.5.0_zod@3.23.8/node_modules/zod-validation-error/dist/esm/index.js\");\n/**\n * Error indicating violations of field-level constraints\n */\nclass ValidationError {\n    constructor(message) {\n        this.message = message;\n    }\n}\nexports.ValidationError = ValidationError;\n/**\n * Validate the given data with the given zod schema (for field-level constraints)\n */\nfunction validate(validator, data) {\n    try {\n        validator.parse(data);\n    }\n    catch (err) {\n        throw new ValidationError((0, zod_validation_error_1.fromZodError)(err).message);\n    }\n}\nexports.validate = validate;\n/**\n * Check if the given object has all the given fields, not null or undefined\n * @param obj\n * @param fields\n * @returns\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction hasAllFields(obj, fields) {\n    if (typeof obj !== 'object' || !obj) {\n        return false;\n    }\n    return fields.every((f) => obj[f] !== undefined && obj[f] !== null);\n}\nexports.hasAllFields = hasAllFields;\n/**\n * Check if the given objects have equal values for the given fields. Returns\n * false if either object is nullish or is not an object.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction allFieldsEqual(obj1, obj2, fields) {\n    if (!obj1 || !obj2 || typeof obj1 !== 'object' || typeof obj2 !== 'object') {\n        return false;\n    }\n    return fields.every((f) => obj1[f] === obj2[f]);\n}\nexports.allFieldsEqual = allFieldsEqual;\n//# sourceMappingURL=validation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHplbnN0YWNraHErcnVudGltZUAyLjIuNF9AcHJpc21hK2NsaWVudEA1LjE3LjBfcHJpc21hQDUuMTcuMF8vbm9kZV9tb2R1bGVzL0B6ZW5zdGFja2hxL3J1bnRpbWUvdmFsaWRhdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsR0FBRyxvQkFBb0IsR0FBRyxnQkFBZ0IsR0FBRyx1QkFBdUI7QUFDMUYsK0JBQStCLG1CQUFPLENBQUMsa0pBQXNCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hcmJsaXNtL25leHQtanMvLi9ub2RlX21vZHVsZXMvLnBucG0vQHplbnN0YWNraHErcnVudGltZUAyLjIuNF9AcHJpc21hK2NsaWVudEA1LjE3LjBfcHJpc21hQDUuMTcuMF8vbm9kZV9tb2R1bGVzL0B6ZW5zdGFja2hxL3J1bnRpbWUvdmFsaWRhdGlvbi5qcz9iNTY4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hbGxGaWVsZHNFcXVhbCA9IGV4cG9ydHMuaGFzQWxsRmllbGRzID0gZXhwb3J0cy52YWxpZGF0ZSA9IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yID0gdm9pZCAwO1xuY29uc3Qgem9kX3ZhbGlkYXRpb25fZXJyb3JfMSA9IHJlcXVpcmUoXCJ6b2QtdmFsaWRhdGlvbi1lcnJvclwiKTtcbi8qKlxuICogRXJyb3IgaW5kaWNhdGluZyB2aW9sYXRpb25zIG9mIGZpZWxkLWxldmVsIGNvbnN0cmFpbnRzXG4gKi9cbmNsYXNzIFZhbGlkYXRpb25FcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFsaWRhdGlvbkVycm9yID0gVmFsaWRhdGlvbkVycm9yO1xuLyoqXG4gKiBWYWxpZGF0ZSB0aGUgZ2l2ZW4gZGF0YSB3aXRoIHRoZSBnaXZlbiB6b2Qgc2NoZW1hIChmb3IgZmllbGQtbGV2ZWwgY29uc3RyYWludHMpXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlKHZhbGlkYXRvciwgZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhbGlkYXRvci5wYXJzZShkYXRhKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKCgwLCB6b2RfdmFsaWRhdGlvbl9lcnJvcl8xLmZyb21ab2RFcnJvcikoZXJyKS5tZXNzYWdlKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlID0gdmFsaWRhdGU7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBvYmplY3QgaGFzIGFsbCB0aGUgZ2l2ZW4gZmllbGRzLCBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAqIEBwYXJhbSBvYmpcbiAqIEBwYXJhbSBmaWVsZHNcbiAqIEByZXR1cm5zXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBoYXNBbGxGaWVsZHMob2JqLCBmaWVsZHMpIHtcbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgIW9iaikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBmaWVsZHMuZXZlcnkoKGYpID0+IG9ialtmXSAhPT0gdW5kZWZpbmVkICYmIG9ialtmXSAhPT0gbnVsbCk7XG59XG5leHBvcnRzLmhhc0FsbEZpZWxkcyA9IGhhc0FsbEZpZWxkcztcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIG9iamVjdHMgaGF2ZSBlcXVhbCB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBmaWVsZHMuIFJldHVybnNcbiAqIGZhbHNlIGlmIGVpdGhlciBvYmplY3QgaXMgbnVsbGlzaCBvciBpcyBub3QgYW4gb2JqZWN0LlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gYWxsRmllbGRzRXF1YWwob2JqMSwgb2JqMiwgZmllbGRzKSB7XG4gICAgaWYgKCFvYmoxIHx8ICFvYmoyIHx8IHR5cGVvZiBvYmoxICE9PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqMiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmllbGRzLmV2ZXJ5KChmKSA9PiBvYmoxW2ZdID09PSBvYmoyW2ZdKTtcbn1cbmV4cG9ydHMuYWxsRmllbGRzRXF1YWwgPSBhbGxGaWVsZHNFcXVhbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbGlkYXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/validation.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/version.js":
/*!***************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/version.js ***!
  \***************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getVersion = void 0;\nconst pkgJson = __importStar(__webpack_require__(/*! ./package.json */ \"(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/package.json\"));\n/**\n * Gets this package's version.\n * @returns\n */\nfunction getVersion() {\n    return pkgJson.version;\n}\nexports.getVersion = getVersion;\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHplbnN0YWNraHErcnVudGltZUAyLjIuNF9AcHJpc21hK2NsaWVudEA1LjE3LjBfcHJpc21hQDUuMTcuMF8vbm9kZV9tb2R1bGVzL0B6ZW5zdGFja2hxL3J1bnRpbWUvdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLDZCQUE2QixtQkFBTyxDQUFDLCtKQUFnQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BtYXJibGlzbS9uZXh0LWpzLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B6ZW5zdGFja2hxK3J1bnRpbWVAMi4yLjRfQHByaXNtYStjbGllbnRANS4xNy4wX3ByaXNtYUA1LjE3LjBfL25vZGVfbW9kdWxlcy9AemVuc3RhY2tocS9ydW50aW1lL3ZlcnNpb24uanM/NTgxOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRWZXJzaW9uID0gdm9pZCAwO1xuY29uc3QgcGtnSnNvbiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9wYWNrYWdlLmpzb25cIikpO1xuLyoqXG4gKiBHZXRzIHRoaXMgcGFja2FnZSdzIHZlcnNpb24uXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBnZXRWZXJzaW9uKCkge1xuICAgIHJldHVybiBwa2dKc29uLnZlcnNpb247XG59XG5leHBvcnRzLmdldFZlcnNpb24gPSBnZXRWZXJzaW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/version.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/zod/input.js":
/*!*****************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/zod/input.js ***!
  \*****************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("let schemas;\ntry {\n    schemas = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '.zenstack/zod/input'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n} catch {}\n\nmodule.exports = schemas && {\n    ...schemas,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHplbnN0YWNraHErcnVudGltZUAyLjIuNF9AcHJpc21hK2NsaWVudEA1LjE3LjBfcHJpc21hQDUuMTcuMF8vbm9kZV9tb2R1bGVzL0B6ZW5zdGFja2hxL3J1bnRpbWUvem9kL2lucHV0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsa0pBQXFCO0FBQzNDLEVBQUU7O0FBRUY7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQG1hcmJsaXNtL25leHQtanMvLi9ub2RlX21vZHVsZXMvLnBucG0vQHplbnN0YWNraHErcnVudGltZUAyLjIuNF9AcHJpc21hK2NsaWVudEA1LjE3LjBfcHJpc21hQDUuMTcuMF8vbm9kZV9tb2R1bGVzL0B6ZW5zdGFja2hxL3J1bnRpbWUvem9kL2lucHV0LmpzPzI1YmUiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IHNjaGVtYXM7XG50cnkge1xuICAgIHNjaGVtYXMgPSByZXF1aXJlKCcuemVuc3RhY2svem9kL2lucHV0Jyk7XG59IGNhdGNoIHt9XG5cbm1vZHVsZS5leHBvcnRzID0gc2NoZW1hcyAmJiB7XG4gICAgLi4uc2NoZW1hcyxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/zod/input.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/package.json":
/*!*****************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@zenstackhq+runtime@2.2.4_@prisma+client@5.17.0_prisma@5.17.0_/node_modules/@zenstackhq/runtime/package.json ***!
  \*****************************************************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"@zenstackhq/runtime","displayName":"ZenStack Runtime Library","version":"2.2.4","description":"Runtime of ZenStack for both client-side and server-side environments.","repository":{"type":"git","url":"https://github.com/zenstackhq/zenstack"},"main":"index.js","types":"index.d.ts","exports":{".":{"types":"./index.d.ts","default":"./index.js"},"./edge":{"types":"./edge.d.ts","default":"./edge.js"},"./enhancements":{"types":"./enhancements/index.d.ts","default":"./enhancements/index.js"},"./constraint-solver":{"types":"./constraint-solver.d.ts","default":"./constraint-solver.js"},"./zod":{"types":"./zod/index.d.ts","default":"./zod/index.js"},"./zod/input":{"types":"./zod/input.d.ts","default":"./zod/input.js"},"./zod/models":{"types":"./zod/models.d.ts","default":"./zod/models.js"},"./zod/objects":{"types":"./zod/objects.d.ts","default":"./zod/objects.js"},"./browser":{"types":"./browser/index.d.ts","import":"./browser/index.mjs","require":"./browser/index.js","default":"./browser/index.js"},"./cross":{"types":"./cross/index.d.ts","import":"./cross/index.mjs","require":"./cross/index.js","default":"./cross/index.js"},"./model-meta":{"types":"./model-meta.d.ts","default":"./model-meta.js"},"./models":{"types":"./models.d.ts"},"./package.json":{"default":"./package.json"}},"publishConfig":{"directory":"dist","linkDirectory":true},"dependencies":{"bcryptjs":"^2.4.3","buffer":"^6.0.3","change-case":"^4.1.2","decimal.js":"^10.4.2","deepcopy":"^2.1.0","deepmerge":"^4.3.1","is-plain-object":"^5.0.0","logic-solver":"^2.0.1","lower-case-first":"^2.0.2","pluralize":"^8.0.0","safe-json-stringify":"^1.2.0","semver":"^7.5.2","superjson":"^1.11.0","tiny-invariant":"^1.3.1","ts-pattern":"^4.3.0","tslib":"^2.4.1","upper-case-first":"^2.0.2","uuid":"^9.0.0","zod":"^3.22.4","zod-validation-error":"^1.5.0"},"peerDependencies":{"@prisma/client":"5.0.0 - 5.15.x"},"author":{"name":"ZenStack Team"},"homepage":"https://zenstack.dev","license":"MIT","devDependencies":{"@types/bcryptjs":"^2.4.2","@types/pluralize":"^0.0.29","@types/safe-json-stringify":"^1.1.5","@types/semver":"^7.3.13","@types/uuid":"^8.3.4"},"scripts":{"clean":"rimraf dist","build":"pnpm lint --max-warnings=0 && pnpm clean && tsc && tsup-node --config ./tsup-browser.config.ts && tsup-node --config ./tsup-cross.config.ts && copyfiles ./package.json ./README.md ../../LICENSE dist && copyfiles -u1 \\"res/**/*\\" dist && pnpm pack dist --pack-destination ../../../.build","watch":"concurrently \\"tsc --watch\\" \\"tsup-node --config ./tsup-browser.config.ts --watch\\" \\"tsup-node --config ./tsup-cross.config.ts --watch\\"","lint":"eslint src --ext ts"}}');

/***/ })

};
;